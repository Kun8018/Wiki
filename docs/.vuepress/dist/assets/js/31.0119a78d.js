(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{388:function(t,e,s){"use strict";s.r(e);var v=s(44),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[t._v("​      把一些前后端概念性比较强的理念放在这里，不放代码，不提供案例，仅供理解核心概念参考。")]),t._v(" "),s("p",[t._v("https://segmentfault.com/a/1190000038774393?utm_source=sf-related")]),t._v(" "),s("h2",{attrs:{id:"前端代码打包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端代码打包"}},[t._v("#")]),t._v(" 前端代码打包")]),t._v(" "),s("h2",{attrs:{id:"前端bundleless"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端bundleless"}},[t._v("#")]),t._v(" 前端bundleless")]),t._v(" "),s("p",[t._v("随着业务的发展，前端代码的复杂度越来越高，构建方面展露新的问题：")]),t._v(" "),s("p",[t._v("过去需要打包的原因：")]),t._v(" "),s("p",[t._v("1.http1.1各浏览器有并行连接限制")]),t._v(" "),s("p",[t._v("2.浏览器不支持模块系统(如commonjs不能在浏览器直接运行)")]),t._v(" "),s("p",[t._v("3.代码依赖关系与顺序管理")]),t._v(" "),s("p",[t._v("可以开始不打包的原因：")]),t._v(" "),s("p",[t._v("1.http2.0多路并用")]),t._v(" "),s("p",[t._v("2.各大浏览器逐一支持ESM")]),t._v(" "),s("p",[t._v("3.越来越多的npm包拥抱ESM(尽管还有很多包不是)")]),t._v(" "),s("p",[t._v("目前构建主要分为两种：")]),t._v(" "),s("p",[t._v("1是基于服务的构建方式。通常服务于实际生产。可以再细分成本地服务构建与远端服务构建。本地服务构建就是我们常规的操作，基本被webpack统治，是bundle方案的代表，snowpack、Vite、Web Dev Server是目前比较火的Bundleless方案，发展迅猛。远端服务构建则是依托云能力的玩法，把构建过程放在服务端完成。")]),t._v(" "),s("p",[t._v("2是基于浏览器的构建方式。通常面向Demo的快速搭建或预览方案。Codesandbox、StackBlitz、CodePen和Riddel是业内比较出色的方案。整体是在浏览器端实现代码的编译、打包、构建和运行。")])])}),[],!1,null,null,null);e.default=_.exports}}]);