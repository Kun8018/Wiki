(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{391:function(t,s,a){"use strict";a.r(s);var n=a(44),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),a("p",[t._v("​      把一些前后端概念性比较强的理念放在这里，不放代码，不提供案例，仅供理解核心概念参考。")]),t._v(" "),a("p",[t._v("https://segmentfault.com/a/1190000038774393?utm_source=sf-related")]),t._v(" "),a("h2",{attrs:{id:"微服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务"}},[t._v("#")]),t._v(" 微服务")]),t._v(" "),a("h2",{attrs:{id:"ci-cd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ci-cd"}},[t._v("#")]),t._v(" CI/CD")]),t._v(" "),a("p",[t._v("持续集成（Continuous integration，简称CI）,")]),t._v(" "),a("p",[t._v("持续集成指的是，频繁地（一天多次）将代码集成到主干。 它的好处主要有两个:")]),t._v(" "),a("p",[t._v("1.快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。")]),t._v(" "),a("p",[t._v("2.防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。")]),t._v(" "),a("p",[t._v("持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。")]),t._v(" "),a("p",[t._v("持续交付（Continuous delivery)，")]),t._v(" "),a("p",[t._v("持续交付指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。")]),t._v(" "),a("p",[t._v("持续部署（continuous deployment）")]),t._v(" "),a("p",[t._v("持续部署是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。")]),t._v(" "),a("p",[t._v("持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。")]),t._v(" "),a("p",[t._v("根据持续集成的设计，代码从提交到生产，整个过程有以下几步。")]),t._v(" "),a("p",[t._v("（1）提交。流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交")]),t._v(" "),a("p",[t._v("（2）测试（第一轮）。代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 测试有好几种。")]),t._v(" "),a("ul",[a("li",[t._v("单元测试：针对函数或模块的测试")]),t._v(" "),a("li",[t._v("集成测试：针对整体产品的某个功能的测试，又称功能测试")]),t._v(" "),a("li",[t._v("端对端测试：从用户界面直达数据库的全链路测试")])]),t._v(" "),a("p",[t._v("（3） 构建。通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 常用的构建工具如下。")]),t._v(" "),a("p",[t._v("（4） 测试（第二轮）。构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。")]),t._v(" "),a("p",[t._v("第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。")]),t._v(" "),a("p",[t._v("需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。")]),t._v(" "),a("p",[t._v("（5）部署。通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。")]),t._v(" "),a("p",[t._v("（6）回滚。一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。")]),t._v(" "),a("h2",{attrs:{id:"软件版本控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软件版本控制"}},[t._v("#")]),t._v(" 软件版本控制")]),t._v(" "),a("p",[t._v("软件开发周期版本控制及称号策略")]),t._v(" "),a("p",[t._v("alpha：内测版，bug多，不稳定，内部版本，不断添加功能")]),t._v(" "),a("p",[t._v("alpha是希腊字母的第一个，表示最早的版本，内部测试版，一般不对外发布，bug多且功能不全，一般只有测试人员使用")]),t._v(" "),a("p",[t._v("Beta1、beta2:公测版，不稳定(比alpha稳定一些)，bug相对还多，且不断添加新功能")]),t._v(" "),a("p",[t._v("beta是希腊字母的第二个，公开测试版，比alpha版本晚一些，主要对部分粉丝用户进行测试使用")]),t._v(" "),a("p",[t._v("RC：候选版，经过多个beta版本逐渐稳定，基本不添加新功能，修复完bug即可进入正式发布版")]),t._v(" "),a("p",[t._v("RC是Release Candidate，候选版本。")]),t._v(" "),a("p",[t._v("GA、RELEASE、Stable、Final：正式版，bug很少，推荐生产使用")]),t._v(" "),a("p",[t._v("GA：General Availability")]),t._v(" "),a("p",[t._v("RELEASE：发行版，sping使用")]),t._v(" "),a("p",[t._v("Stabel：稳定版，Nginx使用")]),t._v(" "),a("p",[t._v("Final：最终版本")]),t._v(" "),a("p",[t._v("其他版本称谓：")]),t._v(" "),a("p",[t._v("Free：自由版")]),t._v(" "),a("p",[t._v("Enhance：增强版")]),t._v(" "),a("p",[t._v("Upgrade：升级版")]),t._v(" "),a("p",[t._v("Plus：增加版")]),t._v(" "),a("p",[t._v("Premium：贵价版")]),t._v(" "),a("p",[t._v("Pro/Professional：专业版")]),t._v(" "),a("p",[t._v("Mini/Lite：精简版，只有最基本的功能")]),t._v(" "),a("p",[t._v("Corporation/Enterprise：企业版")]),t._v(" "),a("h2",{attrs:{id:"灰度发布-蓝绿部署-滚动发布"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#灰度发布-蓝绿部署-滚动发布"}},[t._v("#")]),t._v(" 灰度发布/蓝绿部署/滚动发布")]),t._v(" "),a("p",[t._v("在一般情况下，升级服务器端应用，需要将应用源码或程序包上传到服务器，然后停止掉老版本服务，再启动新版本。但是这种简单的发布方式存在两个问题，一方面，在新版本升级过程中，服务是暂时中断的，另一方面，如果新版本有 BUG，升级失败，回滚起来也非常麻烦，容易造成更长时间的服务不可用。")]),t._v(" "),a("p",[a("strong",[t._v("蓝绿部署")])]),t._v(" "),a("p",[t._v("所谓蓝绿部署，是指同时运行两个版本的应用，蓝绿部署的时候，并不停止掉老版本，而是直接部署一套新版本，等新版本运行起来后，再将流量切换到新版本上。但是蓝绿部署要求在升级过程中，同时运行两套程序，对硬件的要求就是日常所需的二倍，比如日常运行时，需要 10 台服务器支撑业务，那么使用蓝绿部署，你就需要购置二十台服务器。")]),t._v(" "),a("p",[a("strong",[t._v("滚动发布")])]),t._v(" "),a("p",[t._v("所谓滚动升级，就是在升级过程中，并不一下子启动所有新版本，是先启动一台新版本，再停止一台老版本，然后再启动一台新版本，再停止一台老版本，直到升级完成，这样的话，如果日常需要 10 台服务器，那么升级过程中也就只需要 11 台就行了。")]),t._v(" "),a("p",[t._v("但是滚动升级有一个问题，在开始滚动升级后，流量会直接流向已经启动起来的新版本，但是这个时候，新版本是不一定可用的，比如需要进一步的测试才能确认。那么在滚动升级期间，整个系统就处于非常不稳定的状态，如果发现了问题，也比较难以确定是新版本还是老版本造成的问题。")]),t._v(" "),a("p",[t._v("为了解决这个问题，我们需要为滚动升级实现流量控制能力。")]),t._v(" "),a("p",[a("strong",[t._v("灰度发布")])]),t._v(" "),a("p",[t._v("灰度发布（又名金丝雀发布，起源是，矿井工人发现，金丝雀对瓦斯气体很敏感，矿工会在下井之前，先放一只金丝雀到井中，如果金丝雀不叫了，就代表瓦斯浓度高）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。")]),t._v(" "),a("p",[t._v("灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。")]),t._v(" "),a("p",[t._v("在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的 A/B 测试。")]),t._v(" "),a("p",[t._v("当确认新版本运行良好后，再逐步将更多的流量导入到新版本上，在此期间，还可以不断地调整新旧两个版本的运行的服务器副本数量，以使得新版本能够承受越来越大的流量压力。直到将 100% 的流量都切换到新版本上，最后关闭剩下的老版本服务，完成灰度发布。")]),t._v(" "),a("p",[t._v("如果在灰度发布过程中（灰度期）发现了新版本有问题，就应该立即将流量切回老版本上，这样，就会将负面影响控制在最小范围内")]),t._v(" "),a("p",[t._v("总结")]),t._v(" "),a("p",[t._v("在新版本应用发布时，为了服务器不停机升级，使用灰度发布策略，在灰度发布开始时，使用 HTTP Header 匹配指定测试人员的流量到新版本上，然后当新版本内部测试通过后，可以再按百分比，将用户流量一点一点导入到新版本中，比如先导入 10% 观察一下运行情况，然后再导入 20%，如此累加，直到将流量全部导入到新版本上，最后完成升级，如果期间发现问题，就立即取消升级，将流量切回到老版本。")]),t._v(" "),a("p",[t._v("运用灰度发布，就再也不需要加班到深夜进行停机升级了，在白天就可以放心大胆地、安全地发布新版本")]),t._v(" "),a("h2",{attrs:{id:"单元测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[t._v("#")]),t._v(" 单元测试")]),t._v(" "),a("p",[t._v("测试是保证代码质量的重要环节，web项目的单元测试虽然不能完全完成功能测试，但是却能保证底层单一模块的工作质量，并且在代码重构的时候保证对外接口不会发生变化。")]),t._v(" "),a("p",[t._v("经常会提到的敏捷开发，单元测试就是其中必不可少的一步。因此单元测试的需要，尤其是自动化单元测试不可忽略，而且应当作为整个团队的关键责任-而不仅仅是软件开发人员的责任。")]),t._v(" "),a("ul",[a("li",[t._v("单元：相对独立功能模块，类、模块、方法。")]),t._v(" "),a("li",[t._v("又称为模块测试，是针对程序模块(软件设计的最小单位)来进行正确性检验的测试工作。")]),t._v(" "),a("li",[t._v("用来检验程式的内部逻辑，也称为个体测试、结构测试或逻辑驱动测试。")])]),t._v(" "),a("p",[t._v("单元测试的重要性")]),t._v(" "),a("p",[t._v("由于存在浏览器解析环境、用户操作习惯等差异，前端程序的许多问题是无法捕捉或重现的，现在前端程序的测试多是黑盒测试，即靠点击点击点击来寻找程序bug。这种方式既费时费力，又无法保证测试的覆盖面。同时，前端逻辑和交互越来越复杂，和其他编程语言一样，一个函数，一个模块，在修改bug或添加新功能的过程中，很容易就产生新的bug，或使老的bug复活。这种情况下，反复进行黑盒测试，其工作量和测试质量是可想而知的。")]),t._v(" "),a("ul",[a("li",[t._v("反正都要手动测试，所以不如代码自动化。")]),t._v(" "),a("li",[t._v("为了实现依赖接口编程，大型软件项目多人合作时必须要有的")]),t._v(" "),a("li",[t._v("首先，得让你的代码能够测试")]),t._v(" "),a("li",[t._v("增强代码自信")])]),t._v(" "),a("p",[t._v("黑盒测试")]),t._v(" "),a("ul",[a("li",[t._v("bug无法捕捉、重现")]),t._v(" "),a("li",[t._v("费力，工作量大")]),t._v(" "),a("li",[t._v("覆盖面低")]),t._v(" "),a("li",[t._v("反复出现bug")])]),t._v(" "),a("p",[t._v("单元测试")]),t._v(" "),a("ul",[a("li",[t._v("并不是所有的 js 都需要单元测试。中大型项目")]),t._v(" "),a("li",[t._v("并不是所有的 js 都能够单元测试。良好的模块化和解耦")])]),t._v(" "),a("h3",{attrs:{id:"tdd与bdd、相关概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tdd与bdd、相关概念"}},[t._v("#")]),t._v(" TDD与BDD、相关概念")]),t._v(" "),a("p",[t._v("TDD：测试驱动开发（Test-Driven Development）测试驱动开发是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD的基本思路就是通过测试来推动整个开发的进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。TDD首先考虑使用需求（对象、功能、过程、接口等），主要是编写测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。")]),t._v(" "),a("p",[t._v("BDD：行为驱动开发（Behavior Driven Development）行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。主要是从用户的需求出发，强调系统行为。BDD最初是由Dan North在2003年命名，它包括验收测试和客户测试驱动等的极限编程的实践，作为对测试驱动开发的回应。")]),t._v(" "),a("p",[t._v("测试套件”（test suite）：describe (moduleName, testDetails)。可以嵌套使用，明白、易懂即可。describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。")]),t._v(" "),a("p",[t._v("测试用例”（test case）：it (info, function)。具体的测试语句，可多个。it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。")]),t._v(" "),a("ul",[a("li",[t._v("info，写期望的正确输出的简要一句话文字说明。info：当该it 的block内的test failed的时候控制台就会把详细信息打印出来。")]),t._v(" "),a("li",[t._v("测试用例之中，只要有一个断言为false，这个测试用例就会失败，只有所有断言都为true，测试用例才会通过。")]),t._v(" "),a("li",[t._v("function，具体测试函数，一个测试用例内部，包含一个或多个断言（assert）。")])]),t._v(" "),a("p",[t._v("断言指的是对代码行为的预期，会返回一个布尔值，表示代码行为是否符合预期。")]),t._v(" "),a("ul",[a("li",[t._v("所有的测试用例（it块）都应该含有一句或多句的断言。")]),t._v(" "),a("li",[t._v("断言是编写测试用例的关键")]),t._v(" "),a("li",[t._v("断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。")]),t._v(" "),a("li",[t._v("断言库有很多种，Mocha并不限制使用哪一种。")])]),t._v(" "),a("p",[t._v("单元测试生命周期")]),t._v(" "),a("p",[t._v("每个测试块（describe）有4个周期函数：before、beforeEach、afterEach、after")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("周期函数")]),t._v(" "),a("th",[t._v("存在周期")]),t._v(" "),a("th",[t._v("主要功能")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("before()")]),t._v(" "),a("td",[t._v("在本区块的所有测试用例之前执行")]),t._v(" "),a("td",[t._v("用于同一的桩数据导入等功能")])]),t._v(" "),a("tr",[a("td",[t._v("beforeEach()")]),t._v(" "),a("td",[t._v("在本区块的每个测试用例之前执行")]),t._v(" "),a("td",[t._v("用于清理测试环境，删除或回滚相关数据")])]),t._v(" "),a("tr",[a("td",[t._v("afterEach()")]),t._v(" "),a("td",[t._v("在本区块的每个测试用例之后执行")]),t._v(" "),a("td",[t._v("可以用于准备测试用例所需的前置条件")])]),t._v(" "),a("tr",[a("td",[t._v("after()")]),t._v(" "),a("td",[t._v("在本区块的所有测试用例之后执行")]),t._v(" "),a("td",[t._v("可以用于准备测试用例所需的后置条件")])])])]),t._v(" "),a("p",[t._v("测试用例结构：")]),t._v(" "),a("p",[t._v("a. "),a("strong",[t._v("Setup")]),t._v(": 准备好环境和数据，跑这个测试用例之前的准备")]),t._v(" "),a("p",[t._v("b. "),a("strong",[t._v("Execution")]),t._v("：执行测试（测试用例的实现的主要代码）")]),t._v(" "),a("p",[t._v("c. "),a("strong",[t._v("Validation")]),t._v("：验证结果")]),t._v(" "),a("p",[t._v("d. "),a("strong",[t._v("Cleanup")]),t._v("：现场恢复，一般与a相反。不影响跑后面的测试用例。")]),t._v(" "),a("p",[t._v("TDD相关接口：")]),t._v(" "),a("p",[a("strong",[t._v("suite")]),t._v("：定义一组测试用例。")]),t._v(" "),a("p",[a("strong",[t._v("suiteSetup")]),t._v("：此方法会在这个suite所有测试用例执行前执行一次，只一次，这是跟setup的区别。")]),t._v(" "),a("p",[a("strong",[t._v("setup")]),t._v("：此方法会在每个测试用例执行前都执行一遍。")]),t._v(" "),a("p",[a("strong",[t._v("test")]),t._v("：具体执行的测试用例实现代码。")]),t._v(" "),a("p",[a("strong",[t._v("teardown")]),t._v("：此方法会在每个测试用例执行后都执行一遍，与setup相反。")]),t._v(" "),a("p",[a("strong",[t._v("suiteTeardown")]),t._v("：此方法会在这个suite所有测试用例执行后执行一次，与suiteSetup相反。")]),t._v(" "),a("h3",{attrs:{id:"前端单元测试框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端单元测试框架"}},[t._v("#")]),t._v(" 前端单元测试框架")]),t._v(" "),a("p",[t._v("前端测试框架有")]),t._v(" "),a("ul",[a("li",[t._v("Mocha")]),t._v(" "),a("li",[t._v("Jasmine")]),t._v(" "),a("li",[t._v("Jest")]),t._v(" "),a("li",[t._v("Tape")]),t._v(" "),a("li",[t._v("Karma")])]),t._v(" "),a("p",[t._v("Mocha")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" mocha --save-dev\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" add "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./add"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" assert "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"assert"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// describe：定义一组测试")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("describe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"加法函数测试"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("before")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// runs before all tests in this block")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it: 定义一个测试用例")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("it")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1 加 1 应该等于 2"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// assert: nodejs内置断言模块")]),t._v("\n        assert"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("after")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// runs after all test in this block")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br")])]),a("p",[t._v("断言库")]),t._v(" "),a("p",[t._v("Mocha 支持"),a("code",[t._v("should.js")]),t._v(", "),a("code",[t._v("chai")]),t._v(", "),a("code",[t._v("expect.js")]),t._v(", "),a("code",[t._v("better-assert")]),t._v(", "),a("code",[t._v("unexpected")]),t._v("等断言库")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//assert")]),t._v("\nassert"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ok")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nassert"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//shouldjs")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("should"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("be"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("should"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//expectjs")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("to"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("be"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"number"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("to"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//chai支持should, expect, assert三种语法")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[a("code",[t._v("should.js")]),t._v("和"),a("code",[t._v("expect.js")]),t._v("相较于"),a("code",[t._v("assert")]),t._v("语义性更强，且支持类型检测，而"),a("code",[t._v("should.js")]),t._v("在语法上更加简明，同时支持链式语法"),a("code",[t._v(".and")]),t._v("。")]),t._v(" "),a("ul",[a("li",[t._v("chai.js断言库：接口丰富，文档齐全，可以对各种接口进行断言。")]),t._v(" "),a("li",[t._v("expect 库应用是非常广泛，拥有很好的链式结构和仿自然语言的方法。")]),t._v(" "),a("li",[t._v("通常写同一个断言会有几个方法，比如：expect(response).to.be(true) 和 expect(response).equal(true)。")])]),t._v(" "),a("p",[t._v("expect和should是BDD风格的，二者使用相同的链式语言来组织断言，但不同在于他们初始化断言的方式：expect使用构造函数来创建断言对象实例，而should通过为Object.prototype新增方法来实现断言（所以should不支持IE）；expect直接指向chai.expect，而should则是chai.should()。")]),t._v(" "),a("p",[t._v("expect断言风格")]),t._v(" "),a("ul",[a("li",[t._v("ok ：检查是否为真")]),t._v(" "),a("li",[t._v("true：检查对象是否为真")]),t._v(" "),a("li",[t._v("to.be、to：作为连接两个方法的链式方法")]),t._v(" "),a("li",[t._v("not：链接一个否定的断言，如 expect(false).not.to.be(true)")]),t._v(" "),a("li",[t._v("a/an：检查类型（也适用于数组类型）")]),t._v(" "),a("li",[t._v("include/contain：检查数组或字符串是否包含某个元素")]),t._v(" "),a("li",[t._v("below/above：检查是否大于或者小于某个限定值")])]),t._v(" "),a("p",[t._v("assert风格是三种断言风格中唯一不支持链式调用的，Chai提供的assert风格的断言和node.js包含的assert模块非常相似。")]),t._v(" "),a("p",[t._v("Mocha 支持4种 hook，包括"),a("code",[t._v("before / after / beforeEach / afterEach")]),t._v("。")]),t._v(" "),a("p",[t._v("Mocha 默认每个测试用例执行2000ms，超出时长则报错，所以在测试代码中如果有异步操作，则需要通过"),a("code",[t._v("done")]),t._v("函数来明确测试用例结束。"),a("code",[t._v("done")]),t._v("接受"),a("code",[t._v("Error")]),t._v("参数。")]),t._v(" "),a("p",[t._v("Mocha 在node环境下运行时，不支持 BOM 和 DOM 接口，需要引入"),a("code",[t._v("jsdom")]),t._v("和"),a("code",[t._v("jsdom-global")]),t._v("库。")]),t._v(" "),a("p",[t._v("Mocha命令行基本用法：")]),t._v(" "),a("ul",[a("li",[t._v("mocha：默认运行test子目录里面的测试脚本，不包括子文件")]),t._v(" "),a("li",[t._v("mocha add.test.js：当前目录下面的该测试脚本。")]),t._v(" "),a("li",[t._v("mocha file1 file2 file3 ： mocha命令后面紧跟测试脚本的路径和文件名，可以指定多个测试用例。")])]),t._v(" "),a("p",[t._v("通配符：")]),t._v(" "),a("ul",[a("li",[t._v("mocha spec/{my,awesome}.js")]),t._v(" "),a("li",[t._v("mocha test/unit/*.js")])]),t._v(" "),a("p",[t._v("生成格式")]),t._v(" "),a("ul",[a("li",[t._v("mocha –reporter spec：默认为spec格式，可设置其他格式。")]),t._v(" "),a("li",[t._v("mocha –recursive -R markdown > spec.md 。")])]),t._v(" "),a("p",[t._v("网页查看")]),t._v(" "),a("p",[t._v("npm install –save-dev mochawesome")]),t._v(" "),a("p",[t._v("在gulp中运行mocha")]),t._v(" "),a("p",[t._v("安装gulp-mocha插件")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" gulp-mocha --save-dev\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("gulpfile")]),t._v(" "),a("div",{staticClass:"language-gulpfile line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("gulp.task('mocha',function() {\n\treturn \n})\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("Jasmine")]),t._v(" "),a("p",[t._v("Jasmine 是一个功能全面的测试框架，内置断言"),a("code",[t._v("expect")]),t._v("；但是有全局声明，且需要配置，相对来说使用更复杂、不够灵活。")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" jasmine --save-dev\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("Jasmine 的语法与 Mocha 非常相似，不过断言采用内置的"),a("code",[t._v("expect()")]),t._v("。")]),t._v(" "),a("p",[t._v("Jest")]),t._v(" "),a("p",[t._v("Jest 是一个功能全面的“零配置”测试框架，既集成了各种工具，且无需配置即可使用。")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" --save-dev jest\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("Jest 中以"),a("code",[t._v("test")]),t._v("定义一个测试用例，且自带断言"),a("code",[t._v("expect")]),t._v("，断言库功能强大，但语法相较于"),a("code",[t._v("should.js")]),t._v("来说更复杂。")]),t._v(" "),a("p",[t._v("普通匹配："),a("code",[t._v("toBe")]),t._v(", "),a("code",[t._v("not.toBe")])]),t._v(" "),a("p",[t._v("空匹配："),a("code",[t._v("toBeNull")]),t._v(", "),a("code",[t._v("toBeUndefined")]),t._v(", "),a("code",[t._v("toBeDefine")]),t._v(", "),a("code",[t._v("toBeTruthy")]),t._v(", "),a("code",[t._v("toBeFalsy")])]),t._v(" "),a("p",[t._v("数字大小："),a("code",[t._v("toBeGreaterThan")]),t._v(", "),a("code",[t._v("toBeGreaterThanOrEqual")]),t._v(", "),a("code",[t._v("toBeLessThan")]),t._v(", "),a("code",[t._v("toEqual")]),t._v(", "),a("code",[t._v("toBeCloseTo")]),t._v("(用于浮点数)")]),t._v(" "),a("p",[t._v("正则匹配："),a("code",[t._v("toMatch")])]),t._v(" "),a("p",[t._v("数组查询："),a("code",[t._v("toContain")])]),t._v(" "),a("p",[t._v("构造匹配："),a("code",[t._v("toEqual(expect.any(constructor))")])]),t._v(" "),a("p",[t._v("Jest 同样有四个hook，"),a("code",[t._v("beforeAll/beforeEach/afterAll/afterEach")])]),t._v(" "),a("p",[t._v("Jest 内置对 DOM 和 BOM 接口的支持。")]),t._v(" "),a("p",[t._v("Jest 内置覆盖统计，为了更方便地进行相关配置，我们可以创建一个配置文件"),a("code",[t._v("jest.config.js")])]),t._v(" "),a("p",[t._v("然后将"),a("code",[t._v("package.json")]),t._v("中的命名修改一下："),a("code",[t._v('"test-jest": "jest"')])]),t._v(" "),a("h3",{attrs:{id:"其他语言测试框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他语言测试框架"}},[t._v("#")]),t._v(" 其他语言测试框架")]),t._v(" "),a("h3",{attrs:{id:"单元测试与集成测试、功能测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单元测试与集成测试、功能测试"}},[t._v("#")]),t._v(" 单元测试与集成测试、功能测试")]),t._v(" "),a("h4",{attrs:{id:"三种测试的主要作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三种测试的主要作用"}},[t._v("#")]),t._v(" 三种测试的主要作用")]),t._v(" "),a("ul",[a("li",[t._v("单元测试，单个组件正常工作，开发阶段；用来确保每个组件正常工作 —— 测试组件的 API 。")]),t._v(" "),a("li",[t._v("集成测试，不同组件互相合作，中间阶段；用来确保不同组件互相合作 —— 测试组件的 API, UI, 或者边缘情况（比如数据库I/O，登录等等）。")]),t._v(" "),a("li",[t._v("功能测试，主要测试界面，开发完成。 用来确保整个应用会按照用户期望的那样运行 —— 主要测试界面")])]),t._v(" "),a("h4",{attrs:{id:"三种测试在不同阶段的重要性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三种测试在不同阶段的重要性"}},[t._v("#")]),t._v(" 三种测试在不同阶段的重要性")]),t._v(" "),a("ul",[a("li",[t._v("开发阶段，主要是程序员反馈。这时单元测试很有用。")]),t._v(" "),a("li",[t._v("在中间阶段，主要是能够在发现问题时立刻停下来。这时各种测试都很有用。")]),t._v(" "),a("li",[t._v("在生产环境，主要是运行功能测试套件，确保部署的时候没有弄坏什么东西。")])]),t._v(" "),a("h2",{attrs:{id:"ddd驱动测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ddd驱动测试"}},[t._v("#")]),t._v(" DDD驱动测试")]),t._v(" "),a("h2",{attrs:{id:"e2e测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#e2e测试"}},[t._v("#")]),t._v(" e2e测试")]),t._v(" "),a("h2",{attrs:{id:"前端代码打包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端代码打包"}},[t._v("#")]),t._v(" 前端代码打包")]),t._v(" "),a("h2",{attrs:{id:"前端bundleless"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端bundleless"}},[t._v("#")]),t._v(" 前端bundleless")]),t._v(" "),a("p",[t._v("随着业务的发展，前端代码的复杂度越来越高，构建方面展露新的问题：")]),t._v(" "),a("p",[t._v("过去需要打包的原因：")]),t._v(" "),a("p",[t._v("1.http1.1各浏览器有并行连接限制")]),t._v(" "),a("p",[t._v("2.浏览器不支持模块系统(如commonjs不能在浏览器直接运行)")]),t._v(" "),a("p",[t._v("3.代码依赖关系与顺序管理")]),t._v(" "),a("p",[t._v("可以开始不打包的原因：")]),t._v(" "),a("p",[t._v("1.http2.0多路并用")]),t._v(" "),a("p",[t._v("2.各大浏览器逐一支持ESM")]),t._v(" "),a("p",[t._v("3.越来越多的npm包拥抱ESM(尽管还有很多包不是)")]),t._v(" "),a("p",[t._v("目前构建主要分为两种：")]),t._v(" "),a("p",[t._v("1是基于服务的构建方式。通常服务于实际生产。可以再细分成本地服务构建与远端服务构建。本地服务构建就是我们常规的操作，基本被webpack统治，是bundle方案的代表，snowpack、Vite、Web Dev Server是目前比较火的Bundleless方案，发展迅猛。远端服务构建则是依托云能力的玩法，把构建过程放在服务端完成。")]),t._v(" "),a("p",[t._v("2是基于浏览器的构建方式。通常面向Demo的快速搭建或预览方案。Codesandbox、StackBlitz、CodePen和Riddel是业内比较出色的方案。整体是在浏览器端实现代码的编译、打包、构建和运行。")]),t._v(" "),a("h2",{attrs:{id:"重构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重构"}},[t._v("#")]),t._v(" 重构")]),t._v(" "),a("p",[t._v("原则")]),t._v(" "),a("ol",[a("li",[t._v("事不过三，三则重构。即不能重复写同样的代码，在这种情况下要去重构。")]),t._v(" "),a("li",[t._v("如果一段代码让人很难看懂，那就该考虑重构了。")]),t._v(" "),a("li",[t._v("如果已经理解了代码，但是非常繁琐或者不够好，也可以重构。")]),t._v(" "),a("li",[t._v("过长的函数，需要重构。")]),t._v(" "),a("li",[t._v("一个函数最好对应一个功能，如果一个函数被塞入多个功能，那就要对它进行重构了。（4 和 5 不冲突）")]),t._v(" "),a("li",[t._v("重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组合而成。")])]),t._v(" "),a("p",[t._v("手段：")]),t._v(" "),a("ol",[a("li",[t._v("提取重复代码，封装成函数")]),t._v(" "),a("li",[t._v("拆分功能太多的函数")]),t._v(" "),a("li",[t._v("变量/函数改名")]),t._v(" "),a("li",[t._v("替换算法")]),t._v(" "),a("li",[t._v("以函数调用取代内联代码")]),t._v(" "),a("li",[t._v("移动语句")]),t._v(" "),a("li",[t._v("折分嵌套条件表达式")]),t._v(" "),a("li",[t._v("将查询函数和修改函数分离")])])])}),[],!1,null,null,null);s.default=e.exports}}]);