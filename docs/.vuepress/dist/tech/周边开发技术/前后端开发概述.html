<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前后端开发概述 | Kun&#39;s Wiki</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="meta的描述内容">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.528f3631.js" as="script"><link rel="preload" href="/assets/js/2.619c82a8.js" as="script"><link rel="preload" href="/assets/js/33.463bffa3.js" as="script"><link rel="prefetch" href="/assets/js/10.ac7a4de3.js"><link rel="prefetch" href="/assets/js/11.22193742.js"><link rel="prefetch" href="/assets/js/12.6b0d96a8.js"><link rel="prefetch" href="/assets/js/13.bb592c98.js"><link rel="prefetch" href="/assets/js/14.5aadcb22.js"><link rel="prefetch" href="/assets/js/15.78a91f28.js"><link rel="prefetch" href="/assets/js/16.0463299b.js"><link rel="prefetch" href="/assets/js/17.5ade6be6.js"><link rel="prefetch" href="/assets/js/18.ae21993d.js"><link rel="prefetch" href="/assets/js/19.381fa6fe.js"><link rel="prefetch" href="/assets/js/20.5ccce5c5.js"><link rel="prefetch" href="/assets/js/21.cbe0d8e0.js"><link rel="prefetch" href="/assets/js/22.dec488e3.js"><link rel="prefetch" href="/assets/js/23.bd6e325e.js"><link rel="prefetch" href="/assets/js/24.7f63c0c1.js"><link rel="prefetch" href="/assets/js/25.e9d2ca3d.js"><link rel="prefetch" href="/assets/js/26.2ca2fcb2.js"><link rel="prefetch" href="/assets/js/27.9bbd6fb4.js"><link rel="prefetch" href="/assets/js/28.d07f52f0.js"><link rel="prefetch" href="/assets/js/29.69fc0484.js"><link rel="prefetch" href="/assets/js/3.983c5940.js"><link rel="prefetch" href="/assets/js/30.95ebca2d.js"><link rel="prefetch" href="/assets/js/31.0119a78d.js"><link rel="prefetch" href="/assets/js/32.1be9fafc.js"><link rel="prefetch" href="/assets/js/34.e343d136.js"><link rel="prefetch" href="/assets/js/35.7484c5cf.js"><link rel="prefetch" href="/assets/js/36.5aff1e2a.js"><link rel="prefetch" href="/assets/js/37.d06aba3d.js"><link rel="prefetch" href="/assets/js/38.bf208dc8.js"><link rel="prefetch" href="/assets/js/39.30052380.js"><link rel="prefetch" href="/assets/js/4.2fb93bc2.js"><link rel="prefetch" href="/assets/js/40.08ee34f0.js"><link rel="prefetch" href="/assets/js/41.dcd825b5.js"><link rel="prefetch" href="/assets/js/42.487f0aa8.js"><link rel="prefetch" href="/assets/js/43.67a7ad8b.js"><link rel="prefetch" href="/assets/js/44.357ba709.js"><link rel="prefetch" href="/assets/js/45.a590454b.js"><link rel="prefetch" href="/assets/js/46.e7870e58.js"><link rel="prefetch" href="/assets/js/47.abdb75cf.js"><link rel="prefetch" href="/assets/js/48.0a5ab934.js"><link rel="prefetch" href="/assets/js/49.663acd27.js"><link rel="prefetch" href="/assets/js/5.1474cf9c.js"><link rel="prefetch" href="/assets/js/50.96ef16fe.js"><link rel="prefetch" href="/assets/js/51.e0b76e5e.js"><link rel="prefetch" href="/assets/js/52.a909ae03.js"><link rel="prefetch" href="/assets/js/53.b3e7bb38.js"><link rel="prefetch" href="/assets/js/54.d2a5e7cf.js"><link rel="prefetch" href="/assets/js/55.41bdb3fe.js"><link rel="prefetch" href="/assets/js/56.58b21e41.js"><link rel="prefetch" href="/assets/js/57.c3d18e9a.js"><link rel="prefetch" href="/assets/js/58.dc3e0326.js"><link rel="prefetch" href="/assets/js/59.e2e30a9a.js"><link rel="prefetch" href="/assets/js/6.2958d7f8.js"><link rel="prefetch" href="/assets/js/60.8f5cef73.js"><link rel="prefetch" href="/assets/js/61.cf6b261c.js"><link rel="prefetch" href="/assets/js/62.54bae72d.js"><link rel="prefetch" href="/assets/js/63.8ef19855.js"><link rel="prefetch" href="/assets/js/64.4b33c41d.js"><link rel="prefetch" href="/assets/js/65.24a33653.js"><link rel="prefetch" href="/assets/js/7.4f3f4813.js"><link rel="prefetch" href="/assets/js/8.af6b4dfd.js"><link rel="prefetch" href="/assets/js/9.0ac2d280.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Kun's Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="/tech/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/research/" class="nav-link">
  科研
</a></div><div class="nav-item"><a href="/shoot/" class="nav-link">
  摄影
</a></div><div class="nav-item"><a href="https://www.github.com/kun8018" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="/tech/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/research/" class="nav-link">
  科研
</a></div><div class="nav-item"><a href="/shoot/" class="nav-link">
  摄影
</a></div><div class="nav-item"><a href="https://www.github.com/kun8018" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Tech</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/" aria-current="page" class="sidebar-link">Blogging Like a Hacker</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>周边开发技术</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/周边开发技术/gatsbyjs.html" class="sidebar-link">Gatsbyjs</a></li><li><a href="/tech/周边开发技术/git.html" class="sidebar-link">Git使用技巧</a></li><li><a href="/tech/周边开发技术/hexo.html" class="sidebar-link">Hexo个人博客搭建及配置</a></li><li><a href="/tech/周边开发技术/前后端开发概述.html" class="active sidebar-link">前后端开发概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_2019、2020前端开发技术指南" class="sidebar-link">2019、2020前端开发技术指南</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_2021前端开发技术指南" class="sidebar-link">2021前端开发技术指南</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_1-html" class="sidebar-link">1. HTML</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_2-css" class="sidebar-link">2. CSS</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_3-javascript" class="sidebar-link">3. JavaScript</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_4-前端框架" class="sidebar-link">4. 前端框架</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_5-前端工程化" class="sidebar-link">5. 前端工程化</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_6-服务端渲染-ssr" class="sidebar-link">6. 服务端渲染 SSR</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_7-静态站点生成器-ssg" class="sidebar-link">7. 静态站点生成器 SSG</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_8-typescript" class="sidebar-link">8. TypeScript</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_9-用-js-去做服务器端" class="sidebar-link">9. 用 JS 去做服务器端</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_10-桌面应用程序-electron" class="sidebar-link">10. 桌面应用程序 Electron</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_11-移动端开发" class="sidebar-link">11. 移动端开发</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_12-前端架构-jamstack" class="sidebar-link">12. 前端架构 JAMStack</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#_13-webassembly" class="sidebar-link">13. WebAssembly</a></li></ul></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#前端两年应有技术栈" class="sidebar-link">前端两年应有技术栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#一、打好基础不用说" class="sidebar-link">一、打好基础不用说</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#二、框架方面" class="sidebar-link">二、框架方面</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#三、如何看源码" class="sidebar-link">三、如何看源码</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#四、前端工程化" class="sidebar-link">四、前端工程化</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#五、性能优化的方案" class="sidebar-link">五、性能优化的方案</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#利用缓存-空间换时间" class="sidebar-link">利用缓存（空间换时间）</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#其他" class="sidebar-link">其他</a></li></ul></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#六、学习移动端web开发" class="sidebar-link">六、学习移动端web开发</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#restful" class="sidebar-link">Restful</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#swagger" class="sidebar-link">Swagger</a></li></ul></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#oauth" class="sidebar-link">Oauth</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#graphql" class="sidebar-link">GraphQL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#与restful接口相比" class="sidebar-link">与Restful接口相比</a></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#graphql中的基本概念" class="sidebar-link">GraphQL中的基本概念</a></li></ul></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#websocket" class="sidebar-link">Websocket</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#websocket、长轮询、轮询、sse的区别" class="sidebar-link">websocket、长轮询、轮询、sse的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#前后端跨域9种方式" class="sidebar-link">前后端跨域9种方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#各种跨域方式对比" class="sidebar-link">各种跨域方式对比</a></li></ul></li><li class="sidebar-sub-header"><a href="/tech/周边开发技术/前后端开发概述.html#跨域验证" class="sidebar-link">跨域验证</a></li></ul></li><li><a href="/tech/周边开发技术/前后端开发概述(三).html" class="sidebar-link">前后端开发概述</a></li><li><a href="/tech/周边开发技术/前后端开发概述(二).html" class="sidebar-link">前后端开发概述</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>数据库相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>服务器技术</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>桌面端开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>移动端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>静态语言</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>业余研究</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>关于</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>科学研究</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p>​      把一些前后端概念性比较强的理念放在这里，不放代码，不提供案例，仅供理解核心概念参考。</p> <h2 id="_2019、2020前端开发技术指南"><a href="#_2019、2020前端开发技术指南" class="header-anchor">#</a> 2019、2020前端开发技术指南</h2> <p>本指南通过简单分类列出了技术选项，为前端开发者提供技术方向参考</p> <p>如果你是一个基础的前端开发者，你应该具备以下技能或者推荐你具备以下技能：</p> <p>​        1.HTML&amp;CSS。语义化的html元素、基础的css语法、flexbox&amp;grid、CSS变量、浏览器开发者工具。</p> <p>​        2.响应式布局。响应式设计将不再是网页的加分项, 而是必须的。设置viewport、非固定宽度、媒体查询、移动端优先、柱状优先、使用rem替代px（或者等效计算，不能是纯px）。</p> <p>​        3.基础的部署工作。注册一个域名、管理共享主机或者虚拟主机、FTP, SFTP 文件上传、静态页面托管</p> <p>​        4.SASS预处理器。虽然不是必须的, 但是推荐去学, 基础知识的掌握很简单。结构化CSS、变量、嵌套样式表、继承、Mixin&amp;函数。</p> <p>​        5.原生JavaScript语法。是基础中最重要的。包括但不限于js的基础变量类型、函数、条件判断、循环、计算符，DOM操作与事件、JSON、Fetch、ES6语法（箭头函数、promise、async/await、结构）。</p> <p>​        掌握或者基本掌握了以上技能，你可以做到：构建静态网站、构建UI布局、添加交互功能、部署和维护网站。然而这些作为前端开发的工具是远远不够的。</p> <p>如果你是一个成熟的前端开发者，你应该具备以下技能或者推荐你具备以下技能：</p> <p>​        1.HTML &amp; CSS框架。推荐bootstrap或者bulma。</p> <p>​        2.Git和其他工作流工具。基础的命令行、Git版本控制、npm(yarn)包管理、webpack或者gulp打包工具、编辑器插件(ESLint, Prettier, Live Server等)。</p> <p>​        3.前端框架。三大框架angular、vue、react至少熟悉或者掌握一个。这三大框架在大公司开发中非常流行，具有更有趣的交互和设计、可以实现前端代码组件化、对团队非常有利。</p> <p>​        4.状态管理。对于使用框架的大型前端项目, 你也许需要使用状态管理工具去管理你的应用级的状态。推荐框架有redux、vuex、apollo。</p> <p>​          掌握或者基本掌握了以上技能，你可以做到：构建一个优秀的前端应用、流畅和稳定的前端工作流、多人开发&amp;熟练使用Git、请求后端APi</p> <p>如果你是一个进阶的前端开发者，你应该具备以下技能或者推荐你具备以下技能：</p> <p>​         1.学习一门后端语言。成为一个全栈工程师或软件工程师, 你将需要学习一个服务端语言和相关技术。Nodejs、PHP、Python、C#、golang。学习的顺序为基础的后端语法、数据结构和工作流、包管理、http路由。</p> <p>​         2.服务端框架。不要重复造轮子, 学习一门框架去构建更好和更快的应用。Nodejs有express、koa、nest，python有django和flask，php有larvael和symphony，c#有asp.net。</p> <p>​         3.数据库。绝大多数觉得应用都会使用到数据库, 这里有一些选择:关系型（mysql、PostgreSQL）、非关系型（mongoDB）、轻量级（Redis、SQlite）、云数据库（Azure、AWS、Firebase）。</p> <p>​         4.服务端渲染。像React, Vue 和 Angular等框架都可以进行服务端渲染。</p> <p>​         5.内容管理系统。内容管理系统允许快速开发并为您的客户提供更新内容的能力. 在你需要快速开发网站的时候, 它们是很适合的. 特别是对于自由开发者.比较好用的CMS管理系统：基于PHP的(wordpress、drupal)、基于JS的(Ghost、keystone)、基于python的(Mezzazine)。</p> <p>​         6.安装和部署。学习语言和框架是一回事, 但是安装环境, 测试和部署又是另外一回事。部署(Linux, SSH, Git, Nginx, Apache)、平台(Digital Ocean, AWS, Heroku, Azure)、可视化(Docker, Vagrant)、测试(单元测试, 集成测试, 函数式测试, 系统测试)。</p> <p>​         掌握或者基本掌握了以上技能，你可以做到：设置全栈的开发环境和工作流、构建后端服务API和微服务、数据库操作、能够独立开发应用(前后端)、部署到云端。</p> <p>如果你是一个展望未来的前端开发者，下面这些技术也许是你应该关心或者下一步发展的技能：</p> <p>​         1.原生应用开发。ReactNative、Flutter、Ionic、NativeScirpt。</p> <p>​         2.使用Electron开发桌面应用.Electron是一个使用JavaScript构建跨平台的桌面应用工具。</p> <p>​         3.GraphQL &amp; Apollo.GraphQl是对于API的一种革命性新方法，查询语言比标准RESET严格得多。</p> <p>​         4.TypeScript.TypeScript是一个JavaScript的超集, 它添加了静态类型等很多特性。</p> <p>​         5.无服务架构.无需创建和管理自己的服务器</p> <p>​         6.PWA.Progressive Web Apps是一个web app但是在功能和样式上给用户带来原生应用使用体验的一项技术.</p> <p>​         7.AI和机器学习.AI和机器学习已经被广泛应用在所有的程序和技术中, 甚至包括web开发中.</p> <p>​         8.区块链技术.现在许多公司使用区块链技术进行数字交易, 因为它们更安全和有效率.</p> <p>​         9.Web Assembly</p> <p>https://segmentfault.com/a/1190000017483325</p> <h2 id="_2021前端开发技术指南"><a href="#_2021前端开发技术指南" class="header-anchor">#</a> 2021前端开发技术指南</h2> <h3 id="_1-html"><a href="#_1-html" class="header-anchor">#</a> 1. HTML</h3> <ul><li>DOCTYPE</li> <li>HTML, XHTML, XML 差异性</li> <li>HTML5 新特性 及 语义化标签</li> <li>meta, img, script 等标签及其标签属性</li> <li>有兴趣可以了解 W3C 和 WHATWG HTML5 差异</li></ul> <h3 id="_2-css"><a href="#_2-css" class="header-anchor">#</a> 2. CSS</h3> <ul><li>CSS 基础</li> <li>CSS 布局</li> <li>CSS 动画</li> <li>CSS 预处理器（sass, less, stylus）</li></ul> <h3 id="_3-javascript"><a href="#_3-javascript" class="header-anchor">#</a> 3. JavaScript</h3> <ul><li>JavaScript 基础</li> <li>ES6</li> <li>面向对象编程 和 函数式编程</li></ul> <h3 id="_4-前端框架"><a href="#_4-前端框架" class="header-anchor">#</a> 4. 前端框架</h3> <ul><li>Vue
<ul><li>路由（Vue-Router）</li> <li>状态管理（Vuex）</li></ul></li> <li>React
<ul><li>JSX</li> <li>Class Component, Hooks</li> <li>路由（React-Router, React-Router-Dom）</li> <li>状态管理（Redux, Mobx, Context API）</li></ul></li> <li>Angular
<ul><li>状态管理（Service, NgRx, RxJS）</li></ul></li> <li>Svelte
<ul><li>路由（svelte-spa-router）</li> <li>状态管理（Context API）</li></ul></li></ul> <h3 id="_5-前端工程化"><a href="#_5-前端工程化" class="header-anchor">#</a> 5. 前端工程化</h3> <ul><li>包管理工具（npm, yarn）</li> <li>JavaScript 编译器（babel）</li> <li>代码检测工具（ESlint）</li> <li>自动化打包工具（webpack, rollup, parcel, gulp）</li></ul> <h3 id="_6-服务端渲染-ssr"><a href="#_6-服务端渲染-ssr" class="header-anchor">#</a> 6. 服务端渲染 SSR</h3> <ul><li>Nuxt（Vue）</li> <li>Next（React）</li> <li>Sapper（Svelte）</li></ul> <h3 id="_7-静态站点生成器-ssg"><a href="#_7-静态站点生成器-ssg" class="header-anchor">#</a> 7. 静态站点生成器 SSG</h3> <ul><li>Gridsome（Vue）</li> <li>Gatsby（React）</li></ul> <h3 id="_8-typescript"><a href="#_8-typescript" class="header-anchor">#</a> 8. TypeScript</h3> <ul><li>和 JavaScript 的差异</li> <li>基础类型</li> <li>OOP（模块，类，接口，继承，泛型等）</li></ul> <h3 id="_9-用-js-去做服务器端"><a href="#_9-用-js-去做服务器端" class="header-anchor">#</a> 9. 用 JS 去做服务器端</h3> <ul><li>Node.js
<ul><li>单线程、事件驱动、非阻塞I/O</li> <li>框架（Express, Koa，Nest）</li></ul></li> <li>Deno</li></ul> <h3 id="_10-桌面应用程序-electron"><a href="#_10-桌面应用程序-electron" class="header-anchor">#</a> 10. 桌面应用程序 Electron</h3> <p>Electron.js是可以通过HTML，CSS，JavaScript开发跨平台的桌面应用程序。</p> <ul><li>基础语法，API</li> <li>编译</li> <li>性能优化</li> <li>调试</li> <li>部署</li></ul> <h3 id="_11-移动端开发"><a href="#_11-移动端开发" class="header-anchor">#</a> 11. 移动端开发</h3> <ul><li>React Native</li> <li>Flutter</li> <li>Ionic</li></ul> <h3 id="_12-前端架构-jamstack"><a href="#_12-前端架构-jamstack" class="header-anchor">#</a> 12. 前端架构 JAMStack</h3> <p>JAMStack（JAM 代表 JavaScript，API 和 Markup）</p> <p>是一种使用 Static Site Generators (SSG) 技术、不依赖 Web Server 的前端架构。</p> <h3 id="_13-webassembly"><a href="#_13-webassembly" class="header-anchor">#</a> 13. WebAssembly</h3> <p>WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行底层字节码。</p> <p>https://segmentfault.com/a/1190000038774393?utm_source=sf-related</p> <h2 id="前端两年应有技术栈"><a href="#前端两年应有技术栈" class="header-anchor">#</a> 前端两年应有技术栈</h2> <h3 id="一、打好基础不用说"><a href="#一、打好基础不用说" class="header-anchor">#</a> 一、打好基础不用说</h3> <p>HTML、CSS、JavaScript 三大件，完全掌握。不懂得就直接查 MDN。HTML重点掌握语义化。区分块级和内联标签。其他查文档就好了。还有就是定义 head 里面一些meta 了解下。</p> <p>CSS。重点看盒子模型，定位，层级，过渡，动画和 transform。知道原理和规则。大部分工作都是照着设计稿化。掌握上面几个99%还原也不难。接下来重点学习几种常见的布局。完了之后去搞flex。最后搞下sass、less。基本就差不多了。</p> <p>JavaScript。重点来了，红宝书看一遍掌握基础，进阶去看《你不知道的 JavaScript》。就这两套足够了，别搞那么多。每个知识点搞懂。ES6基本没啥问题。下面几个问题优搞懂，优先级如下：</p> <p>this 用法，相关原理
原型/原型链
闭包
面向对象相关
同步异步/回调/promise/async、await
模块化 CommonJS, AMD
先搞这懂这些比较难的概念，对你JS理解更加深入。接下来在开始看框架方面</p> <h3 id="二、框架方面"><a href="#二、框架方面" class="header-anchor">#</a> 二、框架方面</h3> <p>前期要会用，后期要懂原理。</p> <p>新人先搞 Vue。Vue 算是比较简单的框架了，上手容易。照着官方文档来问题不大。原理方面要提高自己认识。学习怎么看源码。github常去逛逛。</p> <p>学习框架之前，我其实特别建议，新人先去了解 Babel 和 webpack 不仅仅是使用。一些原理方面的东西工作中也会用到。babel 里面会有教你如何编译代码。webpack教你如和打包文件。自己手写编译器和打包工具也不是特别难。反正对之后看vue、react源码帮助挺大。</p> <p>搞完 Vue 全家桶，去了解下 React，React hooks 学习下新的理念。再回过头来看Vue。你会发现他们是如此的相似去又不同。</p> <p>多去实践总结，对整体框架理解会越来越深刻。</p> <h3 id="三、如何看源码"><a href="#三、如何看源码" class="header-anchor">#</a> 三、如何看源码</h3> <p>新人刚开始看源码，会陷入两个困境中。一是无从下手。二是看了之后感觉没啥收获。</p> <p>这个也很正常。一般我们熟知的框架都有个几千甚至上万个PR。太大细节会干扰你。掌握整个节奏和流程。学习原理也比较吃力。就连找个入口都像大海捞针一样。建议从下面几个方面入手：</p> <ul><li>挑简单的上手。别一开始就搞 vue、react、webpack。太难，会直接劝退新人。不要为了面试而去读。反而效果不好，面试稍微问深入一点就答不出来了。平时有兴趣多琢磨琢磨。按照难易程度，函数库 &lt; 组件库 &lt; 框架 &lt; 工程化 分别典型代表 lodash &lt; vant &lt; vue &lt; webpack</li> <li>手撸简易模型。像vue, webpack, babel 都有简易项目给你撸。有的创始人（尤哥）还直播手撸。国外的更多，youtube 一搜一大堆。就算不看源码，照着写出了简易 demo 对原理和理解提升都是很大的。</li> <li>调试开源项目。先把项目拉下来。在vscode里面跑下，核心函数多打几个断点。看看里面变量是怎么diff的。对理解更深刻了。</li></ul> <p>看了源码是别人的，学到了是自己的。学习时候边记笔记，边思考原理，总结经验。下面来谈谈前端工程化怎么弄。</p> <h3 id="四、前端工程化"><a href="#四、前端工程化" class="header-anchor">#</a> 四、前端工程化</h3> <p>现在最流行的打包工具 webpack 用起来。当然直接用 vue-cli2、vue-cli3、create-react 都是可以的。但是 webpack 相关还是得掌握。</p> <p>首先重点搞下babel、webpack。学习下编译，打包的原理。自己配置下 webpack。尝试自己去写下下 webpack 的 loader 和 plugin。学习这些之前要懂一点 node.js， node.js 不需要全部学习。一般就日常用到读写文件fs接口，path 路径接口。这些 api 都不难写几个 demo 就懂了。基本上webpack 里面配置文件也没用到多少 node 的东西。最后自己学会配置webpack的配置文件。</p> <p>如果想深想去优化打包体积和速度，就需要去了解很多webpack插件。webpack 里面最核心的就是插件了。</p> <p>当然前端工程化不仅仅是这些，CI/CD可持续集成, Umi 了解下。shell各种脚本自动化命令、代码生成技术了解下。</p> <h3 id="五、性能优化的方案"><a href="#五、性能优化的方案" class="header-anchor">#</a> 五、性能优化的方案</h3> <p>一般来说。性能优化没什么系统化的文档供人学习。完全靠一些经验和自己的实践。</p> <p>我们常提到性能好坏是由什么来衡量呢？</p> <p>访问页面地址 --&gt; 页面首次加载数据 --&gt; 渲染出完整页面的时长</p> <p>非首次情况下，命中缓存的加载缓存数据 --&gt; 渲染出完整页面的时长。</p> <p>一般我从下面几个方面着手去做，一般问题都不大。</p> <p>减小资源（静态资源，后端加载的数据）大小</p> <ul><li>压缩代码HTML/CSS/JS</li> <li>压缩图片、音视频大小</li> <li>Tree-Sharking 消除无用代码</li></ul> <p>以上webpack都可以搞定</p> <p>避免同一时间的过多次数请求</p> <ul><li>CSS 实现雪碧图：使用background-position共享一张图</li> <li>图片懒加载：监听滚动后offsetTop,  使用src 替换 src（真实路径）</li> <li>列表懒加载（分批加载）：监听滚动后offsetTop， 发送请求加载下一页的数据</li> <li>路由懒加载</li> <li>代码分包分块加载（webpack）</li> <li>预加载技术</li> <li>小程序分包、预下载等。</li></ul> <h3 id="利用缓存-空间换时间"><a href="#利用缓存-空间换时间" class="header-anchor">#</a> 利用缓存（空间换时间）</h3> <ul><li>CDN 内容分发：获取更近网络节点缓存下来的静态资源</li> <li>浏览器缓存（自带）</li> <li>部分资源保存在LocalStorage或者APP缓存中（手动操作）</li></ul> <h3 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h3> <ul><li>SSR 服务端渲染：解决SPA框架带来JS动态渲染页面带来的延迟和白屏问题。</li></ul> <p>这些都可以去实践的，难度不大。难度大的地方可能是 dom 节点成千上万的时候渲染的性能问题。这个场景遇到的很少，方案很多。不同人有不同解决方案，有功夫可以自己去尝试尝试。</p> <p>上面提到很多点都可以深入到很深。由于篇幅原因，点到即止。</p> <h2 id="六、学习移动端web开发"><a href="#六、学习移动端web开发" class="header-anchor">#</a> 六、学习移动端web开发</h2> <p>前端现在为什么这么火？各个公司都还挺缺优秀的前端。原因在于技术红利。</p> <p>移动端web流行起来之后，特别是H5和小程序，带动了多少前端就业，前端迅速取代了安卓和iOS 的大量岗位。</p> <p>回到正题：所以作为前端人，移动web一般是都要接触的。不同于PC 端。</p> <p>移动端有哪些东西呢？不需要全部懂，差不多知道就行了。要用的时候再去学。</p> <ul><li>绝对单位换相对单位：px =&gt; rem / vw / rpx</li> <li>弹性布局：使用flex、grid布局</li> <li>hairline （1px的粗线处理）：使用伪元素 + transform: scale(倍数) 缩放线框</li> <li>WebView 环境了解下</li> <li>安卓iOS 兼容踩坑：点击延迟、穿透、滚动不流畅、安全区域等等。</li> <li>小程序开发相关踩坑</li> <li>JSBridge: H5 与App 通信</li> <li>H5动画制作</li> <li>跨平台框架：react native、weex、flutter 等等</li></ul> <p>简单的说移动web 就是：html/css/js 跑在手机app 里面的WebView（web运行环境）。</p> <p>小程序/公众号就是在这个基础上，将自己APP里面的WebView 租售给其他人使用。</p> <p>微信APP ----- 提供SDK ----&gt; 微信webview ----- 提供运行环境-----&gt; 公众号h5 / 小程序</p> <p><strong>为什么微信可以容纳几乎无限的H5/小程序页面呢？</strong></p> <p>因为公众号/小程序的代码都存储在云端，通过不同的路由就可以给几乎无数的开发者使用。</p> <p>使得微信成为一个运行环境+入口的存在。</p> <p>https://mp.weixin.qq.com/s/dW9-6iTB8xoSUwRrS7IVNQ</p> <h2 id="restful"><a href="#restful" class="header-anchor">#</a> Restful</h2> <p>restful架构：</p> <p>每一个URI代表一种资源</p> <p>客户端与服务器之间传递这种资源的表现层</p> <p>客户端通过四个http动词对服务器端资源进行操作，实现表现层状态转化</p> <p>restful中一般包含以下数据：</p> <p>接口地址、请求方法、请求参数:即传输参数时要带什么参数、携带什么字段，规则是什么、返回内容：一般为json或者xml形式，错误代码</p> <h3 id="swagger"><a href="#swagger" class="header-anchor">#</a> Swagger</h3> <p>swagger是rest API生成工具，swagger是一个完整的框架，用于生成、描述、调用和可视化restfulapi的web服务</p> <h2 id="oauth"><a href="#oauth" class="header-anchor">#</a> Oauth</h2> <p></p> <h2 id="graphql"><a href="#graphql" class="header-anchor">#</a> GraphQL</h2> <p>GraphQL是一种用于API的查询语言。对API提供了一套易于理解的完整描述，使客户端能够准确获得需要的数据</p> <p>使用GraphQL后端将不再产出api，与前端约定一套schema，用来生成接口文档，前端通过schema进行自己期望的请求</p> <p>GraphQL并没有和特定的数据库或者存储引擎绑定，而是依靠现有的代码和数据支撑。一个GraphQL是通过定义类型和类型上的字段来创建的，然后给每个类型的字段提供解析函数</p> <p>目前很多语言也提供了对GraphQL的支持，比如javascript/nodejs，Java、php、Ruby、Python、Go、C#等</p> <h3 id="与restful接口相比"><a href="#与restful接口相比" class="header-anchor">#</a> 与Restful接口相比</h3> <p>当今很多页面需要向多个资源发送请求，有的页面甚至发3个以上的请求，而且请求之间可能存在依赖关系，后一个请求需要根据前一个请求的结果进行下一步</p> <p>传统restful：</p> <p>数据请求冗余：一个用户的信息可能包含id、昵称、年龄、性别、头像、等级等很多字段，但是有时我们只需要用户的一两个字段而不得不请求到所有的数据，其他的数据是无用的，或者需要获得一个用户列表时，需要调用多个接口，给后端造成麻烦</p> <p>restful接口改动麻烦：restful一旦要改变API，改变APIurl、增减数量、前后端都需改变</p> <p>GraphQL：</p> <p>减少数据和请求冗余：正如官网所说，请求的数据不多也不少，节省带宽，获取多个资源可以只用一个请求</p> <p>schema格式化：通过schema限制了req和rep的格式和类型，且自动生成文档，减少前后端沟通成本</p> <p>接口校验：</p> <p>接口变动，维护与文档：客户端只声明数据，不需要具体格式，API也无需划分版本，只要服务端包含请求方的数据，不需要更改接口</p> <p>劣势：学习成本，对后端的要求高，这也是graphql推广难的原因，后端需要重新构建</p> <p>简言之：</p> <p>restful一个接口返回一个资源，graphql一次获取多个资源</p> <p>restful用url定义资源，graphql用类型定义资源</p> <h3 id="graphql中的基本概念"><a href="#graphql中的基本概念" class="header-anchor">#</a> GraphQL中的基本概念</h3> <p>操作类型</p> <p>​			query：查询：获取数据，查</p> <p>​			mutation：修改，对数据进行变更，增删改</p> <p>​			substription:订阅：当数据发生更改时进行消息推送</p> <p>​			GraphQL在query查询语句时是并行执行的，在mutation变更时是线性执行的，一个接着一个</p> <p>数据类型</p> <p>​			GraphQL中定义了两种类型：对象类型和标量类型</p> <p>​			对象类型是用户在schema中定义的type</p> <p>​			GraphQL中定义了标量类型，String、Int、Float、Boolean、ID，此外，用户还可以自己定义自己的标量类型</p> <p>​			参数后通常跟！表示参数不能为空</p> <p>​			GraphQL服务器接收到query请求后，从Root Query开始查找，找到对象类型后到它的解析函数Resolver获取内容，如果返回的是标量内容则结束获取，直到获取最后一个标量类型</p> <p>模式schema</p> <p>​			在schema中定义了字段的类型，数据的结构，即接口数据请求的规则，</p> <p>​			schema使用强类型模式语法，称为模式描述语言</p> <p>解析函数Resolver</p> <p>​			前端请求到达后端后，由Resolver函数提供数据，</p> <p>​			解析函数接受四个参数</p> <p>​			parent:当前上一个解析函数的返回值</p> <p>​			args:查询函数中传入的参数</p> <p>​			context:提供给所有解析器的上下文信息</p> <p>​			info:一个保存与当前查询相关的字段特定信息</p> <p>请求格式：</p> <p>​             GraphQL是通过http来发送请求的</p> <p>异常处理</p> <p>​            查询错误：返回状态码200，返回data字段为null，如query语法错误时</p> <p>​			HTTP错误：返回码4** 或5**，如token失效等</p> <p>​			网络异常：fetch方法异常，如无网络</p> <p>​			JSON解析异常：response.json方法异常</p> <h2 id="websocket"><a href="#websocket" class="header-anchor">#</a> Websocket</h2> <p>Http协议是无状态的，只能由客户端主动发起，服务端再被动响应，服务端无法向客户端主动推送内容，并且一旦服务器响应结束，链接就会断开(见注解部分)，所以无法进行实时通信。WebSocket协议正是为解决客户端与服务端实时通信而产生的技术</p> <p>WebSocket协议本质上是一个基于tcp的协议，它是先通过HTTP协议发起一条特殊的http请求进行握手后，如果服务端支持WebSocket协议，则会进行协议升级。WebSocket会使用http协议握手后创建的tcp链接，和http协议不同的是，WebSocket的tcp链接是个长链接（不会断开），所以服务端与客户端就可以通过此TCP连接进行实时通信。</p> <p><a href="http://websocket.org/" target="_blank" rel="noopener noreferrer">WebSocket<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是html5规范中的一个部分，它借鉴了socket这种思想，为web应用程序客户端和服务端之间（注意是客户端服务端）提供了一种全双工通信机制。同时，它又是一种新的应用层协议，WebSocket协议是为了提供web应用程序和服务端全双工通信而专门制定的一种应用层协议，</p> <p>websocket的特点：</p> <ul><li>1）建立在 TCP 协议之上，服务器端的实现比较容易；</li> <li>2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器；</li> <li>3）数据格式比较轻量，性能开销小，通信高效；</li> <li>4）可以发送文本，也可以发送二进制数据；</li> <li>5）没有同源限制，客户端可以与任意服务器通信；</li> <li>6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL，形如：ws://example.com:80/some/path。</li></ul> <p>websocket断码测试</p> <table><thead><tr><th>刷新浏览器页面</th> <th>1001</th> <th>终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开.</th></tr></thead> <tbody><tr><td>关闭浏览器tab页面</td> <td>1001</td> <td>终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开.</td></tr> <tr><td>关闭浏览器, 所有标签页都会关闭。</td> <td>1001</td> <td>可以发现。无论是刷新，关闭tab页面还是关闭浏览器，错误码都是1001</td></tr> <tr><td>ws.close()</td> <td>1005</td> <td>主动调用close, 不传递错误码。对服务端来说，也是异常断开。 1005表示没有收到预期的状态码.</td></tr> <tr><td>ws.close(1000)</td> <td>1000</td> <td>正常的关闭，客户端必需传递正确的错误原因码。 原因码不是随便填入的。 比如 ws.close(1009) <strong>Failed to execute 'close' on 'WebSocket': The code must be either 1000, or between 3000 and 4999. 1009 is neither.</strong></td></tr></tbody></table> <h3 id="websocket、长轮询、轮询、sse的区别"><a href="#websocket、长轮询、轮询、sse的区别" class="header-anchor">#</a> websocket、长轮询、轮询、sse的区别</h3> <p><strong>短轮询(Polling)<strong>的实现思路就是浏览器端每隔几秒钟向</strong>服务器端</strong>发送http请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。<strong>在服务端响应完成，就会关闭这个Tcp连接</strong>，</p> <p>长轮询（Long-Polling）客户端发送请求后服务器端<strong>不会立即</strong>返回数据，服务器端会<strong>阻塞请求</strong>连接不会<strong>立即断开</strong>，直到服务器端<strong>有数据更新或者是连接超时</strong>才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。</p> <p>还有一种长轮询是当我们在页面中嵌入一个iframe并设置其src时，服务端就可以通过长连接“源源不断”地向客户端输出内容。 例如，我们可以向客户端返回一段<code>script</code>标签包裹的<code>javascript</code>代码，该代码就会在iframe中执行。因此，如果我们预先在<code>iframe</code>的父页面中定义一个处理函数process()，而在每次有新数据需要推送时，在该连接响应中写入。那么iframe中的这段代码就会调用父页面中预先定义的process()函数。</p> <p>SSE(Server-sent-Event):<code>Server-Sent</code>是<code>HTML5</code>提出一个标准。由客户端发起与服务器之间创建<code>TCP</code>连接，然后<strong>并维持这个连接</strong>，直到客户端或服务器中的任何一方断开，<code>ServerSent</code>使用的是&quot;问&quot;+&quot;答&quot;的机制，连接创建后浏览器会周期性地发送消息至服务器询问，是否有自己的消息。其实现原理类似于我们在上一节中提到的<strong>基于iframe的长连接模式</strong>。 HTTP响应内容有一种特殊的<code>content-type —— text/event-stream</code>，该响应头标识了响应内容为<strong>事件流</strong>，客户端<strong>不会关闭连接</strong>，而是等待服务端不断得发送响应结果。 SSE规范比较简单，主要分为两个部分：浏览器中的EventSource对象，以及服务器端与浏览器端之间的<strong>通讯协议</strong>。</p> <p>Web Sockets定义了一种在通过一个单一的 socket 在网络上进行<strong>全双工通讯的通道</strong>。仅仅是传统的 HTTP 通讯的一个增量的提高，尤其对于<strong>实时、事件驱动</strong>的应用来说是一个飞跃。</p> <table><thead><tr><th>#</th> <th>轮询(Polling)</th> <th>长轮询(Long-Polling)</th> <th>Websocket</th> <th>sse</th></tr></thead> <tbody><tr><td>通信协议</td> <td>http</td> <td>http</td> <td>tcp</td> <td>http</td></tr> <tr><td>触发方式</td> <td>client(客户端)</td> <td>client(客户端)</td> <td>client、server(客户端、服务端)</td> <td>client、server(客户端、服务端)</td></tr> <tr><td>优点</td> <td>兼容性好容错性强，实现简单</td> <td>比短轮询节约资源</td> <td>全双工通讯协议，性能开销小、安全性高，可扩展性强</td> <td>实现简便，开发成本低</td></tr> <tr><td>缺点</td> <td>安全性差，占较多的内存资源与请求数</td> <td>安全性差，占较多的内存资源与请求数</td> <td>传输数据需要进行二次解析，增加开发成本及难度</td> <td>只适用高级浏览器</td></tr> <tr><td>延迟</td> <td>非实时，延迟取决于请求间隔</td> <td>同短轮询</td> <td>实时</td> <td>非实时，默认3秒延迟，延迟可自定义</td></tr></tbody></table> <p>总结：</p> <p>兼容性：短轮询&gt;长轮询&gt;长连接SSE&gt;WebSocket</p> <p>性能：WebSocket&gt;长连接SSE&gt;长轮询&gt;短轮询</p> <p>服务端推送：WebSocket&gt;长连接SSE&gt;长轮询</p> <h2 id="前后端跨域9种方式"><a href="#前后端跨域9种方式" class="header-anchor">#</a> 前后端跨域9种方式</h2> <p>浏览器的同源策略/SOP（Same origin policy）是一种约定，所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。</p> <p>非同源的两个对象，Cookie、LocalStorage 和 IndexDB 无法读取2、 DOM 和 Js对象无法获得3、 AJAX 请求不能发送</p> <p>对于前后端分离，跨域是需要解决的问题</p> <p>跨域解决方法</p> <p>1.jsonp</p> <p>浏览器允许在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p> <p>手撸jsonp</p> <p>2.跨域资源共享（CORS）</p> <p>服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。CORS也已经成为主流的跨域解决方案。</p> <p>CORS是一种基于http头的机制，该机制通过允许服务器标识除了它自己以外的其他origin（域、协议或者端口），这样浏览器可以从这里加载资源。</p> <p>3.Nodejs中间件/Nginx代理跨域</p> <p>通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p> <p>利用node + express + http-proxy-middleware搭建一个proxy代理服务器。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 代理跨域目标接口</span>
    target<span class="token operator">:</span> <span class="token string">'http://www.demo2.com:8080'</span><span class="token punctuation">,</span>
    changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

    <span class="token comment">// 修改响应头信息，实现跨域并允许带cookie    </span>
      <span class="token function-variable function">onProxyRes</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">proxyRes<span class="token punctuation">,</span> req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'http://www.domain1.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>

      <span class="token comment">// 修改响应信息中的cookie域名</span>
      cookieDomainRewrite<span class="token operator">:</span> <span class="token string">'www.demo1.com'</span>  <span class="token comment">// 可以为false，表示不修改</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>实现思路：通过nginx配置一个代理服务器（域名与demo1相同，端口不同）做跳板机，反向代理访问demo2接口，并且可以顺便修改cookie中demo信息，方便当前域cookie写入，实现跨域登录。</p> <p>4.WebSocket协议跨域</p> <p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p> <p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p> <p>5.XMLHttpRequest</p> <p>HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，</p> <p>6.axios</p> <p>其他</p> <p>window.name + iframe跨域</p> <p>document.domain + iframe跨域</p> <p>location.hash + iframe跨域</p> <p>https://docs.qq.com/doc/BqI21X2yZIht1bfJDW0BNxAF0cqHEb1racd94Lv8jM4Uatg11</p> <h3 id="各种跨域方式对比"><a href="#各种跨域方式对比" class="header-anchor">#</a> 各种跨域方式对比</h3> <p>实现CORS的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信了</p> <p>浏览器将CORS请求分为两类，简单请求和复杂请求</p> <p>简单请求是指http方法为get、post、head三种之一，或者http头部信息不超过以下字段</p> <p>对于简单请求，请求时自动在请求头信息中添加Origin字段，说明本次请求是来自哪个源</p> <p>非简单请求是对服务器有特殊要求的请求，比如请求方法是PUT或者DELETE，或者cotent-type字段的类型是application/json</p> <p>对于非简单请求的CORS请求，会在正式通信之前增加一次HTTP查询请求，称为预检请求</p> <p>浏览器会先询问服务器当前的域名是否在服务器的许可名单之中，以及可使用哪些HTTP动词和头字段</p> <p>预检请求的请求信息</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code>OPTIONS /cors HTTP/<span class="token number">1.1</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>预检请求使用的请求方法是OPTIONS，表示这个请求是用来询问的。</p> <p>一旦服务器通过了预检请求，以后每次浏览器正常的CORS请求就会像简单请求一样，会有一个Origin头部信息</p> <p>CORS比jsonp更强大，JSONP只支持GET请求，CORS支持所有类型的HTTP请求。</p> <p>JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求。</p> <h2 id="跨域验证"><a href="#跨域验证" class="header-anchor">#</a> 跨域验证</h2> <p>方案一：cookie/session认证</p> <p>用户填写用户名和密码，发送给服务器</p> <p>局限：</p> <p>无法数据共享。如果A网站和B网站是同一家公司的</p> <p>方式二：JWT(Json Web Token)是最流行的跨域验证方案</p> <p>JWT的原理是服务器认证以后，生成一个json对象，发回给用户。用户与服务器通信都靠这个对象。为了防止用户篡改数据，服务端生成对象时会加上签名。</p> <p>JWT是一个很长的字符串，中间用点分隔成3个部分。JWT的三个部分依次是头部Header、负载Payload、签名Signature。</p> <p>头部定义签名的算法和令牌类型（默认为JWT），负载包含实际需要传递的数据，其中定义了七个字段</p> <p>iss：签发人，exp：过期时间 sub：主题。aud：受众 nbf：生效时间 iat：签发时间  jti:编号</p> <p>签名是对前两部分的签名，防止数据篡改</p> <p>使用方式：</p> <p>客户端收到服务器返回的JWT，可以存储在cookie中，也可以存储在localstorage中，</p> <p>客户端每次与服务器通信都带上JWT，把JWT放在http请求的头信息Authorization字段里面，就可以跨域访问。</p> <p>JWT的使用特点：</p> <p>JWT默认是不加密的，也可以加密，不加密时不能讲秘密数据写入JWT，加密时生成原生token用密钥加密。</p> <p>JWT不仅可以用于验证，也可以用于交换信息。有效使用JWT可以降低服务器查询数据库的次数</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tech/周边开发技术/hexo.html" class="prev">
        Hexo个人博客搭建及配置
      </a></span> <span class="next"><a href="/tech/周边开发技术/前后端开发概述(三).html">
        前后端开发概述
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.528f3631.js" defer></script><script src="/assets/js/2.619c82a8.js" defer></script><script src="/assets/js/33.463bffa3.js" defer></script>
  </body>
</html>
