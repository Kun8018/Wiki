<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React（三） | Kun&#39;s Wiki</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="meta的描述内容">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.1640ad01.js" as="script"><link rel="preload" href="/assets/js/2.619c82a8.js" as="script"><link rel="preload" href="/assets/js/24.df814ef2.js" as="script"><link rel="prefetch" href="/assets/js/10.278d8a33.js"><link rel="prefetch" href="/assets/js/11.c7f8ebb2.js"><link rel="prefetch" href="/assets/js/12.569b9db6.js"><link rel="prefetch" href="/assets/js/13.5794254e.js"><link rel="prefetch" href="/assets/js/14.5e07029a.js"><link rel="prefetch" href="/assets/js/15.ad4e2769.js"><link rel="prefetch" href="/assets/js/16.480e9db9.js"><link rel="prefetch" href="/assets/js/17.5acf884d.js"><link rel="prefetch" href="/assets/js/18.d6f9547b.js"><link rel="prefetch" href="/assets/js/19.2467c209.js"><link rel="prefetch" href="/assets/js/20.79dfac4b.js"><link rel="prefetch" href="/assets/js/21.442debb3.js"><link rel="prefetch" href="/assets/js/22.bb10007f.js"><link rel="prefetch" href="/assets/js/23.7f317014.js"><link rel="prefetch" href="/assets/js/25.383ae6d0.js"><link rel="prefetch" href="/assets/js/26.3acb69aa.js"><link rel="prefetch" href="/assets/js/27.1652bed7.js"><link rel="prefetch" href="/assets/js/28.cd2fc01f.js"><link rel="prefetch" href="/assets/js/29.227af7be.js"><link rel="prefetch" href="/assets/js/3.93a4eba1.js"><link rel="prefetch" href="/assets/js/30.1043f968.js"><link rel="prefetch" href="/assets/js/31.438dbfe5.js"><link rel="prefetch" href="/assets/js/32.625e12e6.js"><link rel="prefetch" href="/assets/js/33.9ea3599f.js"><link rel="prefetch" href="/assets/js/34.19483a82.js"><link rel="prefetch" href="/assets/js/35.77bf62fe.js"><link rel="prefetch" href="/assets/js/36.42ee25a5.js"><link rel="prefetch" href="/assets/js/37.a757d6b1.js"><link rel="prefetch" href="/assets/js/38.b508b244.js"><link rel="prefetch" href="/assets/js/39.a732e156.js"><link rel="prefetch" href="/assets/js/4.2fb93bc2.js"><link rel="prefetch" href="/assets/js/40.92f6dd98.js"><link rel="prefetch" href="/assets/js/41.bc2021e0.js"><link rel="prefetch" href="/assets/js/42.c8d68adc.js"><link rel="prefetch" href="/assets/js/43.5abe686d.js"><link rel="prefetch" href="/assets/js/44.feb95a51.js"><link rel="prefetch" href="/assets/js/45.2225b733.js"><link rel="prefetch" href="/assets/js/46.9f353a58.js"><link rel="prefetch" href="/assets/js/47.37eae0b5.js"><link rel="prefetch" href="/assets/js/48.cca64988.js"><link rel="prefetch" href="/assets/js/49.a4ba28c5.js"><link rel="prefetch" href="/assets/js/5.1474cf9c.js"><link rel="prefetch" href="/assets/js/50.94e8d637.js"><link rel="prefetch" href="/assets/js/51.3c73b205.js"><link rel="prefetch" href="/assets/js/52.e3973fd0.js"><link rel="prefetch" href="/assets/js/53.3edd1cfa.js"><link rel="prefetch" href="/assets/js/54.64621500.js"><link rel="prefetch" href="/assets/js/55.c50c8888.js"><link rel="prefetch" href="/assets/js/56.e412338a.js"><link rel="prefetch" href="/assets/js/57.57166ded.js"><link rel="prefetch" href="/assets/js/58.1f34de3f.js"><link rel="prefetch" href="/assets/js/59.699c7b6b.js"><link rel="prefetch" href="/assets/js/6.2958d7f8.js"><link rel="prefetch" href="/assets/js/60.14d6d81f.js"><link rel="prefetch" href="/assets/js/61.d4ca4fd3.js"><link rel="prefetch" href="/assets/js/62.ef27ca5a.js"><link rel="prefetch" href="/assets/js/63.b75c5f2e.js"><link rel="prefetch" href="/assets/js/64.f924edfe.js"><link rel="prefetch" href="/assets/js/65.2049de2c.js"><link rel="prefetch" href="/assets/js/66.b67a2359.js"><link rel="prefetch" href="/assets/js/67.fef79d4b.js"><link rel="prefetch" href="/assets/js/68.b0e03deb.js"><link rel="prefetch" href="/assets/js/69.e066586e.js"><link rel="prefetch" href="/assets/js/7.4f3f4813.js"><link rel="prefetch" href="/assets/js/70.326b651c.js"><link rel="prefetch" href="/assets/js/71.fbda0ecf.js"><link rel="prefetch" href="/assets/js/72.62cd018c.js"><link rel="prefetch" href="/assets/js/73.e0f8698d.js"><link rel="prefetch" href="/assets/js/74.101cf034.js"><link rel="prefetch" href="/assets/js/75.01528f28.js"><link rel="prefetch" href="/assets/js/76.e95c7d0a.js"><link rel="prefetch" href="/assets/js/77.7363e7ce.js"><link rel="prefetch" href="/assets/js/78.98f5c9ba.js"><link rel="prefetch" href="/assets/js/79.0d8cc536.js"><link rel="prefetch" href="/assets/js/8.521cb409.js"><link rel="prefetch" href="/assets/js/80.77bea8e4.js"><link rel="prefetch" href="/assets/js/81.a2e92e86.js"><link rel="prefetch" href="/assets/js/82.06388ab2.js"><link rel="prefetch" href="/assets/js/83.97949f19.js"><link rel="prefetch" href="/assets/js/84.849073b1.js"><link rel="prefetch" href="/assets/js/85.c33da5d5.js"><link rel="prefetch" href="/assets/js/9.5faf2f06.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Kun's Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="/tech/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/research/" class="nav-link">
  科研
</a></div><div class="nav-item"><a href="/shoot/" class="nav-link">
  摄影
</a></div><div class="nav-item"><a href="https://www.github.com/kun8018" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="/tech/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/research/" class="nav-link">
  科研
</a></div><div class="nav-item"><a href="/shoot/" class="nav-link">
  摄影
</a></div><div class="nav-item"><a href="https://www.github.com/kun8018" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Tech</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/" aria-current="page" class="sidebar-link">Blogging Like a Hacker</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/react/react.html" class="sidebar-link">React</a></li><li><a href="/tech/react/react2.html" class="sidebar-link">React（二）</a></li><li><a href="/tech/react/react3.html" aria-current="page" class="active sidebar-link">React（三）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/react/react3.html#react原理" class="sidebar-link">React原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/react/react3.html#合成事件" class="sidebar-link">合成事件</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#fiber架构" class="sidebar-link">Fiber架构</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#props与state的区别" class="sidebar-link">props与state的区别</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#setstate原理" class="sidebar-link">setState原理</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#setstate的异步同步" class="sidebar-link">setState的异步同步</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#react-diff算法的机制" class="sidebar-link">react diff算法的机制</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#react渲染机制-work-loop" class="sidebar-link">React渲染机制(work loop)</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#effect-hook机制" class="sidebar-link">Effect Hook机制</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#state、reducer-hook机制" class="sidebar-link">State、Reducer Hook机制</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#hook系统原理" class="sidebar-link">Hook系统原理</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#redux原理" class="sidebar-link">redux原理</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#redux-reducer" class="sidebar-link">redux-reducer</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#redux中间件机制" class="sidebar-link">redux中间件机制</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#redux-compose实现" class="sidebar-link">Redux compose实现</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#利用context-api实现redux" class="sidebar-link">利用context api实现redux</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#react-router原理" class="sidebar-link">React-router原理</a></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#手写自定义hook-实现切换状态" class="sidebar-link">手写自定义hook，实现切换状态</a></li></ul></li><li class="sidebar-sub-header"><a href="/tech/react/react3.html#react优化" class="sidebar-link">React优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/react/react3.html#懒渲染react-visibility-observer" class="sidebar-link">懒渲染react-visibility-observer</a></li></ul></li></ul></li><li><a href="/tech/react/react4.html" class="sidebar-link">React（四）</a></li><li><a href="/tech/react/react5.html" class="sidebar-link">React（五）</a></li><li><a href="/tech/react/reactnative.html" class="sidebar-link">React Native入门</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>周边开发技术</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>数据库相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>服务器技术</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>桌面端开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>移动端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>进阶前端技术</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>静态语言</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>业余研究</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>关于</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>年终总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>科学研究</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>​      前端框架，快速开发页面，函数式编程，与后端api快速搭建</p> <h2 id="react原理"><a href="#react原理" class="header-anchor">#</a> React原理</h2> <h3 id="合成事件"><a href="#合成事件" class="header-anchor">#</a> 合成事件</h3> <p>React合成事件是React模拟原生DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器。它根据w3c规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口</p> <p>在React中，所有事件都是合成的，不是原生DOM事件，但可以通过e。nativeEvent属性获取DOM事件</p> <p>React合成事件存在的目的：</p> <p>1.为了更好的进行浏览器兼容，更好地跨平台</p> <p>React采用的是顶层事件代理机制，能够保证冒泡一致性，可以跨浏览器执行。React提供的合成事件用来抹平不同浏览器事件对象之间的差异，将不同平台事件模拟合成事件</p> <p>2.避免垃圾回收</p> <p>事件对象可能会被频繁创建和回收，因为react引入事件池，在事件池中获取或释放事件对象。即react事件对象不会被释放掉，而是存放在一个数组中，当事件触发时，就从这个数组中弹出，避免频繁地创建和销毁，垃圾回收</p> <p>3.方便事件统一管理和事务机制</p> <p>由于fiber架构的特点，生成一个fiber节点时，它对应的dom节点有可能还未挂载，事件处理函数作为fiber节点的props，也就不能直接绑定到真实的dom节点上。为此，react提供了一种顶层注册、事件收集、统一触发的事件绑定机制</p> <p>在React中，合成事件会以事件委托的形式绑定在组件最上层，即React所有事件都挂载在document对象上（react16及之前），react17之后绑定在root element元素对象上，并在组件卸载阶段自动销毁绑定的事件。事件委托是对冒泡机制进行优化。
事件收集是指事件触发时构造合成事件对象，按照冒泡或者捕获的路径去组件中收集真正的事件处理函数</p> <p>统一触发是</p> <p>绑定到根组件而非document对象上的原因是为了react渐进升级，避免多版本react共同使用时事件系统发生冲突。</p> <p>在react中人为地将事件划分等级，最终目的是确定调度任务的轻重缓急。</p> <p>react按照事件的紧急程度，对事件的优先级分类：</p> <p>离散事件discreteEvent：click、keydown、focus等，这些事件的触发不是连续的，优先级为0</p> <p>用户阻塞事件User Blocking Event：drag、scroll、mouseover等，特点是连续触发，阻塞渲染，优先级为1</p> <p>连续事件ContinuousEvent：canplay、error、audio标签等timeupdate等，优先级最高，为2</p> <p>四种优先级：</p> <p>事件优先级：按照用户事件的交互紧急程度，由事件本身决定</p> <p>更新优先级：事件导致react产生的更新对象的优先级，由事件计算得出</p> <p>任务优先级：产生更新对象之后，react去执行一个更新任务，这个任务所持有的优先级</p> <p>调度优先级：Scheduler根据React更新任务生成一个调度任务，调度优先级根据任务优先级获取</p> <p>事件优先级是在注册阶段被确定的。在root上注册事件时，会根据事件的类别，创建不同优先级的事件监听，最终将它绑定到root上。最终绑定到root上的事件监听其实是dispatchDiscreteEvent、dispatchUserBlockingUpdate、dispatchEvent三个事件中的一个</p> <p>事件的执行会创建一个update对象，update对象创建完成后意味着需要对页面进行更新，会调用scheduleUpdateOnFiber进入调度，而真正开始调度之前会计算本次产生的更新任务的任务优先级，目的是与已有任务的任务优先级去做比较，便于作出多任务的调度决策</p> <p>任务优先级被用来区分多个更新任务的紧急程度，它由更新优先级计算而来。任务优先级保证高优先级任务及时响应，收敛同等优先级的任务调度。</p> <p>一旦事件被调度，那么它就会进入Scheduler，在Scheduler中这个任务会被包装一下，生成一个属于属于Schedule自己的task，这个task持有的优先级就是调度优先级</p> <p>在Scheduler中，分别用过期任务和未过期任务的队列去管理它内部的task，过期任务的队列中的task根据过期事件去排序，最早过期的排在前面，便于被最先处理，而过期时间是有调度优先级计算出的，不同的调度优先级对应的过期时间不同</p> <h3 id="fiber架构"><a href="#fiber架构" class="header-anchor">#</a> Fiber架构</h3> <p>react16相比于react15，经过重构后Reconciliation和Rendering被分为两个不同的阶段。</p> <h4 id="fiber架构中的基本概念"><a href="#fiber架构中的基本概念" class="header-anchor">#</a> fiber架构中的基本概念</h4> <p>Fiber 的架构有两个主要阶段：协调/渲染 和 提交。</p> <p><strong>reconciler协调阶段</strong>：当组件次初始化和其后的状态更新中，React会创建两颗不相同的虚拟树，React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步，计算树哪些部分需要更新。<strong>react diff算法就发生在这个阶段</strong></p> <p><strong>renderer阶段</strong>：渲染器负责将拿到的虚拟组件树信息，根据其对应环境真实地更新渲染到应用中。有兴趣的朋友可以看一下dan自己的博客中的文章=》<a href="https://overreacted.io/react-as-a-ui-runtime/#renderers" target="_blank" rel="noopener noreferrer">运行时的react=》渲染器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，介绍了react的Renderer渲染器如react-dom和react native等，其可以根据不同的主环境来生成不同的实例。</p> <p>协调阶段的工作：</p> <p>协调阶段这是React遍历组件树的阶段，并且：</p> <ul><li>更新状态和属性</li> <li>调用生命周期钩子</li> <li>获取组件的<code>children</code></li> <li>将它们与之前的<code>children</code>进行对比</li> <li>并计算出需要执行的DOM更新</li></ul> <p><strong>fiber对象</strong></p> <p>一个fiber对象是表征work的一个基本单元。</p> <p>每一个React元素对应一个fiber对象，fibers是一个基于child, sibling 和 return属性构成的链表。 fiber对象核心的属性和含义如下所示：</p> <p><strong>child、silbing、return</strong></p> <p>fiber对象的属性，这些属性指向其他fiber，表征当前工作单元的下一个工作单元，用于描述fiber的递归树结构。</p> <p>child： 对应于父fiber节点的子fiber silbing： 对应于fiber节点的同类兄弟节点 return： 对应于fiber节点的父节点</p> <p>相对于React v16之前的版本，正是得益于fiber对象的child、sibing和return属性构成的单链表结构以及fiber对象中存储的上下文信息，才使得scheduler可以达到暂停、中止、重新开始等并发模式的新特性。</p> <p><strong>work</strong></p> <p>在React reconciliation过程中出现的各种比如state update，props update 或 refs update等必须执行计算的活动，这些活动我们在Fiber架构体系里面统一称之为 “work”。</p> <p><strong>worktag</strong></p> <p>workTag 类型，用于描述一个React元素的类型，即为上述fiber对象的 fiber.tag</p> <p><strong>stateNode</strong></p> <p>一个组件、一个DOM节点或其他跟fiber节点相关联的React元素的实例的引用。通常，我们可以说这个属性是用于保存与一个fiber相关联的本地状态。即上述fiber对象的 fiber.stateNode。</p> <h4 id="双缓存机制"><a href="#双缓存机制" class="header-anchor">#</a> 双缓存机制</h4> <p><strong>current树和workInProgress树</strong></p> <p>首次渲染后，React生成一个用于渲染UI并能映射应用状态的fiber树，我们通常称之为current树。当React遍历current树，它为每一个存在的fiber节点创建一个alternate属性的替代节点，该节点构成workInProgress树。</p> <p>所有发生update的work都在workInProgress树中执行，如果alternate属性还未创建，React将在处理update之前在createWorkInProgress函数中创建一个current树的副本，即形成workInProgress树，用于映射新的状态并在commit阶段刷新到屏幕。</p> <p><strong>所有这些活动都被称为Fiber内部的工作。</strong> 需要完成的工作类型取决于React Element的类型。 例如，对于 <code>Class Component</code> React需要实例化一个类，然而对于<code>Functional Component</code>却不需要。</p> <p>在浏览器中GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p> <p><strong>Stack Reconciler 和 fiber reconciliation</strong></p> <p>React16 推出Fiber之前协调算法是Stack Reconciler，即递归遍历所有的 Virtual DOM 节点执行Diff算法，一旦开始便无法中断，直到整颗虚拟dom树构建完成后才会释放主线程，因其JavaScript单线程的特点，若当下组件具有复杂的嵌套和逻辑处理，diff便会堵塞UI进程，使动画和交互等优先级相对较高的任务无法立即得到处理，造成页面卡顿掉帧，影响用户体验。在<code>React15</code>及之前，<code>React</code>会递归比对<code>VirtualDOM</code>树，找出需要变动的节点，然后同步更新它们。这个过程<code>React</code>称为<code>Reconciliation(协调)</code>。</p> <p>在<code>Reconciliation</code>期间，<code>React</code>会一直占用着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可能会感觉到卡顿。</p> <p>针对上述痛点，我们期望将**”找出有增删改的节点“，”然后同步更新他们“<strong>这个过程分解成两个独立的部分，或者通过某种方式能让整个过程</strong>可中断可恢复的执行**，类似于多任务操作系统的单处理器调度。</p> <p>fiber的核心目标：</p> <ul><li>把可中断的工作拆分成多个小任务</li> <li>为不同类型的更新分配任务优先级</li> <li>更新时能够暂停，终止，复用渲染任务</li></ul> <p>这是一种<strong>合作式调度</strong>，需要程序和浏览器互相信任。浏览器作为领导者，会分配执行时间片（即requestIdleCallback）给程序去选择调用，程序需要按照约定在这个时间内执行完毕，并将控制权交还浏览器。</p> <p>Fiber是一个执行单元，每次执行完一个执行单元，React就会检查现在还剩多少时间，如果没有时间就将控制权交还浏览器；然后继续进行下一帧的渲染。</p> <p>从根节点开始遍历</p> <p>如果没有长子，则标识当前节点遍历完成。<code>completeUnitOfWork</code>中收集</p> <p>如果没有相邻兄弟，则返回父节点标识父节点遍历完成。<code>completeUnitOfWork</code>中收集</p> <p>如果没有父节点，标识所有遍历完成。<code>over</code></p> <p>如果有长子，则遍历；<code>beginWork</code>中收集；收集完后返回其长子，回到<code>第2步</code>循环遍历</p> <p>如果有相邻兄弟，则遍历；<code>beginWork</code>中收集；收集完后返回其长子，回到<code>第2步</code>循环遍历</p> <h4 id="render阶段"><a href="#render阶段" class="header-anchor">#</a> Render阶段</h4> <p><strong>enqueueSetState</strong></p> <p>以类组件为例，ReactDOM中的updater对象是一个classComponentUpdater，用于获取fiber实例、update队列和调度 work</p> <p>fiber.updateQueue是一个具有updates优先级的链表（UpdateQueue is a linked list of prioritized updates）</p> <p>跟Fiber一样，update 队列也是成对出现：一个代表屏幕可见状态的 current 队列，一个在commit阶段之前可被异步计算和处理的work-in-progress 队列。如果一个work-in-progress队列在完成之前被丢弃，则将会通过克隆一个curent队列来创建一个新的work-in-progress队列。</p> <p>函数调用栈：performUnitOfWork --&gt; beginWork --&gt; updateClassComponent --&gt; finishedComponent --&gt; completeUnitOfWork</p> <p><strong>completeUnitOfWork</strong></p> <p>React在completeUnitOfWork函数中构建effect-list</p> <p>是深度优先搜索算法一部分，获取workInProgress.alternate、父节点workInProgress.return和workInProgress.sibling，如果存在兄弟节点则返回。否则，返回父节点。</p> <h4 id="commit阶段"><a href="#commit阶段" class="header-anchor">#</a> Commit阶段</h4> <p>类似于<code>Git</code>的分支功能，从旧树里面fork一份，在新分支中进行<strong>添加、删除、更新</strong>操作，然后再进行提交。</p> <p>fiber大量使用链表。由于数组的大小是固定的，从数组的起点或者中间插入或移除项的成本很高。链表相对于传统的数组的优势在于添加或移除元素的时候不需要移动其他元素，<strong>需要添加和移除很多元素时，最好的选择是链表，而非数组。</strong> 链表在React的Fiber架构和Hooks实现发挥很大的作用。</p> <p>commit阶段被分为几个子阶段。每个子阶段都单独进行effect list传递。所有的mutation effects都会在所有的layout effects之前执行。</p> <p>被分为如下三个子阶段：</p> <ul><li>before mutation：React使用此阶段读取 host tree的state状态。 这是调用getSnapshotBeforeUpdate生命周期的地方。</li> <li>mutation phase：在这个阶段，React 会改变host tree。 当该阶段执行结束时，work-in-progress树会变成current树，这必须发生在“mutation phase”阶段之后，以便于在componentWillUnmount生命周期内，仍然是之前的current树。但是，也要发生在“layout phase”阶段之前，以便于在componentDidMount / Update生命周期间，current树是已完成的work操作的。</li> <li>layout phase：在这个阶段hfost tree已经被更改并调用 effects。componentDidMount / Update等生命周期在这个阶段被执行。</li></ul> <h3 id="props与state的区别"><a href="#props与state的区别" class="header-anchor">#</a> props与state的区别</h3> <p>props和state都是普通的JavaScript对象，它们都是用来保存信息的，这些信息可以控制组件的渲染输出。不同点：</p> <p>props是传递给组件的，而state是组件内被组件自己管理</p> <p>props是不可修改的，所有react组件必须像纯函数一样保护它们的props不被修改，由于props是不可变的，因为如果一个组件中只有props，那么就视为pureComponent</p> <p>state实在组件中创建的，一般在constructor中初始化state</p> <p>state是多变的，可以修改的，每次setState都是异步更新的</p> <p>在react中，this.props和this.state都代表已经被渲染了的值，即当前屏幕显示的值。而调用setstate通常是异步的，因此如果你想基于当前的state计算出新的值，那么应该传递一个新函数，而不是一个对象</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>increment() {
  this.setState({count: this.state.count + 1})
}

increment() {
  this.setState({count: state.count + 1})
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="setstate原理"><a href="#setstate原理" class="header-anchor">#</a> setState原理</h3> <p>setState的执行过程：</p> <p>1.将setState传入的<code>partialState</code>参数存储在当前组件实例的state暂存队列中。</p> <p>2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。</p> <p>3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。</p> <p>4.调用事务的<code>waper</code>方法，遍历待更新组件队列依次执行更新。</p> <p>5.执行生命周期<code>componentWillReceiveProps</code>。</p> <p>6.将组件的state暂存队列中的<code>state</code>进行合并，获得最终要更新的state对象，并将队列置为空。</p> <p>7.执行生命周期<code>componentShouldUpdate</code>，根据返回值判断是否要继续更新。</p> <p>8.执行生命周期<code>componentWillUpdate</code>。</p> <p>9.执行真正的更新，<code>render</code>。</p> <p>10.执行生命周期<code>componentDidUpdate</code>。</p> <h3 id="setstate的异步同步"><a href="#setstate的异步同步" class="header-anchor">#</a> setState的异步同步</h3> <p>简单来说，只要setState在react的调度流程中，就是异步的，只要没有进入react的流程中，那就是同步的。不会进入react调度流程的事件：setTimeout，setInterval、直接在DOM上绑定原生事件等，都不会走React调度流程。在这些情况里面调用setState就是同步的，否则就是异步的。</p> <p><code>setState</code>只在合成事件和钩子函数中是“异步”的，在原生事件和<code>setTimeout</code> 中都是同步的。</p> <p><code>setState</code> 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的<code>callback</code>拿到更新后的结果。</p> <p>在<code>react</code>的生命周期和合成事件中，<code>react</code>仍然处于他的更新机制中，这时<code>isBranchUpdate</code>为true。</p> <p>按照上述过程，这时无论调用多少次<code>setState</code>，都会不会执行更新，而是将要更新的<code>state</code>存入<code>_pendingStateQueue</code>，将要更新的组件存入<code>dirtyComponent</code>。</p> <p>当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件<code>didmount</code>后会将<code>isBranchUpdate</code>设置为false。这时将执行之前累积的<code>setState</code>。</p> <p><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次<code>setState</code>，<code>setState</code>的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时<code>setState</code>多个不同的值，在更新时会对其进行合并批量更新。</p> <p>也就是说，一个方法里需要多次调用setState，setState了很多次，然后render（）只调用了一次</p> <p>原因：</p> <p>React会将多个this.setState产生的修改放在一个队列里，缓一缓，攒在一起，觉得差不多了再引发一次更新过程。</p> <p>react为了提高整体的渲染性能，会将一次渲染周期中的state进行合并，在这个渲染周期中你对所有setState的所有调用都会被合并起来之后，再一次性的渲染，这样可以避免频繁的调用setState导致频繁的操作dom，提高渲染性能。具体的实现方面，可以简单的理解为react中存在一个状态变量isBatchingUpdates，当处于渲染周期开始时，这个变量会被设置成true，渲染周期结束时，会被设置成false，react会根据这个状态变量，当出在渲染周期中时，仅仅只是将当前的改变缓存起来，等到渲染周期结束时，再一次性的全部render。</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>1.调用setState不会立即更新
2.所有组件使用的是同一套更新机制，当所有组件didmount后，父组件didmount，然后执行更新
3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="setstate更新数组"><a href="#setstate更新数组" class="header-anchor">#</a> setstate更新数组</h4> <p>对于数组和对象这种引用类型的数据，setstate只能改变引用地址，改变时只能用新的对象或者数组赋值，不能直接在原对象上改</p> <p>可以使用原生js或者react官方推荐immutablejs更新数组</p> <p>实例</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>//错误例子
var list = [1];
list.push(2)
//list对象已经变化，然而引用的值依然还是同一个引用

//正确更新数组
var list = this.state.list;
this.setState({
  list:list.concat('otherData')
})

this.setState({
  list:[...list,'otherData']
})

//正确更新对象
//使用object.assign方法
var user = this.state.user;
this.setState({
  user.Object.assign({},user,{age:18})
})
//使用对象拓展语法
var user = this.state.user;
this.setState({
  user:{...user,age:18}
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>ImmutableJS更新数组</p> <h4 id="连续调用setstate只有一次生效"><a href="#连续调用setstate只有一次生效" class="header-anchor">#</a> 连续调用setstate只有一次生效</h4> <p>实例1</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>componentDidMount() {
    this.setState({ index: this.state.index + 1 }, () =&gt; {
      console.log(this.state.index);
    })
    this.setState({ index: this.state.index + 1 }, () =&gt; {
      console.log(this.state.index);
    })
}
//输出
1
1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>实例2</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>componentDidMount() {
    this.setState((preState) =&gt; ({ index: preState.index + 1 }), () =&gt; {
      console.log(this.state.index);
    })
    this.setState(preState =&gt; ({ index: preState.index + 1 }), () =&gt; {
      console.log(this.state.index);
    })
}
//输出
2
2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>原因：</p> <ul><li>1.直接传递对象的<code>setstate</code>会被合并成一次</li> <li>使用函数传递<code>state</code>不会被合并</li></ul> <h4 id="setstate自动触发两次"><a href="#setstate自动触发两次" class="header-anchor">#</a> setstate自动触发两次</h4> <p>严格模式下，</p> <h4 id="定时器中的setstate"><a href="#定时器中的setstate" class="header-anchor">#</a> 定时器中的setstate</h4> <p>定时器中的 setState，每次都会引起新的 render，即使是同一个定时器中的多次 setState</p> <p>因为定时器中的<code>setState</code>没走<code>react</code>的事物机制，执行时批量更新没被设置<code>true</code>，所以每次都直接 render 了。</p> <p>在事件执行的时候，<strong>当前上下文</strong>执行的是<code>setTimeout</code>函数，但当执行<code>setTimeout</code>函数的回调时，原来的上下文已经结束了，<strong>回调的上下文变成了 window</strong>，所以依据的批量更新属性<code>isBatchingUpdates</code>没有被设置成<code>true</code>的过程，因此始终是<code>false</code>，因此<code>setState</code>就同步执行了。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        me<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            count<span class="token operator">:</span> me<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        me<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            count<span class="token operator">:</span> me<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

   <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        me<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            count<span class="token operator">:</span> me<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        me<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            count<span class="token operator">:</span> me<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">onClickTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        me<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            count<span class="token operator">:</span> me<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        me<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            count<span class="token operator">:</span> me<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>其实在回调函数中，setState 是不会触发批量更新机制的，无论是 promise，ajax，setTimeout 回调等等，同时设置多次 setState，每个 setState 都会单独执行并 render，因为上下文发生了变化。</p> <h4 id="原生事件中的setstate"><a href="#原生事件中的setstate" class="header-anchor">#</a> 原生事件中的setstate</h4> <p>在按钮原生事件中定义的<code>setState</code>,和定时器效果一样，每次<code>setState</code>都会引起新的<code>render</code></p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>componentDidMount() {
       this.button.addEventListener('click', this.onClick.bind(this, '原生事件'), false);
}

onClick(info) {
       console.log(info);
       this.setState({
           count: ++count
       });
       this.setState({
           count: ++count
       });
   }

   render() {
       console.log(this.state.count);
       return &lt;div&gt;
           &lt;input type=&quot;button&quot; ref={input =&gt; this.button = input} onClick={this.onClick.bind(this, 'React事件')} value=&quot;生成计时器&quot; /&gt;
           &lt;div&gt;Count:{this.state.count}&lt;/div&gt;
       &lt;/div&gt;
   }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="生命周期函数调用setstate"><a href="#生命周期函数调用setstate" class="header-anchor">#</a> 生命周期函数调用setstate</h4> <p>在componentDidMount()中，你 可以立即调用setState()。它将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使render()将会调用两次，用户也不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。在大多数情况下，你可以 在constructor()中使用赋值初始状态来代替。然而，有些情况下必须这样，比如像模态框和工具提示框。这时，你需要先测量这些DOM节点，才能渲染依赖尺寸或者位置的某些东西。</p> <p>componentWillUpdate和componentDidUpdate这两个生命周期中不能调用<code>setState</code>。</p> <p>在这两个生命周期里面调用<code>setState</code>会造成死循环，导致程序崩溃。</p> <p>在调用<code>setState</code>时使用函数传递<code>state</code>值，在回调函数中获取最新更新后的<code>state</code>。</p> <h3 id="react-diff算法的机制"><a href="#react-diff算法的机制" class="header-anchor">#</a> react diff算法的机制</h3> <p>diff算法的瓶颈</p> <p>由于diff操作本身也会带来性能损耗，react文档中提到，即使在最前沿的算法中，将前后两棵树完全对比的算法的复杂程度为O(n3)，其中n是树中元素的数量</p> <p>如果在react中使用了该算法，那么展示1000个元素所需要执行的计算量将在10亿范围的量级，这个开销实在太高。</p> <p>为了降低算法的复杂度，react的diff预设了3个限制：</p> <p>1.同级元素进行diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用</p> <p>2.不同类型的元素会产生出不同的树，如果元素由div变为p，react会销毁div及其子孙节点，并新建p及其子孙节点</p> <p>3.开发者可以通过prop key暗示哪些子元素在不同的渲染下能保持稳定</p> <p>举个例子</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>//更新前
&lt;div&gt;
   &lt;p key=&quot;ka&quot;&gt;ka&lt;/p&gt;
   &lt;h3 key=&quot;song&quot;&gt;song&lt;/h3&gt;
&lt;/div&gt;
//更新后
&lt;div&gt;
   &lt;h3 key=&quot;song&quot;&gt;song&lt;/h3&gt;
   &lt;p key=&quot;ka&quot;&gt;ka&lt;/p&gt;
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果没有key，react会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p，这符合限制2的设定，因此会销毁并重建</p> <p>当用key指明了节点的前后对应关系后，react知道key=&quot;ka&quot;的p在更新之后还存在，因此节点可以复用，只需要交换一下顺序即可</p> <h3 id="react渲染机制-work-loop"><a href="#react渲染机制-work-loop" class="header-anchor">#</a> React渲染机制(work loop)</h3> <p>React 16 之前的组件渲染方式是递归渲染：渲染父节点 -&gt; 渲染子节点</p> <p>递归渲染看起来十分简单，但是如果想在子节点的渲染过程中执行优先级更高的操作，只能保留调用栈中子节点的渲染及子节点之前节点的渲染，这样是很复杂的，这种调和/渲染也叫做 Stack Reconciler。</p> <p>Fiber 使用链表的结构去渲染节点，每一个节点都称之为 Fiber Node，每个节点会有三个属性：</p> <ul><li>child 指向第一个子节点</li> <li>sibling 指向兄弟节点</li> <li>return 指向父节点</li></ul> <p>Fiber 的渲染方式：从父节点开始，向下依次遍历子节点，深度优先渲染完子节点后，再回到其父节点去检查是否有兄弟节点，如果有兄弟节点，则从该兄弟节点开始继续深度优先的渲染，直到回退到根节点结束。</p> <p>综上，可以分为 Scheduler、Reconciliation、Commit 这三个阶段</p> <p>Scheduer 流程主要是创建更新，创建更新的方式：</p> <ul><li>ReactDOM.render</li> <li>setState</li></ul> <p>可以发现 React 将首次渲染和更新渲染统一了起来。</p> <h4 id="什么时候重新渲染"><a href="#什么时候重新渲染" class="header-anchor">#</a> 什么时候重新渲染</h4> <p>1.组件的state发生变化，如props变化或者通过setstate变化</p> <p>2.shouldComponentUpdate</p> <p>shouldComponentUpdate方法默认总是返回true，可以重写shouldComponentUpdate方法来看它是否返回true</p> <h3 id="effect-hook机制"><a href="#effect-hook机制" class="header-anchor">#</a> Effect Hook机制</h3> <p>effect hook与其他hook的行为有一些区别</p> <p>effect hook的属性：</p> <p>​		在渲染时被创建，在浏览器执行绘制后运行；</p> <p>​		如果给出销毁指令，会在下一次绘制前被销毁；</p> <p>​		会按照定义的顺序被运行</p> <p>hook effect 将会被保存在 fiber 一个称为 <code>updateQueue</code> 的属性上，每个 effect 节点都有如下的结构.</p> <ul><li><code>tag</code> —— 一个二进制数字，它控制了 effect 节点的行为（后文我将详细说明）。</li> <li><code>create</code> —— 绘制<strong>之后</strong>运行的回调函数。</li> <li><code>destroy</code> —— 它是 <code>create()</code> 返回的回调函数，将会在初始渲染<strong>前</strong>运行。</li> <li><code>inputs</code> —— 一个集合，该集合中的值将会决定一个 effect 节点是否应该被销毁或者重新创建。</li> <li><code>next</code> —— 它指向下一个定义在函数组件中的 effect 节点。</li></ul> <p>除了 <code>tag</code> 属性，其他的属性都很简明易懂。如果你对 hook 很了解，你应该知道，React 提供了一些特殊的 effect hook：比如 <code>useMutationEffect()</code> 和 <code>useLayoutEffect()</code>。这两个 effect hook 内部都使用了 <code>useEffect()</code>，实际上这就意味着它们创建了 effect hook，但是却使用了不同的 tag 属性值。</p> <p>Default effect —— <code>UnmountPassive | MountPassive</code>.</p> <p>Mutation effect —— <code>UnmountSnapshot | MountMutation</code>.</p> <p>Layout effect —— <code>UnmountMutation | MountLayout</code>.</p> <h3 id="state、reducer-hook机制"><a href="#state、reducer-hook机制" class="header-anchor">#</a> State、Reducer Hook机制</h3> <p><code>useReducer</code> 和 <code>useState</code> 本质上是一个原理，虽然我们平时会使用 <code>useState</code> 更多，但事实上 <code>useState</code> 是 <code>useReducer</code> 的封装；</p> <h3 id="hook系统原理"><a href="#hook系统原理" class="header-anchor">#</a> Hook系统原理</h3> <p>Dispatcher</p> <p>dispatcher 是一个包含了 hook 函数的共享对象。基于 ReactDOM 的渲染状态，它将会被动态的分配或者清理，并且它能够确保用户不可在 React 组件之外获取 hook</p> <p>在切换到正确的 Dispatcher 以渲染根组件之前，我们通过一个名为 <code>enableHooks</code> 的标志来启用/禁用 hook。在技术上来说，这就意味着我们可以在运行时开启或关闭 hook。React 16.6.X 版本中也有对此的实验性实现，但它实际上处于禁用状态</p> <p>当我们完成渲染工作后，我们将 dispatcher 置空并禁止用户在 ReactDOM 的渲染周期之外使用 hook。这个机制能够保证用户不会做什么蠢事</p> <p>dispatcher 在每次 hook 的调用中都会被函数 <code>resolveDispatcher()</code> 解析。正如我之前所说，在 React 的渲染周期之外，这些都无意义了，React 将会打印出警告信息：<strong>“hook 只能在函数组件内部调用”</strong></p> <p>Hook队列</p> <p>在 React 后台，hook 被表示为以调用顺序连接起来的节点。这样做原因是 hook 并不能简单的被创建然后丢弃。它们有一套特有的机制，也正是这些机制让它们成为 hook。一个 hook 会有数个属性，在继续学习之前，我希望你能牢记于心：</p> <ul><li>它的初始状态会在初次渲染的时候被创建。</li> <li>它的状态可以在运行时更新。</li> <li>React 可以在后续渲染中记住 hook 的状态。</li> <li>React 能根据调用顺序提供给你正确的状态。</li> <li>React 知道当前 hook 属于哪个 fiber。</li></ul> <p>hook 还有一些附加的属性，但是弄明白 hook 是如何运行的关键在于它的 <code>memoizedState</code> 和 <code>next</code> 属性。其他的属性会被 <code>useReducer()</code> hook 使用，可以缓存发送过的 action 和一些基本的状态，这样在某些情况下，reduction 过程还可以作为后备被重复一次：</p> <ul><li><code>baseState</code> —— 传递给 reducer 的状态对象。</li> <li><code>baseUpdate</code> —— 最近一次创建 <code>baseState</code> 的已发送的 action。</li> <li><code>queue</code> —— 已发送 action 组成的队列，等待传入 reducer。</li></ul> <h3 id="redux原理"><a href="#redux原理" class="header-anchor">#</a> redux原理</h3> <p>Redux是将整个应用状态存储到一个地方上称为<strong>store</strong>,里面保存着一个状态树<strong>store tree</strong>,组件可以派发(dispatch)行为(action)给store,而不是直接通知其他组件，组件内部通过订阅<strong>store</strong>中的状态<strong>state</strong>来刷新自己的视图。</p> <p>redux三大原则</p> <ul><li>1 唯一数据源</li> <li>2 保持只读状态</li> <li>3 数据改变只能通过纯函数来执行</li></ul> <p><code>react-redux</code>的核心机制是通知订阅模式，源码中有一个<code>Subscription</code>类，它的作用主要是订阅父级的更新和通知子级的更新，也就是它既可以订阅别人，别人也可以订阅它，同时可以通知订阅它的<code>Subscription</code></p> <p>最外层的<code>Provider</code>组件的<code>Context</code>里包含了的<code>store</code>（也就是我们传入的）和生成的<code>Subscription</code>实例，它的<code>Subscription</code>实例订阅的则是<code>redux</code> 的<code>subscrib()</code></p> <p>当我们使用了<code>connect()</code>时，它会生成一个新组件<code>&lt;Component1/&gt;</code>，<code>&lt;Component1/&gt;</code>里会生成一个<code>Subscription</code>实例，它会订阅父级（这时是<code>Provider</code>）的<code>Subscription</code>实例，同时将自己的<code>Subscription</code>覆盖进<code>Context</code>，再包装我们传入的组件</p> <p>如果在<code>&lt;Component1/&gt;</code>里的子组件又有<code>connect()</code>，那么生成的<code>&lt;Component2/&gt;</code>组件的<code>Subscription</code>实例会订阅父级<code>&lt;Component1/&gt;</code>的<code>Subscription</code>实例，同时再将自己的<code>Subscription</code>覆盖进<code>Context</code></p> <p>在组件挂载完成后，如果<code>store</code>有更新，<code>Provider</code>会通知下一级组件的<code>Subscription</code>，下一级组件又会通知自己的下一级组件</p> <p>在订阅的时候，会将更新自己组件的方法通过回调<code>onStateChange()</code>传入父级的<code>Subscription</code></p> <p>一旦父级接收到通知，就会循环调用订阅自己的组件的<code>onStateChange</code>来更新它们</p> <p>更新的原理就是使用我们传入的<code>mapStateToProps</code>和<code>mapDispatchToProps</code>，结合内置的<code>selectorFactor()</code>来对比<code>state</code>和<code>props</code>，一旦有改变就强制更新自己，所以我们传入的<code>WrappedComponent</code>也被强制更新了</p> <h3 id="redux-reducer"><a href="#redux-reducer" class="header-anchor">#</a> redux-reducer</h3> <p>reducer为什么要是纯函数？纯函数是什么？</p> <p>纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p> <p>原因：Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同（<strong>浅比较</strong>）。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。两个state相同的话，页面就不会重新渲染了。</p> <h3 id="redux中间件机制"><a href="#redux中间件机制" class="header-anchor">#</a> redux中间件机制</h3> <p><code>redux</code>源码只有<strong>同步</strong>操作，也就是当<code>dispatch action</code> 时，<code>state</code>会被立即更新。若需要引入异步数据流，<a href="https://cn.redux.js.org/docs/advanced/AsyncFlow.html" target="_blank" rel="noopener noreferrer">Redux官方<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>则建议使用中间件来增强<code>createStore</code>的能力，它对外暴露了<code>applyMiddleware</code>函数，接受任意个中间件作为入参，返回作为<code>createStore</code>的入参的值</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>// 引入 redux
import { createStore } from 'redux'
// 创建 store
const store = createStore(
    reducer,
    initial_state,
    //引入中间件
    applyMiddleware(middleware1, middleware2, ...)
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>以 <code>middlewareAPI</code> 作为中间件的入参，逐个调用传入的中间件，获取一个由“内层函数”组成的数组 <code>chain</code></p> <p>调用 <code>compose</code> 函数，将 <code>chain</code> 中的 “内层函数” 逐个组合起来，并调用最终组合出来的函数，传入 <code>dispatch</code> 作为入参</p> <p>返回一个新的 <code>store</code> 对象，这个 <code>store</code> 对象的 <code>dispatch</code> 已经被改写过了</p> <p><code>reduce</code> 会将数组中的每个元素执行指定的逻辑，并将结果汇总为单个返回值，假设有这样一个 <code>compose</code> 调用</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">compose</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span>f2<span class="token punctuation">,</span>f3<span class="token punctuation">,</span>f4<span class="token punctuation">)</span>
<span class="token comment">//会被解析为</span>
<span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token function">f4</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>即<code>f1,f2,f3,f4</code>这4个中间件的内层逻辑会被组合到一个函数中去，当这个函数被调用时，中间件会依次被调用</p> <p>中间件的执行机制</p> <p>我们知道 <strong>任何的中间件都可以用自己的方式解析<code>dispatch</code>的内容，并继续传递<code>actions</code> 给下一个中间件</strong>。但注意：当最后一个中间件开始 <code>dispatch action</code> 时，<code>action</code> 必须是一个普通对象，因为这是同步式的 <code>Redux</code> 数据流 开始的地方。</p> <p><code>redux-thunk</code>源码层面可知道，它主要做的一件事就是 拦截到<code>action</code>后，检查它是否是一个函数</p> <ul><li>若是函数，则执行它并返回执行的结果</li> <li>若不是函数，则直接调用<code>next</code>，工作流继续往下走</li></ul> <p>中间件的工作模式：</p> <ul><li>中间件的执行时机：在<code>action</code>被分发之后、<code>reducer</code>触发之前</li> <li>中间件的执行前提：<code>applyMiddleware</code>函数对<code>dispatch</code>函数进行改写，使得<code>dispatch</code>触发<code>reducer</code>之前，执行<code>Redux</code>中间件的链式调用。</li></ul> <h3 id="redux-compose实现"><a href="#redux-compose实现" class="header-anchor">#</a> Redux compose实现</h3> <p>compose就是执行一系列的任务（函数），比如有以下任务队列</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> tasks <span class="token operator">=</span> <span class="token punctuation">[</span>step1<span class="token punctuation">,</span> step2<span class="token punctuation">,</span> step3<span class="token punctuation">,</span> step4<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>每一个step都是一个步骤，按照步骤一步一步的执行到结尾，这就是一个<strong>compose</strong></p> <p>compose在函数式编程中是一个很重要的工具函数，在这里实现的compose有三点说明</p> <ul><li>第一个函数是多元的（接受多个参数），后面的函数都是单元的（接受一个参数）</li> <li>执行顺序的自右向左的</li> <li>所有函数的执行都是同步的</li></ul> <p>用代码解释</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>componse<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token keyword">function</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">add2</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">+</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>add1<span class="token punctuation">,</span>add2<span class="token punctuation">,</span>add3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
<span class="token comment">//输出结果 '12xy'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="利用context-api实现redux"><a href="#利用context-api实现redux" class="header-anchor">#</a> 利用context api实现redux</h3> <p>https://segmentfault.com/a/1190000023142285</p> <h3 id="react-router原理"><a href="#react-router原理" class="header-anchor">#</a> React-router原理</h3> <p><code>React-Router</code>中的3个核心角色：</p> <p>导航：负责触发路径的改变，比如 <code>Link</code>、<code>NavLink</code> 和 <code>Redirect</code>（以<code>Link</code>为代表）</p> <p>路由：负责定义路径与组件之间的映射关系，比如<code>Route</code>和<code>Switch</code>（以<code>Route</code>为代表）</p> <p>路由器：为新的路径匹配它对应的逻辑，比如<code>BrowserRouter</code>和<code>HashRouter</code>，根据<code>Route</code>定义出来的映射关系</p> <p>负责感知路由的变化并作出反应的路由器，是整个路由系统中最为重要的一环。在<code>React-Router</code>中支持两种路由规则：<code>HashRouter</code>和<code>BrowserRouter</code>分别对应了<code>hash</code>和<code>history</code>两种背后模式，</p> <p>在react-router源码中，HashRouter 调用 <code>createHashHistory</code>，History调用<code>createBrowserHistory</code></p> <p><code>createHashHistory</code>通过使用hash tag(#) 来处理形如<code>https://www.huamu.com/#index</code>的 URL，即通过 URL 的 hash 属性来控制路由跳转</p> <p><code>createBrowserHistory</code> 它将在浏览器中使用 HTML 5 的 history API 来处理形如 <code>https://www.huamu.com/index</code>的 URL，即通过 HTML 5的 history API 来控制路由跳转</p> <h3 id="手写自定义hook-实现切换状态"><a href="#手写自定义hook-实现切换状态" class="header-anchor">#</a> 手写自定义hook，实现切换状态</h3> <div class="language-react line-numbers-mode"><pre class="language-text"><code>function SomeComponent() {
  const [state, toggleState] = useToggle(false);
  return &lt;div&gt;
    {state ? 'true' : 'false'}
    &lt;button onClick={toggleState}&gt;&lt;/button&gt;
  &lt;/div&gt;
}

// 请实现 useToggle
function useToggle(initialValue) {
    const [value, setValue] = useState(initialValue);
    const toggle = () =&gt; {setValue(!value)};
    return [value, toggle];
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="react优化"><a href="#react优化" class="header-anchor">#</a> React优化</h2> <p>https://juejin.cn/post/6935584878071119885</p> <h3 id="懒渲染react-visibility-observer"><a href="#懒渲染react-visibility-observer" class="header-anchor">#</a> 懒渲染react-visibility-observer</h3> <p>当组件进入可视区域才渲染组件，如modal/drawer这种需要用户操作才会出现的组件。</p> <p>使用react-visibility-observer监听</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>import VisibilityObserver,{useVisibilityObserver,} from &quot;react-visibility-observer&quot;

const VisibilityObserverChildren = ({callback,children}) =&gt;{
  const {isVisible} = useVisibilityObserver()
  useEffect(()=&gt;{
    callback(isVisible)
  },[callback,isVisible])
  
  return &lt;&gt;{children}&lt;/&gt;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/8/2021, 10:45:23 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tech/react/react2.html" class="prev">
        React（二）
      </a></span> <span class="next"><a href="/tech/react/react4.html">
        React（四）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1640ad01.js" defer></script><script src="/assets/js/2.619c82a8.js" defer></script><script src="/assets/js/24.df814ef2.js" defer></script>
  </body>
</html>
