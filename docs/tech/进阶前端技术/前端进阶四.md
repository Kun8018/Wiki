---
title: 前端进阶三
date: 2020-12-13 21:40:33
categories: 个人生活
tags: 幸福，个人生活
toc: true
thumbnail: http://cdn.kunkunzhang.top/jenkins.png
---

　　前端进阶3，web api

<!--more-->

## 内网穿透

内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说映射端口，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。

内网穿透的应用场景：

- 内网穿透，可代替vpn
- 将无外网IP的desktop映射到公网
- 临时搭建网络并分配二级域名
- 微信二次开发的本地调试

方法1:localtunnel （使用国外网，非常慢，经常超时，不建议使用）

首先安装包

```shell
npm install -g localtunnel
```

在本地开启服务后，如服务在8080端口，运行命令开启服务

```shell
lt --subdomain mitu --port 8080
```

lt为localtunnel的缩写，mitu是指定域名前缀为mitu，8080为配置端口

常见错误：

（1）运行脚本命令错误：以管理员模式开启脚本权限

（2）invalid host header：在webpack的配置devServer下添加配置：disableHostCheck: true

方法二：natapp （国内网站）

方法三：ngrok

ngrok需要在服务端和客户端配置，客户端叫ngrokd，服务端叫ngrok



https://juejin.cn/post/6844903623659356168

https://aotu.io/notes/2016/02/19/ngrok/index.html

https://xicheng412.github.io/2016/09/27/ngrok-config/

## canvas api

`<canvas>`元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上`<canvas>`是一个可以用 JavaScript 操作的位图（bitmap）

它与 SVG 图像的区别在于，`<canvas>`是脚本调用各种方法生成图像，SVG 则是一个 XML 文件，通过各种子元素生成图像。

每个`<canvas>`元素都有一个对应的`CanvasRenderingContext2D`对象（上下文对象）。Canvas API 就定义在这个对象上面。

```html
<canvas id="myCanvas" width="400" height="250">
  您的浏览器不支持 Canvas
</canvas>
<script>
var canvas = document.getElementById('myCanvas');
var ctx = canvas.getContext('2d');
</script>
```

Canvas API 需要`getContext`方法指定参数`2d`，表示该`<canvas>`节点生成 2D 的平面图像。如果参数是`webgl`，就表示用于生成 3D 的立体图案，这部分属于 WebGL API。

方法：

绘制路径：

`ctx.beginPath()`:

`ctx.closePath()`:

`ctx.moveTo()`:

`ctx.lineTo()`:

`ctx.fill()`:

`ctx.stroke()`:

`ctx.fillStyle()`:

`ctx.strokeStyle`:

`ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);`:

`ctx.restore()`方法将画布的样式恢复到上一个保存的快照，如果没有已保存的快照，则不产生任何效果。

图像变换：

`ctx.rotate`:图像旋转

`ctx.scale`:图像缩放

`ctx.translate`:图像平移

`ctx.transform`:设置图像变换

`ctx.settransform`:取消前面的图像变换



## 业务场景代码

### 手写轮播图

轮播需要设置一个很长的DOM，设置超出容器隐藏，使用setInterval进行轮播，计算便宜位置。

DOM左端与右端交换的时候会有快速滑动，为了体验好一点，我会设置两层DOM，在容器之外的DOM进行DOM的左右交换。

```javascript
const position = [-8,-388,-768,-1148,-1528,-1908,-2208,-2668,-3048,-3428]
var certificate = document.getElementById("certificate-inner");

var i = 3;

function pre_pic(){
   if(i >= 1){
     if(isNaN(parseInt(certificate.style.marginLeft)) || parseInt(certificate.style.marginLeft) < -400)
         i--;
         var newLeft = position[i] + "px";
         $("#certificate-inner").animate({marginLeft:newLeft},500);
     else if (parseInt(certificate.style.marginLeft)> -400 || i >= 1){
         i++;
         var newLeft = position[i] + "px";
         $("#certificate-inner").animate({marginLeft:newLeft},500);
         setTimeout(function(){
            i = 6;
            certificate.style.marginLeft = "-2283px"
         },3985)
     }
   }else{
     i = 5;
     certificate.style.marginLeft = "-2283px";
     var newLeft = position[i] + "px"
     $("#certificate-inner").animate({marginLeft:newLeft},500);
   }
}

function next_pic(){
   if(i < 9){
     if(isNaN(parseInt(certificate.style.marginLeft))|| parseInt(certificate.style.marginLeft) > 374*8 || i > 0)			{
        i++;
        var newLeft = position[i] + "px"
        $("#certificate-inner").animate({marginLeft:newLeft},500)
     }
     else{
        i++;
        var newLeft = position[i] + "px"
        $("#certificate-inner").animate({marginLeft:newLeft},500)
        setTimeout(function(){
          i = 3;
          certificate.style.marginLeft = "-1143px"
        },3985)
     }
     newLeft = newLeft + "px"
     time = 0;
   }else{
     i = 4;
     certificate.style.marginLeft = "1143px";
     var newLeft = position[i] + "px"
     $("#certificate-inner").animate({marginLeft:newLeft},500)
   }
}

$(".left-coursol-icon").on("click",function(e){
  e.preventDefault();
  pre_pic();
})
$(".right-coursol-icon").on("click",function(e){
  e.preventDefault();
  next_pic();
})

var time = null;
function autoplay(){
  time = setInterval(function(){
    next_pic();
  },4000);
}
autoplay();
```



### 手写图片懒加载



### 手写Google搜索



### 前端添加水印





## 富文本编辑器





## 前端大容量缓存方案indexedDB

对于做3D WebGL 的开发者来说，加载大量的 hdr、glb、gltf 等文件往往是很令人头疼的，因为这些文件体积不小，在网络侧加载会消耗大量时间，从而影响用户体验。对于这些大文件，localstorage 和 sessionstorage 的缓存容量肯定是不够塞牙缝的。所以这时候我们要请出 IndexedDB。

IndexedDB 是一种可以让你在用户的浏览器内持久化存储数据的方法， 允许储存大量数据，提供查找接口，还能建立索引。 IndexedDB 的兼容性也还不错，基本上不兼容太老的浏览器，都还是可用的。

容量

chrome67设置了should remain available，这个值表示为浏览器本身需要留出来的空间，硬盘容量除去这个值以后的空间就是浏览器临时存储可用空间

大文件存储

IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象），所以我们可以把图片或者 3D 模型文件转化成 Blob 格式的文件，存在 IndexedDB 中，就可以解决免去二次加载时网络请求的时间。

IndexedDB 完全可以满足存储大体积文件的需求，并且 IndexedDB 可以 worker 中使用，包括 Web Worker 和 Service Worker，当 3D 需要进行复杂计算时，就可以利用 Service Worker 把一些数据存储在 IndexedDB 中或者通过 Web Worker 读取 IndexedDB 中的数据进行多线程计算。

需要注意的是 IndexedDB 也遵从同源协议([same-origin policy](http://www.w3.org/Security/wiki/Same_Origin_Policy))，所以你只能访问同域中存储的数据，而不能访问其他域的。

## 

## 性能监控



### 关键指标

首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间；首屏时间等于白屏时间+首屏渲染时间

白屏时间：是指从用户进入网站（输入url、刷新、跳转等方式）的时刻开始计算，一直到页面有内容展示出来的时间节点。这个过程包括dns查询、建立tcp连接、发送首个http请求（如果使用https还要介入TLS的验证时间）、返回html文档、html文档head解析完毕。

用户可操作时间节点：domready触发节点，点击事件有反应；

总下载时间：window.onload的触发节点。

### window.performance

Window.performance是用来测量网页和Web应用程序的性能api，performance中有以下字段用来衡量性能：

`memory字段`代表JavaScript对内存的占用。

`navigation字段`统计的是一些网页导航相关的数据：redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向；type 返回值应该是0,1,2 中的一个。分别对应三个枚举值: 0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式) 1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面) 2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面)

`timing字段`的统计数据，它包含了网络、解析等一系列的时间数据。具体包括：

DNS查询耗时 ：`domainLookupStart`和`domainLookupEnd`分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart；

TCP链接耗时：`connectStart`和`connectEnd`分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd；

request请求耗时：`responseStart`和`responseEnd`分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻；

解析dom树耗时:`domComplete`html文档完全解析完毕的时间节点减去`domInteractive`，代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点；

白屏时间：`domLoading`代表浏览器开始解析html文档的时间节点减去`fetchStart`是指在浏览器发起任何请求之前的时间值。

domready可操作时间 ：domContentLoadedEventEnd 代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间；- fetchStart

onload总下载时间 = loadEventEnd代表onload事件结束的时间节点-fetchStart；

### 实例方法

白屏时间

在html文档的head中所有的静态资源以及内嵌脚本/样式之前记录一个时间点，在head最底部记录另一个时间点，两者的差值作为白屏时间

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>白屏时间</title>
    <script>
        // 开始时间
        window.pageStartTime = Date.now();
    </script>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="">
    <script>
        // 白屏结束时间
        window.firstPaint = Date.now()
    </script>
</head>
<body>
    <div>123</div>
</body>
</html>

白屏时间 = firstPaint - pageStartTime
```

通常计算首屏的方法有

- 首屏模块标签标记法
- 统计首屏内加载最慢的图片的时间
- 自定义首屏内容计算法 

标签标记法

由于浏览器解析HTML是按照顺序解析的，当解析到某个元素的时候，觉得首屏完成了，就在此元素后面加入<script>计算首屏完成时间

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>首屏时间</title>
    <script>
        // 开始时间
        window.pageStartTime = Date.now();
    </script>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="">
</head>
<body>
    <div>123</div>
    <div>456</div>
    // 首屏可见内容
    <script>
        // 首屏结束时间
        window.firstPaint = Date.now();
    </script>
    // 首屏不可见内容
    <div class=" "></div>
</body>
</html>

首屏时间 = firstPaint - pageStartTime
```

**统计首屏内加载最慢的图片/iframe**（更常用）

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>首屏时间</title>
    <script>
        window.pageStartTime = Date.now()
    </script>
</head>
<body>
    <img src="https://lz5z.com/assets/img/google_atf.png" alt="img" onload="load()">
    <img src="https://lz5z.com/assets/img/css3_gpu_speedup.png" alt="img" onload="load()">
    <script>
        function load () {
            window.firstScreen = Date.now()
        }
        window.onload = function () {
            // 首屏时间
            console.log(window.firstScreen - window.pageStartTime)
        }
    </script>
</body>
</html>
```

缺点：使用场景受限

同样无法获取解析html文档之前的时间信息

这种方案比较适合首屏元素数量固定的页面，比如移动端首屏不论屏幕大小都展示相同数量的内容，响应式得改变内容的字体、尺寸等。

但是对于首屏元素不固定的页面，这种方案并不适用，最典型的就是PC端页面，不同屏幕尺寸下展示的首屏内容不同。上述方案便不适用于此场景。

可操作时间

用户可操作的时间节点即dom ready触发的时间，使用jquery可以通过$(document).ready()获取此数据。

```javascript
// 原生JS实现dom ready
window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
});
```

总下载时间

总下载时间即window.onload触发的时间节点。









## 自动化部署与负载均衡

### pm2

pm2是node进程管理工具，利用它进行node应用管理的性能监控、自动重启、负载均衡等。

全局安装

```shell
npm install -g pm2
```

使用pm2控制进程

```shell
pm2 start app.js  //启动进程
pm2 restart app.js   //重启进程
pm2 list   //获取当前应用等名字/进程id
pm2 stop app_name|app_id  //停止进程应用
pm2 delete app_name|app_id  //删除特定进程应用
pm2 stop all //停止所有应用
```

其他命令行参数

```shell
pm2 start app.js -i max //根据有效CPU数启动最大进程数目
pm2 start app.js -i 3 //启动3个进程
pm2 start app.js -n name //启动进程时指定进程名字name
pm2 start app.js --watch //监听应用目录的变化，一旦发生变化就自动重启
pm2 monit  //查看当前pm2的运行进程的状态
pm2 start big-array.js --max-memory-restart 20M  //超过内存上限后自动重启
```

配置启动环境

在node中指定启动环境（开发环境、生产环境等）

```javascript
"env":{
  "NODE_ENV":"production",
  "REMOTE_ADDR":"http://www.example.com/"
},
"env_dev":{
  "NODE_ENV":"development",
   "REMOTE_ADDR":"http://wdev.example.com/"
}
"env_test":{
  "NODE_ENV":"test",
  "REMOTE_ADDR":"http://wtest.example.com/"
}
```

启动时设置环境

```shell
pm2 start app.js --env dev
```

pm2支持线上系统和第三方扩展，如常用的log、rotate，



### jenkins

jenkins是基于java和docker的自动化部署和管理工具

安装之前确保电脑安装java(java 1.8)和docker

mac安装

使用brew工具安装和启动

```shell

```



## Sentry

sentry是一个开源的错误追踪工具，可以帮助开发人员实时监控和修复系统中的错误。其专注于错误监控以及提取一切事后处理所需的信息，支持几乎所有主流开发语言（JS/Java/Python/php）和平台，并提供了web来展示错误。

[sentry.io](https://sentry.io) [docs.sentry.io/platforms](https://docs.sentry.io/platforms/)



官方推荐使用docker或者python安装

在前端项目中使用

```shell
npm install @sentry/browser @sentry/integrations
```



```javascript
import * as Sentry from '@sentry/browser'
import * as Intergrations from '@sentry/integrations'

process.env.NODE_ENV === "production" && Sentry.init ({
  dsn: 'https://e028cb7b8dd645978cf5d84a@sentry.io/18726',
  integrations: [new Integrations.Vue{}],
})
```





## 前端测试

现如今大部分互联网团队都是走 **敏捷开发** 的节奏。实际上，自动化测试才是实现“敏捷”的基本保障。业务端的快速上线和快速验证对技术侧的响应力提出了更高的要求：**更快上线，持续上线**。再考虑到人员流动和应用逐步变大的事实，日后迭代的成本只会变得越来越高。当然这个项目迭代的成本也跟项目的复杂度有关，比如笔者所在的点餐业务，项目有足够的复杂性，有些细微的改动点其实会牵扯到很多内容，而对刚加入团队的新人就会显得不太友好。因此，项目拥有前端测试是必不可少的，它能够有效保障业务迭代的质量和稳定性。

我们经常说的单元测试其实只是前端测试的一种。前端测试分为单元测试，UI 测试，集成测试和端到端测试。

- 单元测试：是指对软件中的最小可测试单元进行检查和验证，通常指的是独立测试单个函数。
- UI 测试：是对图形交互界面的测试。
- 集成测试：就是测试应用中不同模块如何集成，如何一起工作，这和它的名字一致。
- 端到端测试（e2e）：是站在用户角度的测试，把我们的程序看成是一个黑盒子，我不懂你内部是怎么实现的，我只负责打开浏览器，把测试内容在页面上输入一遍，看是不是我想要得到的结果。

前端测试的框架可谓是百花齐放。

- 单元测试有 Mocha, Ava, Karma, Jest, Jasmine 等。
- UI 测试有 ReactTestUtils, Test Render, Enzyme, React-Testing-Library, Vue-Test-Utils 等。
- e2e 测试有 Nightwatch, Cypress, Phantomjs, Puppeteer 等。

单元测试

https://kerminate.me/2019/12/22/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#more

## highchart



## bulma



##  Tailwind

