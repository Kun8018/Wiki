---
title: 前端进阶（二）-前端工程化
date: 2020-12-15 21:40:33
categories: IT
tags: IT，Web,数据库
toc: true
thumbnail: http://cdn.kunkunzhang.top/webpack.png
---

　　前端的基础是html、css和JavaScript，掌握这些能够实现基本的功能和整齐的样式。掌握vue或者react框架能够快速实现spa应用。

​       对于进阶，掌握基本原理和一些动画方面的库能够更美观的进行展现，实现更炫酷的动画效果。

<!--more-->

## js底层原理

### js执行过程

JavaScript是一种解释型语言，执行时按照解释器-编译器-执行的顺序进行。

解释器：

JavaScript的解释器包含在即时编译器(JIT，just in time)中，在一句一句编译源代码的同时又会将编译后的一些代码保存下来。

即时编译器中首先有监视器监控着代码的运行状况。如果一段代码运行了几次，那么这段代码就会被标记为warm代码，标记为warm的代码会被编译器送到基线编译器编译，同时把结果缓存起来，如果一个函数被基线编译器编译，那么函数的每一行都会被编译成一个表，这个表的索引是行号和变量类型，如果监视器发现有代码使用相同的变量类型命中这段代码时，JIT会直接提取这段代码编译后的内容。

如果标记为warm的代码还在不断被调用，那么它会被标记为hot，标记为hot的代码，意味着可能会被经常调用，所以可能需要更多时间优化编译结果。监视器会把该段代码送到优化编译器，编译成一个高效的版本并存储下来。

编译：

parse阶段-

词法分析和语法分析：词法分析是把需要执行的代码字符串分割出来，生成一系列token，便于做语法分析

语法分析分析上述输出，输出AST抽象语法树，如果分析发现异常则抛出错误。

Ignition：Ignition是v8的解释器，它会根据抽象语法树生成对应的字节码并执行。

所谓字节码，就是机器码的抽象，机器码虽然运行效率最高，但是占用空间较大，导致十分占内存，所以以时间换空间，引入字节码

Turbofan：Turbofan能够把字节码翻译成机器码，当发现hot代码时，turbofan会把字节码翻译成机器码，然后调用生成的机器码。如果发现假设失效，则退回字节码

Orinoco：Orinoco是v8的垃圾回收模块

执行：

执行阶段有执行上下文和执行栈两个概念

执行上下文就是JavaScript的运行环境，通常有

全局执行上下文，即window对象

函数执行上下文，即函数执行的时候被创建，每次调用函数就会创建一个新的执行上下文

eval执行上下文

对于每个执行上下文创建时，都有三个比较重要的属性：

变量对象：表示执行上下文的数据作用域，

作用域链

确定this指向：

执行栈：

js通过执行栈管理多个执行上下文，执行栈最底端是全局上下文，全局上下文中执行函数的时候，相应上下文会入栈，其中不断调用函数，不同的函数不断创建不同的执行上下文，直到函数执行完毕，上下文出栈，即后进先出

如果有异步函数，在执行栈的空的时候查看任务队列，微任务优先入栈。

### AST的应用

Es-lint就是使用ast查询器查询AST，AST选择器类似CSS选择器，每个ESlint规则都是通过选择器操作的

Babel:Babel对于一段代码的工作流程是：

1.输入代码 2.词法分析，将代码分成token 3.语法分析：把token转换成AST

4.遍历AST 5.改变AST，增删改查。 6.AST转换为源代码

webpack：webpack主要通过遍历AST分析出模块的依赖、消除无用代码等

## Gulp

Gulp基于Node.js的前端构建工具，通过Gulp的插件可以实现前端代码的编译（sass、less）、压缩、测试；图片的压缩；浏览器自动刷新，还有许多强大的插件可以在[这里](https://gulpjs.com/plugins/)查找。

安装

```shell
 npm install gulp -g
```

### Gulp Api

使用gulp，仅需知道4个API即可：`gulp.task()`,`gulp.src()`,`gulp.dest()`,`gulp.watch()`

`gulp.src()`方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流([Vinyl files](https://github.com/wearefractal/vinyl-fs))，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息

`gulp.dest()`方法是用来写文件的，其语法为：

gulp的使用流程一般是这样子的：首先通过`gulp.src()`方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到`gulp.dest()`中，`gulp.dest()`方法则把流中的内容写入到文件中，

`gulp.task`方法用来定义任务，内部使用的是[Orchestrator](https://github.com/robrich/orchestrator)，其语法为：

`gulp.watch()`用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为

### 常用插件

安装gulp插件

CSS

- sass的编译（[gulp-ruby-sass](https://github.com/sindresorhus/gulp-ruby-sass)）
- less的编译（[gulp-less](https://www.npmjs.com/packages/gulp-less)）
- 自动添加css前缀（[gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer)）
- 压缩css（[gulp-minify-css](https://github.com/jonathanepollack/gulp-minify-css)）

js

- js代码校验（[gulp-jshint](https://github.com/spenceralger/gulp-jshint)）
- 合并js文件（[gulp-concat](https://github.com/wearefractal/gulp-concat)）
- 压缩js代码（[gulp-uglify](https://github.com/terinjokes/gulp-uglify)）

html

- 压缩html([gulp-minify-html](https://www.npmjs.com/packages/gulp-minify-html))

图片、资源

- 压缩图片（[gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)）
- 图片缓存，只有图片替换了才压缩（[gulp-cache](https://github.com/jgable/gulp-cache)）

其他

- 自动加载插件([gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins))
- 自动刷新页面（[gulp-livereload](https://github.com/vohof/gulp-livereload)）
- 更改提醒（[gulp-notify](https://github.com/mikaelbr/gulp-notify)）
- 重命名（[gulp-rename](https://www.npmjs.com/packages/gulp-rename)）
- 清除文件（[del](https://www.npmjs.org/package/del)）

安装这些插件

```shell
npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev
```

创建一个gulpfile.js在根目录下，然后在里面加载插件：

```javascript
var gulp = require('gulp'),
    sass = require('gulp-ruby-sass'),
    autoprefixer = require('gulp-autoprefixer'),
    minifycss = require('gulp-minify-css'),
    jshint = require('gulp-jshint'),
    uglify = require('gulp-uglify'),
    imagemin = require('gulp-imagemin'),
    rename = require('gulp-rename'),
    concat = require('gulp-concat'),
    notify = require('gulp-notify'),
    cache = require('gulp-cache'),
    livereload = require('gulp-livereload'),
    del = require('del');
```

创建任务

```javascript
// Load plugins
var gulp = require('gulp'),
    sass = require('gulp-ruby-sass'),
    autoprefixer = require('gulp-autoprefixer'),
    minifycss = require('gulp-minify-css'),
    jshint = require('gulp-jshint'),
    uglify = require('gulp-uglify'),
    imagemin = require('gulp-imagemin'),
    rename = require('gulp-rename'),
    concat = require('gulp-concat'),
    notify = require('gulp-notify'),
    cache = require('gulp-cache'),
    livereload = require('gulp-livereload'),
    del = require('del');
// Styles，编译sass，添加前缀，保存到我们指定的目录下面，还没结束，我们还要压缩，给文件添加.min后缀再输出压缩文件到指定目录，最后提醒任务完成了
gulp.task('styles', function() {
  return gulp.src('src/styles/main.scss')
    .pipe(sass({ style: 'expanded', }))
    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))
    .pipe(gulp.dest('dist/styles'))
    .pipe(rename({ suffix: '.min' }))
    .pipe(minifycss())
    .pipe(gulp.dest('dist/styles'))
    .pipe(notify({ message: 'Styles task complete' }));
});
// Scripts，js代码校验、合并和压缩
gulp.task('scripts', function() {
  return gulp.src('src/scripts/**/*.js')
    .pipe(jshint('.jshintrc'))
    .pipe(jshint.reporter('default'))
    .pipe(concat('main.js'))
    .pipe(gulp.dest('dist/scripts'))
    .pipe(rename({ suffix: '.min' }))
    .pipe(uglify())
    .pipe(gulp.dest('dist/scripts'))
    .pipe(notify({ message: 'Scripts task complete' }));
});
// Images，使用imagemin插件把所有在src/images/目录以及其子目录下的所有图片（文件）进行压缩，我们可以进一步优化，利用缓存保存已经压缩过的图片
gulp.task('images', function() {
  return gulp.src('src/images/**/*')
    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))
    .pipe(gulp.dest('dist/images'))
    .pipe(notify({ message: 'Images task complete' }));
});
// Clean，在任务执行前，最好先清除之前生成的文件
gulp.task('clean', function(cb) {
    del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img'], cb)
});
// Default task设置默认任务，在命令行下输入$ gulp执行的就是默认任务，现在我们为默认任务指定执行上面写好的三个任务：
gulp.task('default', ['clean'], function() {
    gulp.start('styles', 'scripts', 'images');
});
// Watch，实现当文件修改时自动刷新页面，我们要修改watch任务，配置LiveReload：
gulp.task('watch', function() {
  // Watch .scss files
  gulp.watch('src/styles/**/*.scss', ['styles']);
  // Watch .js files
  gulp.watch('src/scripts/**/*.js', ['scripts']);
  // Watch image files
  gulp.watch('src/images/**/*', ['images']);
  // Create LiveReload server
  livereload.listen();
  // Watch any files in dist/, reload on change
  gulp.watch(['dist/**']).on('change', livereload.changed);
});
```

### 其他插件

打包前拷贝到dist目录，之后所有的操作基于dist目录

```javascript 
const { series, src, dest } = require('gulp');
const clean = require('gulp-clean');
//清除文件夹插件
function clear() {
	return src('dist',{ allowEmpty: true }).pipe(clean());
}
//拷贝静态资源
function assets() {
  return src('src/assets/**/*.*').pipe(dest('dist/assets/'));
}
//拷贝css文件
function css() {
  return src(['src/css/**/*.css']).pipe(dest('dist/css'));
}
//拷贝js文件
function js() {
  return src(['src/js/**/*.js']).pipe(dest('dist/js'))
}
//拷贝html文件
function html() {
  return src('src/views/**/*.html').pipe(dest('dist/views'))
}

exports.build = series(
	clear,
  assets,
  css,
  js,
  html
)
```

给打包文件加hash

```shell
npm i gulp-dev -D
```

在gulpfile。js中添加以下代码

```javascript
const rev = require('gulp-rev');
//给css文件加入hash
function cssRevHash() {
  return src('dist/css/**/*.css')
  	.pipe(rev())
  	.pipe(dest('/dist/css'))
  	.pipe(rev.manifest())
  	.pipe(dev('rev/css'));
}
//给js文件加入hash
function jsRevHash() {
  return src('dist/js/**/*.js')
  	.pipe(rev())
  	.pipe(dest('dist/js/'))
  	.pipe(rev.manifest())
  	.pipe(dev('rev/js'));
}

export.build = series(
		...
  	cssRevHash,
  	jsRevHash
)
```

替换文件中的源文件

```javascript
npm i gulp-rev-collector -D
```

在gulpfilejs中加入代码

```javascript
const revCollector = require('gulp-rev-collector');

function htmlRevInject() {
  return src([`rev/${revDir}/**/*.json`,'dist/views/**/*.html'])
  	.pipe(revCollector({ replaceReved: true}))
  	.pipe(dest('dist/views'));
}

exports.build = series(
	...
  htmlRevInject
)
```

打包zip文件

```shell
npm i gulp-zip -D
```

在gulpfilejs中加入代码

```javascript
const zip = require('gulp-zip')

function zipiupiu() {
  return src('dist/**/*').pipe(zip(zipName)).pipe(dest('dist'));
}

exports.build = series(
	...
  zipiupiu
)
```

动态处理打包环境，有prod和dev两种

```shell
npm i cross-env -D
```

在packagejson中添加命令

```json
{
  "scripts": {
		"build:env": "cross-env NODE_ENV=development gulp build",
    "build:prod": "cross-env NODE_ENV=production gulp build"
  };
}
```

根据不同环境执行不同的打包方式，如开发环境不需要压缩。

```javascript
if (process.env.NODE_ENV === 'production') {
	exports.build = series (
  	clear,
    assets,
    css,
    js,
    html,
    cssRevHash,
    jsRevHash,
    htmlRevInject,
    htmlMinify,
    zipiupiu
  )
}else {
  exports.build = series (
  	clear,
    assets,
    css,
    js,
    html,
    cssRevHash,
    jsRevHash,
    htmlRevInject,
    zipiupiu
  )
}
```



### gulp与webpack、grant的区别

与webpack

gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。

webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。

gulp应该与grunt比较，而webpack应该与browserify

gulp与webpack上是互补的，还是可替换的，取决于你项目的需求。如果只是个vue或react的单页应用，webpack也就够用；如果webpack某些功能使用起来麻烦甚至没有（雪碧图就没有），那就可以结合gulp一起用。

与grunt

Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务...就这样反复下去。而在Gulp中，使用的是Nodejs中的[stream](http://nodejs.org/api/stream.html)(流)，首先获取到需要的stream，然后可以通过stream的`pipe()`方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因。

https://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/

https://www.cnblogs.com/2050/p/4198792.html



## Rollup

应用场景:
   项目（特别是类库）只有 js，而没有其他的静态资源文件，使用 webpack 就有点大才小用了，因为 webpack bundle 文件的体积略大，运行略慢，可读性略低。这时候 [rollup](https://github.com/rollup/rollup)就是一种不错的解决方案

### Rollup 的好处

- Tree Shaking: 自动移除未使用的代码, 输出更小的文件
- Scope Hoisting: 所有模块构建在一个函数内, 执行效率更高
- Config 文件支持通过 ESM 模块格式书写
- 可以一次输出多种格式:IIFE, AMD, CJS, UMD, ESM
- Development 与 production 版本: .js, .min.js
- 文档精简

### 基础插件

- rollup-plugin-alias: 提供 modules 名称的 alias 和 reslove 功能.
- rollup-plugin-babel: 提供 Babel 能力, 需要安装和配置 Babel (这部分知识不在本文涉及)
- rollup-plugin-eslint: 提供 ESLint 能力, 需要安装和配置 ESLint (这部分知识不在本文涉及)
- rollup-plugin-node-resolve: 解析 node_modules 中的模块
- rollup-plugin-commonjs: 转换 CJS -> ESM, 通常配合上面一个插件使用
- rollup-plugin-replace: 类比 Webpack 的 DefinePlugin , 可在源码中通过 process.env.NODE_ENV 用于构建区分 Development 与 Production 环境.
- rollup-plugin-filesize: 显示 bundle 文件大小
- rollup-plugin-uglify: 压缩 bundle 文件
- rollup-plugin-serve: 类比 webpack-dev-server, 提供静态服务器能力



## Grunt



安装cli工具

```shell
npm install -g grunt-cli
```

安装grunt及用到的插件

```shell
npm install gulp grunt-contrib-uglify --save-dev
```

创建`Gruntfile.js`文件

```javascript
module.exports = function(grunt) {
    // Project configuration.
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        uglify: {
            options: {
                banner: '/*! <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> */\n'
            },
            build: {
                src: 'src/*.js',
                dest: 'build/all.min.js'
            }
        }
    });
    // 加载包含 "uglify" 任务的插件。
    grunt.loadNpmTasks('grunt-contrib-uglify');
    // 默认被执行的任务列表。
    grunt.registerTask('default', ['uglify']);
};
```

大部分的Gruntfile.js都非常臃肿，有一大段一大段的嵌套配置结构，令人看起来很烦躁。这些冗余的`Gruntfile.js`文件其实维护起来并不是那么轻量的，主要体现在下面几个方面，

1. 配置和运行分离
2. 大部分插件的职责不单一，做了不仅一件事
3. 配置项过多，做的事情越多，配置增长的就越快，且越不可控制
4. 任务执行中会产生一些临时文件，较频繁的IO操作导致性能滞后

我们再来看看gulp中是如何解决这些问题的，

1. gulp遵循**code over configuration**的原则，直接就在调用的地方配置
2. gulp的插件严格遵循单一职责原则，一个插件仅作一件事，一个gulp一般只有20多行代码就搞定
3. gulp基于流的思想，并没有过多的配置，任务更多的像是在写代码而不是定义配置
4. 这个是grunt的致命伤，gulp的流式构建改变了底层的流程控制，不再频繁的去进行IO操作了

## Parcel





## ESbuild

esbuild是新一代的Javascript打包工具。

esbuild以速度快著称，耗时只有webpack的2%到3%。很多工具都内置了esbuild，比如vite和snowpack

esbuild快的原因：

1.使用Go语言编写，可以编译为原生代码

2.解析、打印和源映射完全并行化

3.无须昂贵的数据转换，只需很少的几步完成

目前支持：

commonjs模块、es6模块

使用--bundle与es6模块的静态绑定打包

使用--minify完全压缩（空格、标识符和修饰符）

使用--sourcemap完全支持源映射

支持jsx转向js

使用--define进行编译时标识符替换

使用package.json中的browser字段进行替换

自动监测tsconfig中的baseUrl



### Vite



### snowpack





## WebRTC





## webpack学习资源

wepack：https://www.kancloud.cn/sllyli/webpack/1242354











​                   


