---
title: 前端进阶（一）
date: 2020-12-15 21:40:33
categories: IT
tags: IT，Web,数据库
toc: true
thumbnail: http://cdn.kunkunzhang.top/webpack.png
---

　　前端的基础是html、css和JavaScript，掌握这些能够实现基本的功能和整齐的样式。掌握vue或者react框架能够快速实现spa应用。

​       对于进阶，掌握基本原理和一些动画方面的库能够更美观的进行展现，实现更炫酷的动画效果。

<!--more-->

## Gulp

Gulp基于Node.js的前端构建工具，通过Gulp的插件可以实现前端代码的编译（sass、less）、压缩、测试；图片的压缩；浏览器自动刷新，还有许多强大的插件可以在[这里](https://gulpjs.com/plugins/)查找。

安装

```shell
 npm install gulp -g
```

### Gulp Api

使用gulp，仅需知道4个API即可：`gulp.task()`,`gulp.src()`,`gulp.dest()`,`gulp.watch()`

`gulp.src()`方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流([Vinyl files](https://github.com/wearefractal/vinyl-fs))，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息

`gulp.dest()`方法是用来写文件的，其语法为：

gulp的使用流程一般是这样子的：首先通过`gulp.src()`方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到`gulp.dest()`中，`gulp.dest()`方法则把流中的内容写入到文件中，

`gulp.task`方法用来定义任务，内部使用的是[Orchestrator](https://github.com/robrich/orchestrator)，其语法为：

`gulp.watch()`用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为

### 常用插件

安装gulp插件

CSS

- sass的编译（[gulp-ruby-sass](https://github.com/sindresorhus/gulp-ruby-sass)）
- less的编译（[gulp-less](https://www.npmjs.com/packages/gulp-less)）
- 自动添加css前缀（[gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer)）
- 压缩css（[gulp-minify-css](https://github.com/jonathanepollack/gulp-minify-css)）

js

- js代码校验（[gulp-jshint](https://github.com/spenceralger/gulp-jshint)）
- 合并js文件（[gulp-concat](https://github.com/wearefractal/gulp-concat)）
- 压缩js代码（[gulp-uglify](https://github.com/terinjokes/gulp-uglify)）

html

- 压缩html([gulp-minify-html](https://www.npmjs.com/packages/gulp-minify-html))

图片、资源

- 压缩图片（[gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)）
- 图片缓存，只有图片替换了才压缩（[gulp-cache](https://github.com/jgable/gulp-cache)）

其他

- 自动加载插件([gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins))
- 自动刷新页面（[gulp-livereload](https://github.com/vohof/gulp-livereload)）
- 更改提醒（[gulp-notify](https://github.com/mikaelbr/gulp-notify)）
- 重命名（[gulp-rename](https://www.npmjs.com/packages/gulp-rename)）
- 清除文件（[del](https://www.npmjs.org/package/del)）

安装这些插件

```shell
npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev
```

创建一个gulpfile.js在根目录下，然后在里面加载插件：

```javascript
var gulp = require('gulp'),
    sass = require('gulp-ruby-sass'),
    autoprefixer = require('gulp-autoprefixer'),
    minifycss = require('gulp-minify-css'),
    jshint = require('gulp-jshint'),
    uglify = require('gulp-uglify'),
    imagemin = require('gulp-imagemin'),
    rename = require('gulp-rename'),
    concat = require('gulp-concat'),
    notify = require('gulp-notify'),
    cache = require('gulp-cache'),
    livereload = require('gulp-livereload'),
    del = require('del');
```

创建任务

```javascript
// Load plugins
var gulp = require('gulp'),
    sass = require('gulp-ruby-sass'),
    autoprefixer = require('gulp-autoprefixer'),
    minifycss = require('gulp-minify-css'),
    jshint = require('gulp-jshint'),
    uglify = require('gulp-uglify'),
    imagemin = require('gulp-imagemin'),
    rename = require('gulp-rename'),
    concat = require('gulp-concat'),
    notify = require('gulp-notify'),
    cache = require('gulp-cache'),
    livereload = require('gulp-livereload'),
    del = require('del');
// Styles，编译sass，添加前缀，保存到我们指定的目录下面，还没结束，我们还要压缩，给文件添加.min后缀再输出压缩文件到指定目录，最后提醒任务完成了
gulp.task('styles', function() {
  return gulp.src('src/styles/main.scss')
    .pipe(sass({ style: 'expanded', }))
    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))
    .pipe(gulp.dest('dist/styles'))
    .pipe(rename({ suffix: '.min' }))
    .pipe(minifycss())
    .pipe(gulp.dest('dist/styles'))
    .pipe(notify({ message: 'Styles task complete' }));
});
// Scripts，js代码校验、合并和压缩
gulp.task('scripts', function() {
  return gulp.src('src/scripts/**/*.js')
    .pipe(jshint('.jshintrc'))
    .pipe(jshint.reporter('default'))
    .pipe(concat('main.js'))
    .pipe(gulp.dest('dist/scripts'))
    .pipe(rename({ suffix: '.min' }))
    .pipe(uglify())
    .pipe(gulp.dest('dist/scripts'))
    .pipe(notify({ message: 'Scripts task complete' }));
});
// Images，使用imagemin插件把所有在src/images/目录以及其子目录下的所有图片（文件）进行压缩，我们可以进一步优化，利用缓存保存已经压缩过的图片
gulp.task('images', function() {
  return gulp.src('src/images/**/*')
    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))
    .pipe(gulp.dest('dist/images'))
    .pipe(notify({ message: 'Images task complete' }));
});
// Clean，在任务执行前，最好先清除之前生成的文件
gulp.task('clean', function(cb) {
    del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img'], cb)
});
// Default task设置默认任务，在命令行下输入$ gulp执行的就是默认任务，现在我们为默认任务指定执行上面写好的三个任务：
gulp.task('default', ['clean'], function() {
    gulp.start('styles', 'scripts', 'images');
});
// Watch，实现当文件修改时自动刷新页面，我们要修改watch任务，配置LiveReload：
gulp.task('watch', function() {
  // Watch .scss files
  gulp.watch('src/styles/**/*.scss', ['styles']);
  // Watch .js files
  gulp.watch('src/scripts/**/*.js', ['scripts']);
  // Watch image files
  gulp.watch('src/images/**/*', ['images']);
  // Create LiveReload server
  livereload.listen();
  // Watch any files in dist/, reload on change
  gulp.watch(['dist/**']).on('change', livereload.changed);
});
```

### gulp与webpack、grant的区别

与webpack

gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。

webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。

gulp应该与grunt比较，而webpack应该与browserify

gulp与webpack上是互补的，还是可替换的，取决于你项目的需求。如果只是个vue或react的单页应用，webpack也就够用；如果webpack某些功能使用起来麻烦甚至没有（雪碧图就没有），那就可以结合gulp一起用。

与grunt

Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务...就这样反复下去。而在Gulp中，使用的是Nodejs中的[stream](http://nodejs.org/api/stream.html)(流)，首先获取到需要的stream，然后可以通过stream的`pipe()`方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因。

https://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/

https://www.cnblogs.com/2050/p/4198792.html



## Rollup

应用场景:
   项目（特别是类库）只有 js，而没有其他的静态资源文件，使用 webpack 就有点大才小用了，因为 webpack bundle 文件的体积略大，运行略慢，可读性略低。这时候 [rollup](https://github.com/rollup/rollup)就是一种不错的解决方案

### Rollup 的好处

- Tree Shaking: 自动移除未使用的代码, 输出更小的文件
- Scope Hoisting: 所有模块构建在一个函数内, 执行效率更高
- Config 文件支持通过 ESM 模块格式书写
- 可以一次输出多种格式:IIFE, AMD, CJS, UMD, ESM
- Development 与 production 版本: .js, .min.js
- 文档精简

### 基础插件

- rollup-plugin-alias: 提供 modules 名称的 alias 和 reslove 功能.
- rollup-plugin-babel: 提供 Babel 能力, 需要安装和配置 Babel (这部分知识不在本文涉及)
- rollup-plugin-eslint: 提供 ESLint 能力, 需要安装和配置 ESLint (这部分知识不在本文涉及)
- rollup-plugin-node-resolve: 解析 node_modules 中的模块
- rollup-plugin-commonjs: 转换 CJS -> ESM, 通常配合上面一个插件使用
- rollup-plugin-replace: 类比 Webpack 的 DefinePlugin , 可在源码中通过 process.env.NODE_ENV 用于构建区分 Development 与 Production 环境.
- rollup-plugin-filesize: 显示 bundle 文件大小
- rollup-plugin-uglify: 压缩 bundle 文件
- rollup-plugin-serve: 类比 webpack-dev-server, 提供静态服务器能力

## Parcel





## ESbuild

esbuild是新一代的Javascript打包工具。

esbuild以速度快著称，耗时只有webpack的2%到3%。很多工具都内置了esbuild，比如vite和snowpack

esbuild快的原因：

1.使用Go语言编写，可以编译为原生代码

2.解析、打印和源映射完全并行化

3.无须昂贵的数据转换，只需很少的几步完成

目前支持：

commonjs模块、es6模块

使用--bundle与es6模块的静态绑定打包

使用--minify完全压缩（空格、标识符和修饰符）

使用--sourcemap完全支持源映射

支持jsx转向js

使用--define进行编译时标识符替换

使用package.json中的browser字段进行替换

自动监测tsconfig中的baseUrl



### Vite



### snowpack







## WebRTC





## webpack学习资源

wepack：https://www.kancloud.cn/sllyli/webpack/1242354











​                   


