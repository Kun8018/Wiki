(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{348:function(t,e,n){"use strict";n.r(e);var a=n(14),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("​      前端框架，快速开发页面，函数式编程，与后端api快速搭建")]),t._v(" "),n("h2",{attrs:{id:"purecomponent"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent"}},[t._v("#")]),t._v(" purecomponent")]),t._v(" "),n("p",[t._v("当使用component时，父组件的props或者state更新时，无论子组件的state、props是否更新，都会触发子组件的更新，这会造成很多没必要的render，浪费很多性能。pureComponent的优点在于，在shouldcomponentUpdate只进行浅层比较，只要外层对象没有变化，就不会触发render，也就是不需要开发者使用shouldComponentUpdate就可使用简单的判断来提升性能")]),t._v(" "),n("p",[t._v("缺点：")]),t._v(" "),n("p",[t._v("由于进行的时浅比较，可能由于深层的数据不一致导致产生错误的否定判断，从而导致页面得不到更新")]),t._v(" "),n("p",[t._v("不适合用于在含有多层嵌套对象的state和props中，一般是作为展示组件来使用。因为对于数组和对象等引用类型，需要引用不同才会渲染")]),t._v(" "),n("p",[t._v("尤其是当遇到复杂组件时，可以将一个组件拆分成多个pureComponent，以这种方式来实现复杂数据结构，以期达到节省不必要渲染的目的，如表单、复杂列表、文本域等")]),t._v(" "),n("p",[t._v("如果props和state每次都会变，建议使用Component")]),t._v(" "),n("p",[t._v("父组件是pureComponent时，子组件无论是purecomponent或者component都不影响，因为父组件不会重新渲染，")]),t._v(" "),n("p",[t._v("父组件是Component时，子组件是component时每次都会重新渲染，子组件是purecomponent时，props不变时不会重新渲染")]),t._v(" "),n("h3",{attrs:{id:"与react-memo、usememo的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#与react-memo、usememo的区别"}},[t._v("#")]),t._v(" 与React.memo、usememo的区别")]),t._v(" "),n("p",[t._v("reacr.memo控制函数组件的重新渲染，reacr.purecomponent控制类组件的重新渲染")]),t._v(" "),n("p",[t._v("使用时将函数组件传递给react.memo函数就可以")]),t._v(" "),n("p",[t._v("实例")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const Funcomponent = () =>{\n  return (\n     <div>\n     hiya!i am a functional component!\n     </div>\n  )\n}\nconst MemoFuncComponent = React.memo(Funcomponent)\n")])])]),n("p",[t._v("React.memo返回英国纯组件MemoFuncComponent，jsx中将标记次组件，每当组件的props和state发生变化时，react会检查上一个props和state与下一个pros和state是否相等，不相等重新渲染，相等则不会重新渲染")]),t._v(" "),n("p",[t._v("React.memo可以传递第二个参数，自定义比较函数，返回false时更新")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function MyComponent(props) {\n  /* render using props */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  return true if passing nextProps to render would return\n  the same result as passing prevProps to render,\n  otherwise return false\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n")])])]),n("p",[t._v("类组件中即成purecomponent实现")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React from 'react'\nclass TestC extends React.PureComponent{\n   constructor(props){\n     super(props);\n     this.state = {\n       conut: 0\n     }\n   }\n  \n  render(){\n    return(\n      <div>\n        {this.state.count}\n        <button onClick={()=>this.setState({count:1})}>\n          click me\n        </button>\n      </div>\n    )\n  }\n}\n")])])]),n("h3",{attrs:{id:"prop使用嵌套对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prop使用嵌套对象"}},[t._v("#")]),t._v(" prop使用嵌套对象")]),t._v(" "),n("p",[t._v("使用immutable属性。")]),t._v(" "),n("h2",{attrs:{id:"hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hook"}},[t._v("#")]),t._v(" Hook")]),t._v(" "),n("p",[t._v("Https://juejin.cn/post/6844903985338400782")]),t._v(" "),n("p",[t._v("Hook是react16.8新增的特性，可以在不编写class 的情况下使用state和其他react特性，reactnative从0.59版本开始支持hook。")]),t._v(" "),n("h3",{attrs:{id:"hook出现的原因以及解决的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hook出现的原因以及解决的问题"}},[t._v("#")]),t._v(" hook出现的原因以及解决的问题")]),t._v(" "),n("p",[t._v("Class component 劣势")]),t._v(" "),n("ol",[n("li",[t._v("状态逻辑难复用：在组件之间复用状态逻辑很难，可能要用到 render props （渲染属性）或者 HOC（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），这样高阶组件多了会形成回调地狱类似的问题，导致层级冗余 趋向复杂难以维护：")]),t._v(" "),n("li",[t._v("在生命周期函数中混杂不相干的逻辑（如：在 componentDidMount 中注册事件以及其他的逻辑，在 componentWillUnmount 中卸载事件，这样分散不集中的写法，很容易写出 bug ） 类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件")]),t._v(" "),n("li",[t._v("this 指向问题：父组件给子组件传递函数时，必须绑定 this")])]),t._v(" "),n("p",[t._v("Hooks不能在class中使用，只能在函数组件中，为函数组件勾入react state及生命周期等函数")]),t._v(" "),n("p",[t._v("react内置的hook有以下")]),t._v(" "),n("p",[t._v("基础hook：useState、useEffect、useContext")]),t._v(" "),n("p",[t._v("额外的hook：useReducer、useCallback、useMemo、useRef、useLayoutEffect、useDebugValue、useImperativeHandle")]),t._v(" "),n("h3",{attrs:{id:"函数式组件与class组件对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数式组件与class组件对比"}},[t._v("#")]),t._v(" 函数式组件与class组件对比")]),t._v(" "),n("h4",{attrs:{id:"性能对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能对比"}},[t._v("#")]),t._v(" 性能对比")]),t._v(" "),n("p",[t._v("class组件中，setState之后要对比整个虚拟dom的状态。对于一个复杂页面，几十个状态要对比消耗性能。而hook阶段只对比一个值即可，性能更佳")]),t._v(" "),n("p",[t._v("闭包很多，值捕获现象严重，要尤其注意hook的依赖")]),t._v(" "),n("p",[t._v("大量的内联函数、函数嵌套，垃圾回收压力大。函数式组件每次渲染就像调用纯函数一样，调用之后产生一个作用域，并开辟对应的内容空间存储该作用域下的变量，函数返回结束后该作用域会被销毁，该作用域下的变量如果没有被作用域外的东西引用，在作用域销毁之后就需要在下一次GC时被回收。因此相对于Class组件额外的开销会多很多。因为Class组件所有的东西都是承载在一个对象上的，都是在这个对象上，每次更新组件，这个对象上的属性、方法和对象本身都不会被销毁，即不会出现频繁的开辟和回收内存空间。")]),t._v(" "),n("h4",{attrs:{id:"生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),n("p",[t._v("constructor：函数组件不需要构造函数，可以直接调用useState来初始化State，如果代价比较昂贵可以穿一个函数给useState")]),t._v(" "),n("p",[t._v("getDerivedStateFromProps：改为在渲染时安排一次更新")]),t._v(" "),n("p",[t._v("shouldComponentUpdate：使用React.memo替代")]),t._v(" "),n("p",[t._v("使用react.memo包裹一个组件对props进行浅比较")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Button "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("memo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// component")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("p",[t._v("react.memo不比较state，因为没有单一的state对象进行比较，可以用usememo优化子节点")]),t._v(" "),n("p",[t._v("render：函数组件本身就有")]),t._v(" "),n("p",[t._v("componentDidMount、componentDidUpdate、componentWillUnmount：通过使用UseEffect的不同方式可以分别表达这些生命周期")]),t._v(" "),n("p",[t._v("getSnapshotBeforeUpdate、ComponentDidCatch、getDerivedFromError：目前还没有这些方法的等价写法")]),t._v(" "),n("h4",{attrs:{id:"根本区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#根本区别"}},[t._v("#")]),t._v(" 根本区别")]),t._v(" "),n("p",[t._v("函数式组件与class组件的心智模型不同。函数式组件捕获了渲染所用的值")]),t._v(" "),n("p",[t._v('hooks的最好的心智规则是"写代码时要认为任何值都可以随时更改"。')]),t._v(" "),n("p",[t._v("在react中，默认props在组件中是不可变的，这是在函数组件和类组件中都适用")]),t._v(" "),n("p",[t._v("但是，在类组件中，props要通过this取得，而this是永远可变的。这也是类组件 "),n("code",[t._v("this")]),t._v(" 存在的意义：能在渲染方法以及生命周期方法中得到最新的实例。")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class ProfilePage extends React.Component {\n  showMessage = () => alert('Followed ' + this.props.user);\n\n  handleClick = () => setTimeout(this.showMessage, 3000);\n\n  render() {\n    return <button onClick={this.handleClick}>Follow</button>;\n  }\n}\n")])])]),n("p",[t._v("所以如果在请求已经发出的情况下我们的组件进行了重新渲染， "),n("code",[t._v("this.props")]),t._v("将会改变。 "),n("code",[t._v("showMessage")]),t._v('方法从一个"过于新"的 '),n("code",[t._v("props")]),t._v("中得到了 "),n("code",[t._v("user")]),t._v("。")]),t._v(" "),n("p",[t._v("从 this 中读取数据的这种行为，调用一个回调函数读取 "),n("code",[t._v("this.props")]),t._v(" 的 timeout 会让 "),n("code",[t._v("showMessage")]),t._v(' 回调并没有与任何一个特定的渲染"绑定"在一起，所以它"失去"了正确的 props。。')]),t._v(" "),n("p",[t._v("解决上面的问题有两种方式")]),t._v(" "),n("p",[t._v("1.在调用事件之前读取 "),n("code",[t._v("this.props")]),t._v("，然后显式地传递到timeout回调函数中")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class ProfilePage extends React.Component {\n  showMessage = (user) => alert('Followed ' + user);\n\n  handleClick = () => {\n    const {user} = this.props;\n    setTimeout(() => this.showMessage(user), 3000);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>Followbutton>;\n  }\n}\n")])])]),n("p",[t._v("2.利用JavaScript的闭包")]),t._v(" "),n("p",[t._v("在render函数中获取渲染所用的props")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class ProfilePage extends React.Component {\n  render() {\n    const props = this.props;\n\n    const showMessage = () => {\n      alert('Followed ' + props.user);\n    };\n\n    const handleClick = () => {\n      setTimeout(showMessage, 3000);\n    };\n\n    return <button onClick={handleClick}>Follow</button>;\n  }\n}\n")])])]),n("p",[t._v("而在函数")]),t._v(" "),n("p",[n("code",[t._v("props")]),t._v("仍旧被捕获了 —— React将它们作为参数传递。 "),n("strong",[t._v("不同于 "),n("code",[t._v("this")]),t._v(" ， "),n("code",[t._v("props")]),t._v(" 对象本身永远不会被React改变")])]),t._v(" "),n("p",[n("strong",[t._v("捕获props和state通常是更好的默认值。")]),t._v(" 然而，在处理类似于intervals和订阅这样的命令式API时，ref会十分便利。你可以像这样跟踪 任何值 —— 一个prop，一个state变量，整个props对象，或者甚至一个函数")]),t._v(" "),n("h3",{attrs:{id:"hook本质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hook本质"}},[t._v("#")]),t._v(" hook本质")]),t._v(" "),n("p",[t._v("React Hook 是一种特殊的函数，其本质可以是函数式组件（返回 Dom 或 Dom 及 State ），也可以只是一个工具函数（传入配置项返回封装后的数据处理逻辑）")]),t._v(" "),n("p",[t._v("Hooks 组件的目标并不是取代类组件，而是增加函数式组件的使用率，明确通用工具函数与业务工具函数的边界，"),n("strong",[t._v("鼓励开发者将业务通用的逻辑封装成 React Hooks 而不是工具函数")])]),t._v(" "),n("h3",{attrs:{id:"usestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[t._v("#")]),t._v(" useState")]),t._v(" "),n("p",[t._v("实例")]),t._v(" "),n("div",{staticClass:"language-jsx extra-class"},[n("pre",{pre:!0,attrs:{class:"language-jsx"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" React"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("useState"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Example")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("count"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("setCount"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n     "),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),n("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n        ")]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),n("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("you click ")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("count"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v(" times")]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),n("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n        ")]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("button")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("onClick")]),n("span",{pre:!0,attrs:{class:"token script language-javascript"}},[n("span",{pre:!0,attrs:{class:"token script-punctuation punctuation"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("setCount")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("count "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),n("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n        click    \n        ")]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("button")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),n("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n     ")]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("上述useState方法定义了一个state变量count，并给他初始化的值0。通过setCount方法更新当前count的值。")]),t._v(" "),n("p",[t._v("调用count时不需要绑定this直接调用，更新count时也直接调用setCount方法")]),t._v(" "),n("p",[t._v("usestate定义state时返回一个有两个值的数组，第一个是当前state，第二个是更新state的函数，")]),t._v(" "),n("p",[t._v("count与setCount与class中的this.state.count和this.setstate类似，唯一的区别是需要成对地获取他们。")]),t._v(" "),n("p",[t._v("如果初始化state时需要复杂计算，可以调用函数，此函数只在初次渲染时被调用")]),t._v(" "),n("div",{staticClass:"language-jsx extra-class"},[n("pre",{pre:!0,attrs:{class:"language-jsx"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("setState"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" initialState"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("someExpensiveComputation")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" initialState"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("p",[t._v("count与setCount与class中的this.state.count和this.setstate类似，唯一的区别是需要成对地获取他们。")]),t._v(" "),n("p",[t._v("可以同时声明多个state变量")]),t._v(" "),n("div",{staticClass:"language-jsx extra-class"},[n("pre",{pre:!0,attrs:{class:"language-jsx"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("ExamplewithManyStates")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("age"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("setAge"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("usestate")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("fruit"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("setFruit"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("usestate")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'banana'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("todos"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("setTodos"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("usestate")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("text")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'学习'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("Hook只能在函数最外层调用，不要在循环、条件判断或者子函数中调用")]),t._v(" "),n("p",[t._v("useState更新数组时，必须用浅拷贝之后的新数组，如果只是简单赋值无法更新页面。因为react中如果数组引用地址不变，是不触发渲染的，但是值是设置进去的")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 无法更新\nconst [lists, setLists] = useState([]);\n\nconst arr = lists;\narr.splice(index,1);\nsetLists(arr);\n\n//扩展运算符浅拷贝\nconst [lists, setLists] = useState([]);\n\nconst arr = lists; //const arr = [...lists]\narr.splice(index,1);\nsetLists([...arr]);\n")])])]),n("h4",{attrs:{id:"usestate与setstate的异同"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usestate与setstate的异同"}},[t._v("#")]),t._v(" useState与setState的异同")]),t._v(" "),n("p",[t._v("setState会自动合并，不同的useState不会")]),t._v(" "),n("h4",{attrs:{id:"forceupdate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#forceupdate"}},[t._v("#")]),t._v(" forceupdate")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { useState, useCallback } from 'react'\n\nexport const useForceRender = () => {\n  const [, updateState] = useState<any>();\n  return useCallback(() => updateState({}),[])\n}\n")])])]),n("h4",{attrs:{id:"注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),n("p",[t._v("useState初始化时不能直接使用props。因为props变化时并不会通知useState方法，所以使用props初始化state时一直是undefined，可以使用useEffect在组件初始化时手动set一次")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { useState, useEffect } from 'react';\n\nconst FC = (initContent) => {\n  const [content, setContent] = useState<Partial<ContentType[]>>([]);\n\n  useEffect(() => {\n      initContent?.length && setContent(initContent);\n   }, [initContent]);\n}\n")])])]),n("h3",{attrs:{id:"useeffect和uselayouteffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect和uselayouteffect"}},[t._v("#")]),t._v(" useEffect和useLayoutEffect")]),t._v(" "),n("p",[t._v("对于class中的生命周期函数，为了能在函数组件中使用类似功能，使用useEffect方法，它相当于componentDidMount、componentDidupdate、componentWillUnmount三个函数的组合")]),t._v(" "),n("p",[t._v("useEffect默认情况下会在第一次渲染之后和每次更新之后都会执行。")]),t._v(" "),n("p",[t._v("useEffect在全部渲染完毕后才会执行，而useLayoutEffect会在浏览器layout之后，painting之前执行")]),t._v(" "),n("p",[t._v("为了用户体验，一般先使用useEffect")]),t._v(" "),n("p",[t._v("useLayoutEffect与原componentDidMount和componentDidUpdate相同，会堵塞渲染，useEffect不会。")]),t._v(" "),n("p",[t._v("使用步骤：")]),t._v(" "),n("ol",[n("li",[t._v("作为 componentDidMount 使用，第二个参数为空数组 "),n("code",[t._v("[]")])]),t._v(" "),n("li",[t._v("作为 componentDidUpdate 使用，第二个参数为指定依赖")]),t._v(" "),n("li",[t._v("作为 componentWillUnmount 使用，空数组的情况下通过 return返回函数来清除。该函数将在组件卸载时被执行。如果不需要清理副作用则不用返回任何值")]),t._v(" "),n("li",[t._v("如果useEffect当作ComponentDidUpdate使用时，每次Update之前会执行return中的返回函数以清理上一次渲染的副作用")])]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const BlinkyRender = () => {\n  const [value, setValue] = useState(0);\n\n  useEffect(() => {\n    document.querySelector(\'#x\').innerText = `value: 1000`\n  }, [value]);\n\n  return (\n    <div id="x" onClick={() => setValue(0)}>value: {value}</div>\n  );\n};\n\nReactDOM.render(\n  <BlinkyRender />,\n  document.querySelector("#root")\n);\n')])])]),n("p",[t._v("清除effect")]),t._v(" "),n("p",[t._v("通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，"),n("code",[t._v("useEffect")]),t._v(" 函数需返回一个清除函数。")]),t._v(" "),n("p",[t._v("为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则"),n("strong",[t._v("在执行下一个 effect 之前，上一个 effect 就已被清除")]),t._v("。")]),t._v(" "),n("p",[t._v("需要注意的是，"),n("strong",[t._v("如果包括多个副作用，应该调用多个useEffect，而不能够合并在一起。")])]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//错误\nuseEffect(()=>{\n  const timeoutA = setTimeout(()=> setVarA(varA + 1), 1000)\n  const timeoutB = setTimeout(()=> setVarB(varB + 1), 2000)\n  \n  return () => {\n    clearTimeout(timeoutA);\n    clearTimeout(timeoutB);\n  }\n},[varA, varB])\n\n//正确\nuseEffect(()=>{\n  const timeout = setTimeout(()=> setVarA(varA + 1), 1000)\n  return () => { clearTimeout(timeout)};\n},[varA])\n\nuseEffect(()=>{\n  const timeout = setTimeout(()=> setVarB(varB + 1), 1000)\n  return () => { clearTimeout(timeout)};\n},[varB])\n\n")])])]),n("p",[n("code",[t._v("useLayoutEffect")]),t._v(" 和 "),n("code",[t._v("useEffect")]),t._v(" 的相同点是：")]),t._v(" "),n("ul",[n("li",[t._v("函数签名是一样的；")]),t._v(" "),n("li",[t._v("clean up 机制是一样的；")]),t._v(" "),n("li",[t._v("提交 DOM mutation 次数是一样的。")])]),t._v(" "),n("p",[t._v("区别：")]),t._v(" "),n("p",[t._v("1."),n("code",[t._v("useEffect")]),t._v(" 是异步执行的，而"),n("code",[t._v("useLayoutEffect")]),t._v("是同步执行的。"),n("code",[t._v("useLayoutEffect")]),t._v("会阻塞paint流程，而"),n("code",[t._v("useEffect")]),t._v("不会阻塞paint流程。"),n("code",[t._v("useLayoutEffect")]),t._v(" callback 里面的「状态更新是批量」， 而 "),n("code",[t._v("useLayEffect")]),t._v(" callback 里面的「状态更新是非批量的」（也就是说，会分配到不同的渲染帧里面）。")]),t._v(" "),n("p",[t._v("如果"),n("code",[t._v("useLayoutEffect")]),t._v("的callback函数里面对状态请求了多次更新，那么这些更新请求会合并成一个 paint 请求，浏览器更新一次 UI 界面；同样的情况如果发生在"),n("code",[t._v("useEffect")]),t._v("的callback函数里面，那么更新请求不会被合并，有多少次状态更新请求，就会有多少次 paint 请求， 浏览")]),t._v(" "),n("p",[t._v("2."),n("code",[t._v("useEffect")]),t._v(" 的执行时机是浏览器完成渲染之后，而 "),n("code",[t._v("useLayoutEffect")]),t._v(" 的执行时机是浏览器把内容真正渲染到界面之前，和 "),n("code",[t._v("componentDidMount")]),t._v(" 等价。也就是，"),n("strong",[n("code",[t._v("useLayoutEffect")]),t._v(" 比 "),n("code",[t._v("useEffect")]),t._v(" 先执行")])]),t._v(" "),n("p",[t._v("也就是说，对于 "),n("code",[t._v("useEffect")]),t._v(" 来说，执行的时机是完成所有的 DOM 变更并让浏览器渲染页面后，而 "),n("code",[t._v("useLayoutEffect")]),t._v(" 和 class 组件中 "),n("code",[t._v("componentDidMount")]),t._v(", "),n("code",[t._v("componentDidUpdate")]),t._v("一致——在 React 完成 DOM 更新后马上同步调用，会阻塞页面渲染。")]),t._v(" "),n("p",[t._v("最好把操作 dom 、动画的相关操作放到 "),n("code",[t._v("useLayouteEffect")]),t._v(" 中去，避免导致闪烁")]),t._v(" "),n("p",[t._v("比如把useState分别放在useEffect和useLayoutEffect的if语句中，useEffect会闪烁，useLayoutEffect不会")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('import React, { useState, useLayoutEffect, useEffect } from "react";\nimport ReactDOM from "react-dom";\nimport "./styles.css";\n\nconst BlinkyRender = () => {\n  const [value, setValue] = useState(0);\n\n  useEffect(() => {\n    if (value === 0) {\n      setValue(10 + Math.random() * 200);\n    }\n  }, [value]);\n\n  console.log("render", value);\n\n  return <div onClick={() => setValue(0)}>value: {value}</div>;\n};\n\nReactDOM.render(<BlinkyRender />, document.querySelector("#root"));\n')])])]),n("h3",{attrs:{id:"usereducer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer"}},[t._v("#")]),t._v(" useReducer")]),t._v(" "),n("p",[t._v("useState内部就是靠useReducer实现的。")]),t._v(" "),n("p",[t._v("useReducer可以理解为是用来代替 Redux 的，或者说，是一个加强版的 "),n("code",[t._v("useState")]),t._v("。")]),t._v(" "),n("p",[t._v("使用步骤：")]),t._v(" "),n("p",[t._v("1.创建初始值initialState")]),t._v(" "),n("p",[t._v("2.创建所有操作reduce(state,action)")]),t._v(" "),n("p",[t._v("3.传给useReducer，得到读和写api")]),t._v(" "),n("p",[t._v("4.调用，写({type: '操作类型'})")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" initial "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("n")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("reducer")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" action")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("action"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("type "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"add"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("n")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" action"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("number "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("action"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("type "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"multi"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("n")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"unknown type"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("App")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dispatch"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("useReducer")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("reducer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" initial"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" n "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onClick")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("type")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"add"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("number")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onClick2")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("type")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"add"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("number")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div className"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"App"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n      "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button onClick"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("onClick"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button onClick"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("onClick2"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("useReducer 与js 数组的reduce方法这两者之间有巨大的相似之处。")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("reduce in JavaScript")]),t._v(" "),n("th",[t._v("useReducer in React")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[n("code",[t._v("array.reduce(reducer, initialValue)")])]),t._v(" "),n("td",[n("code",[t._v("useReducer(reducer, initialState)")])])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("singleValue = reducer(accumulator, itemValue)")])]),t._v(" "),n("td",[n("code",[t._v("newState = reducer(currentState, action)")])])]),t._v(" "),n("tr",[n("td",[t._v("reduce method returns a single value")]),t._v(" "),n("td",[t._v("useReducer returns a pair of values. [newState, dispatch]")])])])]),t._v(" "),n("h4",{attrs:{id:"usereducer-vs-usestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer-vs-usestate"}},[t._v("#")]),t._v(" useReducer vs useState")]),t._v(" "),n("p",[t._v("如果 state 的类型为 Number, String, Boolean 建议使用 useState，如果 state 的类型 为 Object 或 Array，建议使用 useReducer")]),t._v(" "),n("p",[t._v("如果 state 变化非常多，也是建议使用 useReducer，集中管理 state 变化，便于维护")]),t._v(" "),n("p",[t._v("如果 state 关联变化，建议使用 useReducer")]),t._v(" "),n("p",[t._v("业务逻辑如果很复杂，也建议使用 useReducer")]),t._v(" "),n("p",[t._v("如果 state 只想用在 组件内部，建议使用 useState，如果想维护全局 state 建议使用 useReducer")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("Scenario")]),t._v(" "),n("th",[t._v("useState")]),t._v(" "),n("th",[t._v("useReducer")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("Type of state")]),t._v(" "),n("td",[t._v("Number, String, Boolean")]),t._v(" "),n("td",[t._v("Object or Array")])]),t._v(" "),n("tr",[n("td",[t._v("Number of state transitions")]),t._v(" "),n("td",[t._v("1 or 2")]),t._v(" "),n("td",[t._v("Too many")])]),t._v(" "),n("tr",[n("td",[t._v("Related state transitions")]),t._v(" "),n("td",[t._v("No")]),t._v(" "),n("td",[t._v("Yes")])]),t._v(" "),n("tr",[n("td",[t._v("Business logic")]),t._v(" "),n("td",[t._v("No business logic")]),t._v(" "),n("td",[t._v("Complex business logic")])]),t._v(" "),n("tr",[n("td",[t._v("local vs global")]),t._v(" "),n("td",[t._v("local")]),t._v(" "),n("td",[t._v("global")])])])]),t._v(" "),n("p",[t._v("在react hooks的源码中，useState就是给useReducer的函数中传入一个固定的dispatch，其他与useReducer相同")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//  packages/react-reconciler/src/ReactFiberHooks.new.js\nfunction mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue<S, A> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchReducerAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n\n// useState的处理函数\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue<S, BasicStateAction<S>> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch<\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n")])])]),n("h3",{attrs:{id:"usecontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[t._v("#")]),t._v(" useContext")]),t._v(" "),n("p",[t._v("接受一个context对象，并返回该context的当前值，用于在函数组件之间共享状态")]),t._v(" "),n("p",[t._v("使用方法：")]),t._v(" "),n("p",[t._v("1.使用C=createContext(initial)创建上下文")]),t._v(" "),n("p",[t._v("2.使用<C.provider>圈定作用域")]),t._v(" "),n("p",[t._v("3.在作用域内使用 "),n("code",[t._v("useContext(C)")]),t._v(" 来使用上下文")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const C = createContext(null);\n\nfunction App() {\n  console.log("App 执行了");\n  const [n, setN] = useState(0);\n  return (\n    <C.Provider value={{ n, setN }}>\n      <div className="App">\n        <Baba />\n      </div>\n    </C.Provider>\n  );\n}\n\nfunction Baba() {\n  const { n, setN } = useContext(C);\n  return (\n    <div>\n      我是爸爸 n: {n} <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const { n, setN } = useContext(C);\n  const onClick = () => {\n    setN(i => i + 1);\n  };\n  return (\n    <div>\n      我是儿子 我得到的 n: {n}\n      <button onClick={onClick}>+1</button>\n    </div>\n  );\n}\n')])])]),n("p",[n("code",[t._v("useContext(MyContext)")]),t._v(" 相当于 class 组件中的 "),n("code",[t._v("static contextType = MyContext")]),t._v(" 或者 "),n("code",[t._v("<MyContext.Consumer>")]),t._v("。")]),t._v(" "),n("p",[n("code",[t._v("useContext(MyContext)")]),t._v(" 只是让你能够"),n("em",[t._v("读取")]),t._v(" context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 "),n("code",[t._v("<MyContext.Provider>")]),t._v(" 来为下层组件"),n("em",[t._v("提供")]),t._v(" context。")]),t._v(" "),n("h3",{attrs:{id:"usecallback与usememo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecallback与usememo"}},[t._v("#")]),t._v(" usecallback与useMemo")]),t._v(" "),n("p",[n("strong",[t._v("useMemo")])]),t._v(" "),n("p",[t._v("返回一个缓存值。")]),t._v(" "),n("p",[t._v("useMemo是一种缓存机制提速，当他的依赖未发生改变时就不会触发重新计算，与vue中computed类似")]),t._v(" "),n("p",[t._v("使用语法：useMemo(()=> fn,deps)")]),t._v(" "),n("p",[t._v("把创建函数和依赖项数组作为参数传入useMemo，它只会在某个依赖项改变时才重新计算memoized值。如果没有提供依赖项数组，useMemo在每次渲染时都会计算新的值")]),t._v(" "),n("div",{staticClass:"language-tsx extra-class"},[n("pre",{pre:!0,attrs:{class:"language-tsx"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" myValue"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("useMemo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" item "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" allCrowdData"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("value "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      name"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" item"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        value"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        label"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" item"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" LabeledValue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("allCrowdData"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[n("strong",[t._v("useCallback")])]),t._v(" "),n("p",[t._v("返回一个缓存函数。把内联回调函数及依赖数组作为参数传入useCallback，它将返回该回调函数u的memorized版本，该回调函数仅在某个依赖项改变时才会更新，在组件中使用usecallback可以避免非必要渲染")]),t._v(" "),n("p",[n("strong",[t._v("useCallback（fn，dep） 与useCallback( ()=>fn，dep）等效")])]),t._v(" "),n("p",[n("strong",[t._v("useCallback（fn，dep）相当于useMemo( () => fn，deps）")])]),t._v(" "),n("p",[t._v("useMemo与usecallback的区别："),n("code",[t._v("useMemo")]),t._v("可以缓存所有对象，"),n("code",[t._v("useCallback")]),t._v("只能缓存函数。")]),t._v(" "),n("p",[n("code",[t._v("useCallback(x => log(x), [m])")]),t._v(" 等价于 "),n("code",[t._v("useMemo(() => x => log(x), [m])")])]),t._v(" "),n("div",{staticClass:"language-tsx extra-class"},[n("pre",{pre:!0,attrs:{class:"language-tsx"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" handleInputChange "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("useCallback")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleUpdateSearchWord")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("handleUpdateSearchWord"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("普通的函数组件本身就是高内聚的，所以一般没有useCallback的事，比如")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 用于记录 getData 调用次数\nlet count = 0;\n\nfunction App() {\n  const [val, setVal] = useState(\"\");\n\n  function getData() {\n    setTimeout(()=>{\n      setVal('new data '+count);\n      count++;\n    }, 500)\n  }\n\n  useEffect(()=>{\n    getData();\n  }, []);\n\n  return (\n    <div>{val}</div>\n  );\n}\n")])])]),n("p",[t._v("实际上，在普通组件中使用useCallback可能性能会更差，比如普通的onChange函数")]),t._v(" "),n("p",[t._v("https://codesandbox.io/s/test-usecallback-xqvuc?file=/src/index.js")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function App() {\n  const [val, setVal] = useState("");\n\n  const onChange = (evt) => {\n    setVal(evt.target.value);\n  };\n\n  // const onChange = useCallback(evt => {\n  //   setVal(evt.target.value);\n  // }, []);\n  //可以看到onChange的定义是省不了的，而且额外还要加上调用useCallback产生的开销，性能怎么可能会更好\n  return <input val={val} onChange={onChange} />;\n}\n')])])]),n("p",[t._v("useCallback能够改善性能的场景有两种：")]),t._v(" "),n("ul",[n("li",[t._v("函数"),n("code",[t._v("定义")]),t._v("时需要进行大量运算， 这种场景极少")]),t._v(" "),n("li",[t._v("需要比较引用的场景，如"),n("code",[t._v("useEffect")]),t._v("，又或者是配合"),n("code",[t._v("React.Memo")]),t._v("使用：")])]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const Child = React.memo(function({val, onChange}) {\n  console.log('render...');\n  \n  return <input value={val} onChange={onChange} />;\n});\n\nfunction App() {\n  const [val1, setVal1] = useState('');\n  const [val2, setVal2] = useState('');\n\n  const onChange1 = useCallback( evt => {\n    setVal1(evt.target.value);\n  }, []);\n\n  const onChange2 = useCallback( evt => {\n    setVal2(evt.target.value);\n  }, []);\n\n  return (\n  <>\n    <Child val={val1} onChange={onChange1}/>\n    <Child val={val2} onChange={onChange2}/>\n  </>\n  );\n}\n")])])]),n("p",[t._v("在useEffect中的监听函数")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 用于记录 getData 调用次数\nlet count = 0;\n\nfunction App() {\n  const [val, setVal] = useState("");\n\n  function getData() {\n    setTimeout(() => {\n      setVal("new data " + count);\n      count++;\n    }, 500);\n  }\n\n  return <Child val={val} getData={getData} />;\n}\n\nfunction Child({val, getData}) {\n  useEffect(() => {\n    getData();\n  }, [getData]);\n\n  return <div>{val}</div>;\n}\n')])])]),n("p",[t._v("上面的代码中，是一个死循环，分析下代码的执行过程：")]),t._v(" "),n("ol",[n("li",[n("code",[t._v("App")]),t._v("渲染"),n("code",[t._v("Child")]),t._v("，将"),n("code",[t._v("val")]),t._v("和"),n("code",[t._v("getData")]),t._v("传进去")]),t._v(" "),n("li",[n("code",[t._v("Child")]),t._v("使用"),n("code",[t._v("useEffect")]),t._v("获取数据。因为对"),n("code",[t._v("getData")]),t._v("有依赖，于是将其加入依赖列表")]),t._v(" "),n("li",[n("code",[t._v("getData")]),t._v("执行时，调用"),n("code",[t._v("setVal")]),t._v("，导致"),n("code",[t._v("App")]),t._v("重新渲染")]),t._v(" "),n("li",[n("code",[t._v("App")]),t._v("重新渲染时生成新的"),n("code",[t._v("getData")]),t._v("方法，传给"),n("code",[t._v("Child")])]),t._v(" "),n("li",[n("code",[t._v("Child")]),t._v("发现"),n("code",[t._v("getData")]),t._v("的引用变了，又会执行"),n("code",[t._v("getData")])]),t._v(" "),n("li",[t._v("3 -> 5 是一个死循环")])]),t._v(" "),n("p",[t._v("把函数用useCallback缓存就可以")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const getData = useCallback(() => {\n  setTimeout(() => {\n    setVal("new data " + count);\n    count++;\n  }, 500);\n}, []);\n')])])]),n("p",[t._v("还有一种情况是在"),n("code",[t._v("getData")]),t._v("中需要用到"),n("code",[t._v("val")]),t._v("( useState 中的值)，就需要将其加入依赖列表，这样的话又会导致每次"),n("code",[t._v("getData")]),t._v("的引用都不一样，死循环又出现了")]),t._v(" "),n("p",[t._v("如果我们希望无论"),n("code",[t._v("val")]),t._v("怎么变，"),n("code",[t._v("getData")]),t._v("的引用都保持不变，同时又能取到"),n("code",[t._v("val")]),t._v("最新的值，可以通过自定义 hook 实现。注意这里不能简单的把"),n("code",[t._v("val")]),t._v("从依赖列表中去掉，否则"),n("code",[t._v("getData")]),t._v("中的"),n("code",[t._v("val")]),t._v("永远都只会是初始值（闭包）")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function useRefCallback(fn, dependencies) {\n  const ref = useRef(fn);\n\n  // 每次调用的时候，fn 都是一个全新的函数，函数中的变量有自己的作用域\n  // 当依赖改变的时候，传入的 fn 中的依赖值也会更新，这时更新 ref 的指向为新传入的 fn\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n\n// 调用\nconst getData = useRefCallback(() => {\n  console.log(val);\n\n  setTimeout(() => {\n    setVal("new data " + count);\n    count++;\n  }, 500);\n}, [val]);\n')])])]),n("h3",{attrs:{id:"useref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[t._v("#")]),t._v(" useRef")]),t._v(" "),n("p",[t._v("useRef")]),t._v(" "),n("p",[t._v("主要作用是创建一个数据的引用，并让这个数据在 render 过程中始终"),n("strong",[t._v("保持不变")]),t._v("。修改ref对象不会像修改state那样触发重绘。")]),t._v(" "),n("p",[n("strong",[t._v("Refs为我们提供了一种绕过状态更新和重新渲染访问元素的方法（获取某个元素的实例），但不能作为props 和 state 的替代方法")])]),t._v(" "),n("p",[t._v("基本语法： "),n("code",[t._v("const count = useRef(0)")]),t._v("，读取用 "),n("code",[t._v("count.current")])]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export function ReactEcharts(props) {\n  const {option, loading} = props\n  const container = useRef(null)\n  const chart = useRef(null)\n\n  useEffect(() => {\n    const width = document.documentElement.clientWidth\n    const c = container.current\n    console.log(c)\n    c.style.width = `${width - 20}px`\n    c.style.height = `${(width - 20) * 1.2}px`\n    chart.current = echarts.init(c, 'dark')\n\n  }, []) // [] - mounted on first time\n\n  useEffect(() => {\n    chart.current.setOption(option)\n  }, [option]) // when option change 类似 vue 的 watch\n\n  useEffect(() => {\n    if (loading) chart.current.showLoading()\n    else chart.current.hideLoading()\n  }, [loading])\n  return (\n    <div ref={container}/>\n  )\n}\n")])])]),n("p",[t._v("useRef使用时报错不能将类型“MutableRefObject<HTMLDivElement | undefined>”分配给类型“LegacyRef | undefined”。")]),t._v(" "),n("p",[t._v("原因：")]),t._v(" "),n("p",[t._v("1.没赋初值")]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("useRef里面没写对类型")])]),t._v(" "),n("h4",{attrs:{id:"useref与createref的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useref与createref的区别"}},[t._v("#")]),t._v(" useRef与createRef的区别")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('import React, { useRef, createRef, useState } from "react";\nimport ReactDOM from "react-dom";\n\nfunction App() {\n  const [renderIndex, setRenderIndex] = useState(1);\n\n  const refFromUseRef = useRef();\n  const refFromCreateRef = createRef();\n\n  if (!refFromUseRef.current) {\n    // 赋值操作,赋值给useRef\n    refFromUseRef.current = renderIndex;\n  }\n  if (!refFromCreateRef.current) {\n    // 赋值操作，赋值给createRef\n    refFromCreateRef.current = renderIndex;\n  }\n  return (\n    <div className="App">\n      Current render index: {renderIndex}\n      <br />\n      在refFromUseRef.current中记住的第一个渲染索引：\n      {refFromUseRef.current}\n      <br />\n      在refFromCreateRef.current中未能成功记住第一个渲染索引：\n      {refFromCreateRef.current}\n      <br />\n      <button onClick={() => setRenderIndex(prev => prev + 1)}>\n        数值 + 1\n      </button>\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById("root");\nReactDOM.render(<App />, rootElement);\n')])])]),n("p",[t._v("上面的案例中无论如何点击按钮 "),n("code",[t._v("refFromUseRef.current")]),t._v(" 将始终为 "),n("code",[t._v("1")]),t._v("，而 "),n("code",[t._v("renderIndex")]),t._v(" 和 "),n("code",[t._v("refFromCreateRef.current")]),t._v(" 会伴随点击事件改变")]),t._v(" "),n("p",[t._v("当 ref 对象内容发生变化时，useRef 并不会通知你。变更 "),n("code",[t._v(".current")]),t._v(" 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用 "),n("code",[t._v("callback ref")]),t._v(" 来实现")]),t._v(" "),n("h4",{attrs:{id:"ref的使用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ref的使用场景"}},[t._v("#")]),t._v(" ref的使用场景")]),t._v(" "),n("ul",[n("li",[t._v("管理焦点，文本选择或处理表单数据")])]),t._v(" "),n("p",[t._v("因为非受控组件将真实数据储存在 DOM 节点中，所以再使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件")]),t._v(" "),n("ul",[n("li",[t._v("媒体播放。")])]),t._v(" "),n("p",[t._v("基于 React 的音乐或视频播放器可以利用 Refs 来管理其当前状态（播放/暂停），或管理播放进度等。这些更新不需要进行状态管理。")]),t._v(" "),n("ul",[n("li",[t._v("触发强制动画。")])]),t._v(" "),n("p",[t._v("如果要在元素上触发过强制动画时，可以使用 Refs 来执行此操作。")]),t._v(" "),n("ul",[n("li",[t._v("集成第三方 DOM 库。")])]),t._v(" "),n("p",[t._v("默认情况下，"),n("strong",[t._v("你不能在函数组件上使用 "),n("code",[t._v("ref")]),t._v(" 属性")]),t._v("，因为它们没有实例")]),t._v(" "),n("p",[t._v("如果要在函数组件中使用 "),n("code",[t._v("ref")]),t._v("，你可以使用 "),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/forwarding-refs.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("forwardRef")]),n("OutboundLink")],1),t._v("（可与 "),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("useImperativeHandle")]),n("OutboundLink")],1),t._v(" 结合使用），或者可以将该组件转化为 class 组件。")]),t._v(" "),n("p",[t._v("你可以"),n("strong",[t._v("在函数组件内部使用 "),n("code",[t._v("ref")]),t._v(" 属性")]),t._v("，只要它指向一个 DOM 元素或 class 组件")]),t._v(" "),n("h4",{attrs:{id:"回调ref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回调ref"}},[t._v("#")]),t._v(" 回调ref")]),t._v(" "),n("p",[t._v("React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。")]),t._v(" "),n("p",[t._v("不同于传递 "),n("code",[t._v("createRef()")]),t._v(" 创建的 "),n("code",[t._v("ref")]),t._v(" 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.textInput = null;\n\n    this.setTextInputRef = element => {\n      this.textInput = element;\n    };\n\n    this.focusTextInput = () => {\n      // 使用原生 DOM API 使 text 输入框获得焦点\n      if (this.textInput) this.textInput.focus();\n    };\n  }\n\n  componentDidMount() {\n    // 组件挂载后，让文本框自动获得焦点\n    this.focusTextInput();\n  }\n\n  render() {\n    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React\n    // 实例上（比如 this.textInput）\n    return (\n      <div>\n        <input\n          type="text"\n          ref={this.setTextInputRef}\n        />\n        <input\n          type="button"\n          value="Focus the text input"\n          onClick={this.focusTextInput}\n        />\n      </div>\n    );\n  }\n}\n')])])]),n("p",[t._v("React 将在组件挂载时，会调用 "),n("code",[t._v("ref")]),t._v(" 回调函数并传入 DOM 元素，当卸载时调用它并传入 "),n("code",[t._v("null")]),t._v("。在 "),n("code",[t._v("componentDidMount")]),t._v(" 或 "),n("code",[t._v("componentDidUpdate")]),t._v(" 触发前，React 会保证 refs 一定是最新的")]),t._v(" "),n("h3",{attrs:{id:"useimperativehandle与forwardref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useimperativehandle与forwardref"}},[t._v("#")]),t._v(" useImperativeHandle与forwardref")]),t._v(" "),n("p",[t._v("useImperativeHandle")]),t._v(" "),n("p",[t._v("useImperativeHandle可以让你在使用转发ref时自定义暴露给父组件的实例值。通过"),n("code",[t._v("useImperativeHandle")]),t._v("减少暴露给父组件获取的DOM元素属性，只暴露特定的操作，从而提升性能")]),t._v(" "),n("p",[t._v("在大多数情况下，应当避免使用ref这样的命令式代码，useImperativeHandle应当与forwardRef一起使用")]),t._v(" "),n("p",[t._v("useImperativeHandle的语法：useImperativeHandle(ref, createHandle, [deps])")]),t._v(" "),n("ol",[n("li",[n("code",[t._v("ref")]),t._v("\n需要被赋值的"),n("code",[t._v("ref")]),t._v("对象。")]),t._v(" "),n("li",[n("code",[t._v("createHandle")]),t._v("：\n"),n("code",[t._v("createHandle")]),t._v("函数的返回值作为"),n("code",[t._v("ref.current")]),t._v("的值。")]),t._v(" "),n("li",[n("code",[t._v("[deps]")]),t._v("\n依赖数组，依赖发生变化会重新执行"),n("code",[t._v("createHandle")]),t._v("函数。")])]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { useRef, forwardRef, useImperativeHandle } from 'react'\n\nconst JMInput = forwardRef((props, ref) => {\n  const inputRef = useRef()\n  // 作用: 减少父组件获取的DOM元素属性,只暴露给父组件需要用到的DOM方法\n  // 参数1: 父组件传递的ref属性\n  // 参数2: 返回一个对象,父组件通过ref.current调用对象中方法\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus()\n    },\n  }))\n  return <input type=\"text\" ref={inputRef} />\n})\n\nexport default function ImperativeHandleDemo() {\n  // useImperativeHandle 主要作用:用于减少父组件中通过forward+useRef获取子组件DOM元素暴露的属性过多\n  // 为什么使用: 因为使用forward+useRef获取子函数式组件DOM时,获取到的dom属性暴露的太多了\n  // 解决: 使用uesImperativeHandle解决,在子函数式组件中定义父组件需要进行DOM操作,减少获取DOM暴露的属性过多\n  const inputRef = useRef()\n\n  return (\n    <div>\n      <button onClick={() => inputRef.current.focus()}>聚焦</button>\n      <JMInput ref={inputRef} />\n    </div>\n  )\n}\n")])])]),n("p",[t._v("useImperativeHandle更常用的写法是")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type Props = {\n  content?: string;\n};\n\ntype Instance = {\n  insertParam: (text: string, value: string) => void;\n};\nconst Setting = React.forwardRef<\n  Instance,\n  Props\n>(function ContentSetting({ content }, ref) {\n\tconst itemRefs = React.useRef<(RichTextInputInstance | null)[]>([]);\n  useImperativeHandle(ref, () => ({\n    insertParam(text, value) {\n      const focusRef = itemRefs?.current?.[focusIndex as any];\n      focusRef?.insertParam(text, value);\n    },\n  }));\n  \n  return (\n  \n    <RichTextInput\n      placeholder={placeholder}\n      readOnly={readOnly}\n      ref={(inputRef) => (itemRefs.current[index] = inputRef)}\n      onFocus={() => handleFocus(index)}\n      className={classNames({ [styles.formReadOnly]: readOnly })}\n      singleLine={singleLine}\n      />)\n}\n")])])]),n("h3",{attrs:{id:"usedebugvalue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usedebugvalue"}},[t._v("#")]),t._v(" useDebugValue")]),t._v(" "),n("h3",{attrs:{id:"自定义hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义hook"}},[t._v("#")]),t._v(" 自定义hook")]),t._v(" "),n("p",[t._v("可以把不同的hook按照实际的需求混合起来，封装成一个新的函数使用")]),t._v(" "),n("p",[t._v("通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const useList = () => {\n  const [list, setList] = useState(null);\n  useEffect(() => {\n    ajax("/list").then(list => {\n      setList(list);\n    });\n  }, []); // [] 确保只在第一次运行\n  return {\n    list: list,\n    setList: setList\n  };\n};\nexport default useList;\n')])])]),n("p",[t._v("抽象useInput hooks")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { useState } from 'react'\n\nfunction useInput(initialValue: string) {\n  const [value, setValue] = useState(initialValue)\n  const reset = () => {\n    setValue(initialValue)\n  }\n  const bind = {\n    value,\n    onChange(e: any) {\n      setValue(e.target.value)\n    }\n  }\n  return [value, bind, reset]\n}\n\nexport default useInput\n")])])]),n("p",[t._v("使用useInput Hook")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { FormEvent } from 'react'\nimport useInput from './hooks/useInput'\n\nfunction UserForm() {\n\n  const [firstName, bindFirstName, resetFirstName] = useInput('')\n  const [lastName, bindLastName, resetLastName] = useInput('')\n\n  const submitHandler = (e: FormEvent) => {\n    e.preventDefault()\n    console.log(`Hello ${firstName} ${lastName}`)\n    // @ts-ignore\n    resetFirstName()\n    // @ts-ignore\n    resetLastName()\n  }\n  return (\n    <div>\n      <form onSubmit={submitHandler}>\n        <div>\n          <label htmlFor=\"\">First name</label>\n          <input\n            type=\"text\"\n            {...bindFirstName}\n          />\n        </div>\n        <div>\n          <label htmlFor=\"\">Last name</label>\n          <input\n            type=\"text\"\n            {...bindLastName}\n          />\n        </div>\n        <button>submit</button>\n      </form>\n    </div>\n  )\n}\n\nexport default UserForm\n")])])]),n("p",[t._v("返回 DOM 其实和最基本的 Hook 逻辑是相同的，只是在返回的数据内容上有一些差异")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { useState } from 'react';\nimport { Modal } from 'antd';\n\nfunction useModal() {\n  const [visible, changeVisible] = useState(false);\n\n  const toggleModalVisible = () => {\n    changeVisible(!visible);\n  };\n\n  return [(\n    <Modal\n      visible={visible}\n      onOk={toggleModalVisible}\n      onCancel={toggleModalVisible}\n    >\n      弹窗内容\n      </Modal>\n  ), toggleModalVisible];\n}\n\nexport default function HookDemo() {\n  const [modal, toggleModal] = useModal();\n  return (\n    <div>\n      {modal}\n      <button onClick={toggleModal}>打开弹窗</button>\n    </div>\n  );\n}\n")])])]),n("h4",{attrs:{id:"自定义hooks的注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义hooks的注意事项"}},[t._v("#")]),t._v(" 自定义hooks的注意事项")]),t._v(" "),n("ul",[n("li",[t._v("定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。")]),t._v(" "),n("li",[t._v("只在最顶层使用 Hook")]),t._v(" "),n("li",[t._v("不要在循环，条件或嵌套函数中调用 Hook")]),t._v(" "),n("li",[t._v("只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook")])]),t._v(" "),n("p",[t._v("注意性能优化")]),t._v(" "),n("h3",{attrs:{id:"最佳实践"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),n("h4",{attrs:{id:"惰性初始值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#惰性初始值"}},[t._v("#")]),t._v(" 惰性初始值")]),t._v(" "),n("p",[n("code",[t._v("someExpensiveComputation")]),t._v(" 是一个相对耗时的操作。如果我们直接采用")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" initialState "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("someExpensiveComputation")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setState"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("initialState"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("注意，虽然 "),n("code",[t._v("initialState")]),t._v(" 只在初始化时有其存在的价值，但是 "),n("code",[t._v("someExpensiveComputation")]),t._v(" 在每一帧都被调用了。只有当使用惰性初始化的方法")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const [state, setState] = useState(() => {\n    const initialState = someExpensiveComputation(props);\n    return initialState;\n});\n")])])]),n("p",[t._v("因 "),n("code",[t._v("someExpensiveComputation")]),t._v(" 运行在一个匿名函数下，该函数当且仅当初始化时被调用，从而优化性能。")]),t._v(" "),n("h4",{attrs:{id:"usememo-usecallback"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usememo-usecallback"}},[t._v("#")]),t._v(" useMemo/useCallback")]),t._v(" "),n("p",[t._v("useMemo 的目的其实是尽量使用缓存的值。")]),t._v(" "),n("p",[t._v("对于函数，其作为另外一个 useEffect 的 deps 时，减少函数的重新生成，就能减少该 Effect 的调用，甚至避免一些死循环的产生;")]),t._v(" "),n("p",[t._v("对于对象和数组，如果某个子组件使用了它作为 props，减少它的重新生成，就能避免子组件不必要的重复渲染，提升性能。")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 未优化代码\nconst data = { id };\n\nreturn <Child data={data}>;\n\n// 优化代码\nconst data = useMemo(() => ({ id }), [id]);\n\nreturn <Child data={data}>;\n")])])]),n("p",[t._v("未优化之前，每当父组件需要 render 时，子组件也会执行 render。如果使用 "),n("code",[t._v("useMemo")]),t._v(" 对 data 进行优化：")]),t._v(" "),n("p",[t._v("当父组件 render 时，只要满足 id 不变，data 的值也不会发生变化，子组件也将避免 render。")]),t._v(" "),n("p",[t._v("对于组件返回的 React Elements，我们可以选择性地提取其中一部分 elements，通过 useMemo 进行缓存，也能避免这一部分的重复渲染。")]),t._v(" "),n("p",[t._v("但同时，也要避免滥用useMemos")]),t._v(" "),n("p",[t._v("使用 useMemo 当 deps 不变时，直接返回上一次计算的结果，从而使子组件跳过渲染。")]),t._v(" "),n("p",[t._v("但是当返回的是原始数据类型（如字符串、数字、布尔值）。即使参与了计算，只要 deps 依赖的内容不变，返回结果也很可能是不变的。此时就需要权衡这个计算的时间成本和 useMemo 额外带来的空间成本（缓存上一次的结果）了。")]),t._v(" "),n("p",[t._v("此外，如果 useMemo 的 deps 依赖数组为空，这样做说明你只是希望存储一个值，这个值在重新 render 时永远不会变。此时用useMemo不是最佳选择")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 未优化代码\nconst Comp = () => {\n    const data = useMemo(() => ({ type: 'xxx' }), []);\n    return <Child data={data}>;\n}\n    \n// 优化1\nconst Comp = () => {\n    const { current: data } = useRef({ type: 'xxx' });\n    return <Child data={data}>;\n}\n        \n// 优化2\nconst data = { type: 'xxx' };\nconst Comp = () => {\n    return <Child data={data}>;\n}\n")])])]),n("p",[t._v("此外，如果 deps 频繁变动，我们也要思考，使用 useMemo 是否有必要。因为 useMemo 占用了额外的空间，还需要在每次 render 时检查 deps 是否变动，反而比不使用 useMemo 开销更大。")]),t._v(" "),n("p",[t._v("一个函数执行完毕之后，就会从函数调用栈中被弹出，里面的内存也会被回收。因此，即使在函数内部创建了多个函数，执行完毕之后，这些创建的函数也都会被释放掉。"),n("strong",[t._v("函数式组件的性能是非常快的")]),t._v("。相比class，函数更轻量，也避免了使用高阶组件、renderProps等会造成额外层级的技术。使用合理的情况下，性能几乎不会有什么问题。")]),t._v(" "),n("p",[t._v("而当我们使用"),n("code",[t._v("useMemo/useCallback")]),t._v("时，由于新增了对于闭包的使用，新增了对于依赖项的比较逻辑，因此，盲目使用它们，甚至可能会让你的组件变得更慢。")]),t._v(" "),n("p",[t._v("大多数情况下，这样的交换，并不划算，或者赚得不多。你的组件可能并不需要使用useMemo/useCallback来优化。")]),t._v(" "),n("p",[n("strong",[t._v("记忆函数并非完全没有代价，我们需要创建闭包，占用更多的内存，用以解决计算上的冗余")]),t._v("。")]),t._v(" "),n("p",[n("strong",[t._v("通常情况下，当函数体或者结果的计算过程非常复杂时，我们才会考虑优先使用useCallback/useMemo。")])]),t._v(" "),n("h4",{attrs:{id:"受控与非受控"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#受控与非受控"}},[t._v("#")]),t._v(" 受控与非受控")]),t._v(" "),n("p",[t._v("如果组件中有派生state，可以像这样")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("useSomething = (inputCount) => {\n    const [ count, setCount ] = setState(inputCount);\n};\n")])])]),n("p",[t._v("外部传入的 "),n("code",[t._v("inputCount")]),t._v(" 属性发生了变化时，默认不会更新，因为 useState 参数代表的是初始值，仅在 "),n("code",[t._v("useSomething")]),t._v(" 初始时赋值给了 "),n("code",[t._v("count")]),t._v(" state。后续 "),n("code",[t._v("count")]),t._v(" 的状态将与 "),n("code",[t._v("inputCount")]),t._v(" 无关。这种外部无法直接控制 state 的方式，我们称为非受控。")]),t._v(" "),n("p",[t._v("如果想被外部传入的 props 始终控制，比如在这个例子中，"),n("code",[t._v("useSomething")]),t._v(" 内部，"),n("code",[t._v("count")]),t._v(" 这一 state 的值需要从 "),n("code",[t._v("inputCount")]),t._v(" 进行同步，")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("useSomething = (inputCount) => {\n    const [ count, setCount ] = setState(inputCount);\n    setCount(inputCount);\n};\n")])])]),n("p",[n("code",[t._v("setCount")]),t._v("后，React 会立即退出当前的 render 并用更新后的 state 重新运行 render 函数。")]),t._v(" "),n("p",[t._v("在这种的机制下，state 由外界同步的同时，内部又有可能通过 setState 来修改 state，可能引发新的问题。例如 "),n("code",[t._v("useSomething")]),t._v(" 初始时，count 为 0，后续内部通过 "),n("code",[t._v("setCount")]),t._v(" 修改了 "),n("code",[t._v("count")]),t._v(" 为 1。当外部函数组件的 render 函数重新调用，也会再一次调用 "),n("code",[t._v("useSomething")]),t._v("，此时传入的 "),n("code",[t._v("inputCount")]),t._v(" 依然是 0，就会把 "),n("code",[t._v("count")]),t._v(" 变回 0")]),t._v(" "),n("p",[t._v("遇到这样的问题，建议将 inputCount 的当前值与上一次的值进行比较，只有确定发生变化时执行 setCount(inputCount) 。")]),t._v(" "),n("p",[t._v("https://zhuanlan.zhihu.com/p/142735113")])])}),[],!1,null,null,null);e.default=s.exports}}]);