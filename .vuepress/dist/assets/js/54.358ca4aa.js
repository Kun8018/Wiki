(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{339:function(e,r,t){"use strict";t.r(r);var o=t(14),n=Object(o.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("​")]),e._v(" "),t("h2",{attrs:{id:"k8s简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#k8s简介"}},[e._v("#")]),e._v(" K8s简介")]),e._v(" "),t("p",[e._v("Kubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。")]),e._v(" "),t("p",[e._v("通过Kubernetes你可以：")]),e._v(" "),t("ul",[t("li",[e._v("快速部署应用")]),e._v(" "),t("li",[e._v("快速扩展应用")]),e._v(" "),t("li",[e._v("无缝对接新的应用功能")]),e._v(" "),t("li",[e._v("节省资源，优化硬件资源的使用")])]),e._v(" "),t("p",[e._v("Kubernetes的特点")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("可移植")]),e._v(": 支持公有云，私有云，混合云，多重云（multi-cloud）")]),e._v(" "),t("li",[t("strong",[e._v("可扩展")]),e._v(": 模块化, 插件化, 可挂载, 可组合")]),e._v(" "),t("li",[t("strong",[e._v("自动化")]),e._v(": 自动部署，自动重启，自动复制，自动伸缩/扩展")])]),e._v(" "),t("h2",{attrs:{id:"k8s的历史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#k8s的历史"}},[e._v("#")]),e._v(" K8s的历史")]),e._v(" "),t("p",[e._v("众所周知，"),t("a",{attrs:{href:"https://kubernetes.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes"),t("OutboundLink")],1),e._v(" 是 Google 于 2014 年 6 月基于其内部使用的 "),t("a",{attrs:{href:"https://research.google.com/pubs/pub43438.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Borg"),t("OutboundLink")],1),e._v(" 系统开源出来的容器编排调度引擎。其实从 2000 年开始，Google 就开始基于容器研发三个容器管理系统，分别是 Borg、Omega 和 Kubernetes。这篇由 Google 工程师 Brendan Burns、Brian Grant、David Oppenheimer、Eric Brewer 和 John Wilkes 几人在 2016 年发表的"),t("a",{attrs:{href:"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Borg, Omega, and Kubernetes》"),t("OutboundLink")],1),e._v("论文里，阐述了 Google 从 Borg 到 Kubernetes 这个旅程中所获得知识和经验教训。")]),e._v(" "),t("p",[e._v("Google 从 2000 年初就开始使用容器（Linux 容器）系统，Google 开发出来的第一个统一的容器管理系统在内部称之为 “Borg”，用来管理长时间运行的生产服务和批处理服务。由于 Borg 的规模、功能的广泛性和超高的稳定性，一直到现在 Borg 在 Google 内部依然是主要的容器管理系统。")]),e._v(" "),t("p",[e._v("Google 的第二套容器管理系统叫做 Omega，作为 Borg 的延伸，它的出现是出于提升 Borg 生态系统软件工程的愿望。Omega 应用到了很多在 Borg 内已经被认证的成功的模式，但是是从头开始来搭建以期更为一致的构架。由于越来越多的应用被开发并运行在 Borg 上，Google 开发了一个广泛的工具和服务的生态系统。它被应用到了很多在 Borg 内已经被认证的成功的模式，但是是从头开始来搭建以期更为一致的构架。这些系统提供了配置和更新 job 的机制，能够预测资源需求，动态地对在运行中的程序推送配置文件、服务发现、负载均衡、自动扩容、机器生命周期管理、额度管理等。许多 Omega 的创新（包括多个调度器）都被收录进了 Borg。")]),e._v(" "),t("p",[e._v("Google 的第三套容器管理系统就是我们所熟知的 Kubernetes，它是针对在 Google 外部的对 Linux 容器感兴趣的开发者以及 Google 在公有云底层商业增长的考虑而研发的。和 Borg、Omega 完全是谷歌内部系统相比，Kubernetes 是开源的。像 Omega 一样，Kubernetes 在其核心有一个被分享的持久存储，有组件来检测相关 object 的变化。跟 Omega 不同的是，Omega 把存储直接暴露给信任的控制平面的组件，而在 Kubernete 中，提供了完全由特定领域更高层面的版本控制、认证、语义、策略的 REST API 接口，以服务更多的用户。更重要的是，Kubernetes 是由一群底层开发能力更强的开发者开发的，他们主要的设计目标是用更容易的方法去部署和管理复杂的分布式系统，同时仍能从容器提升的效率中受益。")]),e._v(" "),t("p",[e._v("2014 年 Kubernetes 正式开源，2015 年被作为初创项目贡献给了云原生计算基金会（CNCF），从此开启了 Kubernetes 及云原生化的大潮。")]),e._v(" "),t("p",[e._v("2015年左右，Google在美国波特兰的OSCON 2015大会上宣布并正式发布Kubernetes 1.0。Google与Linux基金会合作组建了云原生计算基金会（CNCF）。CNCF旨在为云原生软件构建可持续发展的生态系统，并围绕一系列高质量开源项目建立社区，整合这些开源技术来让编排容器成为微服务架构的一部分。CNCF自创立以来已经拥有非常多的高质量项目，其中包括Kubernetes、Prometheus、gRPC、CoreDNS等。")]),e._v(" "),t("p",[e._v("2016年左右，Kubernetes成为主流。在CloudNativeCon 2016大会上，来自世界各地的约1000名贡献者和开发者齐聚一堂，交流有关Fluentd、Kubernetes、Prometheus、OpenTracing和其他云原生技术的内容。")]),e._v(" "),t("p",[e._v("2017年左右，互联网巨头纷纷表示支持Kubernetes。在这一年，Google和IBM发布微服务框架Istio，其提供了一种无缝连接、管理和保护不同微服务网格的方法。Amazon宣布为Kubernetes提供弹性容器服务，用户可以在AWS上使用Kubernetes部署、管理和扩展容器化应用程序。同年年底，Kubernetes 1.9发布。")]),e._v(" "),t("p",[e._v("2018年左右，无人不知Kubernetes。在KubeCon+CloudNativeCon Europe 2018峰会上，有超过4300名开发者聚集在一起讨论Kubernetes生态技术。同年，Kubernetes 1.10发布。KubeCon第一次在中国举办。")]),e._v(" "),t("p",[e._v("Kubernetes是Google公司开源的一个容器（Container）编排与调度管理框架，该项目最初是Google内部面向容器的集群管理系统，而现在是由Cloud Native Computing Foundation（CNCF，云原生计算基金会）托管的开源平台，由Google、AWS、Microsoft、IBM、Intel、Cisco和Red Hat等主要参与者支持，其目标是通过创建一组新的通用容器技术来推进云原生技术和服务的开发。作为领先的容器编排引擎，Kubernetes提供了一个抽象层，使其可以在物理或虚拟环境中部署容器应用程序，提供以容器为中心的基础架构。")]),e._v(" "),t("p",[e._v("Kubernetes系统拥有一个庞大而活跃的开发人员社区，这使其成为历史上增长最快的开源项目之一。它是GitHub上排名前10的项目，也是Go语言最大的开源项目之一，Kubernetes也被称为K8s，是通过将8个字母ubernete替换为8而形成的缩写。Kubernetes系统具有如下特点。")]),e._v(" "),t("p",[e._v("● 可移植：支持公有云、私有云、混合云、多重云（Multi-cloud）。")]),e._v(" "),t("p",[e._v("● 可扩展：模块化、插件化、可挂载、可组合。")]),e._v(" "),t("p",[e._v("● 自动化：自动部署、自动重启、自动复制、自动伸缩/扩展。")]),e._v(" "),t("h3",{attrs:{id:"架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[e._v("#")]),e._v(" 架构")]),e._v(" "),t("p",[e._v("Kubernetes系统用于管理分布式节点集群中的微服务或容器化应用程序，并且其提供了零停机时间部署、自动回滚、缩放和容器的自愈（其中包括自动配置、自动重启、自动复制的高弹性基础设施，以及容器的自动缩放等）等功能。")]),e._v(" "),t("p",[e._v("Kubernetes系统最重要的设计因素之一是能够横向扩展，即调整应用程序的副本数以提高可用性。设计一套大型系统，且保证其运行时健壮、可扩展、可移植和非常具有挑战性，尤其是在系统复杂度增加时，系统的体系结构会直接影响其运行方式、对环境的依赖程度及相关组件的耦合程度。")]),e._v(" "),t("p",[e._v("微服务是一种软件设计模式，适用于集群上的可扩展部署。开发人员使用这一模式能够创建小型、可组合的应用程序，通过定义良好的HTTP REST API接口进行通信。Kubernetes也是遵循微服务架构模式的程序，具有弹性、可观察性和管理功能，可以适应云平台的需求。")]),e._v(" "),t("p",[e._v("Kubernetes的系统架构设计与Borg的系统架构设计理念非常相似，如Scheduler调度器、Pod资源对象管理等。")]),e._v(" "),t("p",[e._v("Kubernetes系统架构遵循客户端/服务端（C/S）架构，系统架构分为Master和Node两部分，Master作为服务端，Node作为客户端。Kubernetes系统具有多个Master服务端，可以实现高可用。在默认的情况下，一个Master服务端即可完成所有工作。")]),e._v(" "),t("p",[e._v("Master服务端也被称为主控节点，它在集群中主要负责如下任务。")]),e._v(" "),t("p",[e._v("（1）集群的“大脑”，负责管理所有节点（Node）。")]),e._v(" "),t("p",[e._v("（2）负责调度Pod在哪些节点上运行。")]),e._v(" "),t("p",[e._v("（3）负责控制集群运行过程中的所有状态。")]),e._v(" "),t("p",[e._v("Node客户端也被称为工作节点，它在集群中主要负责如下任务。")]),e._v(" "),t("p",[e._v("（1）负责管理所有容器（Container）。")]),e._v(" "),t("p",[e._v("（2）负责监控/上报所有Pod的运行状态。")]),e._v(" "),t("p",[e._v("Master服务端（主控节点）主要负责管理和控制整个Kubernetes集群，对集群做出全局性决策，相当于整个集群的“大脑”。集群所执行的所有控制命令都由Master服务端接收并处理。Master服务端主要包含如下组件。")]),e._v(" "),t("p",[e._v("● kube-apiserver组件：集群的HTTP REST API接口，是集群控制的入口。")]),e._v(" "),t("p",[e._v("● kube-controller-manager组件：集群中所有资源对象的自动化控制中心。")]),e._v(" "),t("p",[e._v("● kube-scheduler组件：集群中Pod资源对象的调度服务。")]),e._v(" "),t("p",[e._v("Node客户端（工作节点）是Kubernetes集群中的工作节点，Node节点上的工作由Master服务端进行分配，比如当某个Node节点宕机时，Master节点会将其上面的工作转移到其他Node节点上。Node节点主要包含如下组件。")]),e._v(" "),t("p",[e._v("● kubelet组件：负责管理节点上容器的创建、删除、启停等任务，与Master节点进行通信。")]),e._v(" "),t("p",[e._v("● kube-proxy组件：负责Kubernetes服务的通信及负载均衡服务。")]),e._v(" "),t("p",[e._v("● container组件：负责容器的基础管理服务，接收kubelet组件的指令。")]),e._v(" "),t("p",[e._v("另外，作为开发者，还需要深入了解client-go库。不同组件之间是松耦合架构，各组件之间各司其职，保证整个集群的稳定运行。")]),e._v(" "),t("p",[e._v("Client-go")]),e._v(" "),t("p",[e._v("Kubernetes还提供了通过编程的方式与Kubernetes API Server进行通信。client-go是从Kubernetes的代码中单独抽离出来的包，并作为官方提供的Go语言的客户端发挥作用。client-go简单、易用，Kubernetes系统的其他组件与Kubernetes API Server通信的方式也基于client-go实现")]),e._v(" "),t("p",[e._v("在大部分基于Kubernetes做二次开发的程序中，建议通过client-go来实现与Kubernetes API Server的交互过程。这是因为client-go在Kubernetes系统上做了大量的优化，Kubernetes核心组件（如kube-scheduler、kube-controller-manager等）都通过client-go与Kubernetes API Server进行交互")]),e._v(" "),t("p",[e._v("熟练使用并掌握client-go是每个Kubernetes开发者必备的技能。")]),e._v(" "),t("p",[e._v("Kube-apiserver")]),e._v(" "),t("p",[e._v("kube-apiserver组件，也被称为Kubernetes API Server。它负责将Kubernetes“资源组/资源版本/资源”以RESTful风格的形式对外暴露并提供服务。Kubernetes集群中的所有组件都通过kube-apiserver组件操作资源对象。kube-apiserver组件也是集群中唯一与Etcd集群进行交互的核心组件。例如，开发者通过kubectl创建了一个Pod资源对象，请求通过kube-apiserver的HTTP接口将Pod资源对象存储至Etcd集群中。")]),e._v(" "),t("p",[e._v("Etcd集群是分布式键值存储集群，其提供了可靠的强一致性服务发现。Etcd集群存储Kubernetes系统集群的状态和元数据，其中包括所有Kubernetes资源对象信息、集群节点信息等。Kubernetes将所有数据存储至Etcd集群中前缀为/registry的目录下。")]),e._v(" "),t("p",[e._v("kube-apiserver属于核心组件，对于整个集群至关重要，它具有以下重要特性。")]),e._v(" "),t("p",[e._v("● 将Kubernetes系统中的所有资源对象都封装成RESTful风格的API接口进行管理。")]),e._v(" "),t("p",[e._v("● 可进行集群状态管理和数据管理，是唯一与Etcd集群交互的组件。")]),e._v(" "),t("p",[e._v("● 拥有丰富的集群安全访问机制，以及认证、授权及准入控制器。")]),e._v(" "),t("p",[e._v("● 提供了集群各组件的通信和交互功能。")]),e._v(" "),t("p",[e._v("Kube-controller-manager")]),e._v(" "),t("p",[e._v("kube-controller-manager组件，也被称为Controller Manager（管理控制器），它负责管理Kubernetes集群中的节点（Node）、Pod副本、服务、端点（Endpoint）、命名空间（Namespace）、服务账户（ServiceAccount）、资源定额（ResourceQuota）等。例如，当某个节点意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。")]),e._v(" "),t("p",[e._v("Controller Manager负责确保Kubernetes系统的实际状态收敛到所需状态，其默认提供了一些控制器（Controller），例如DeploymentControllers控制器、StatefulSet控制器、Namespace控制器及PersistentVolume控制器等，每个控制器通过kube-apiserver组件提供的接口实时监控整个集群每个资源对象的当前状态，当因发生各种故障而导致系统状态出现变化时，会尝试将系统状态修复到“期望状态”。")]),e._v(" "),t("p",[e._v("Controller Manager具备高可用性（即多实例同时运行），即基于Etcd集群上的分布式锁实现领导者选举机制，多实例同时运行，通过kube-apiserver提供的资源锁进行选举竞争。抢先获取锁的实例被称为Leader节点（即领导者节点），并运行kube-controller-manager组件的主逻辑；而未获取锁的实例被称为Candidate节点（即候选节点），运行时处于阻塞状态。在Leader节点因某些原因退出后，Candidate节点则通过领导者选举机制参与竞选，成为Leader节点后接替kube-controller-manager的工作。")]),e._v(" "),t("p",[e._v("Kube-scheduler")]),e._v(" "),t("p",[e._v("kube-scheduler组件，也被称为调度器，目前是Kubernetes集群的默认调度器。它负责在Kubernetes集群中为一个Pod资源对象找到合适的节点并在该节点上运行。调度器每次只调度一个Pod资源对象，为每一个Pod资源对象寻找合适节点的过程是一个调度周期。")]),e._v(" "),t("p",[e._v("kube-scheduler组件监控整个集群的Pod资源对象和Node资源对象，当监控到新的Pod资源对象时，会通过调度算法为其选择最优节点。调度算法分为两种，分别为预选调度算法和优选调度算法。除调度策略外，Kubernetes还支持优先级调度、抢占机制及亲和性调度等功能。")]),e._v(" "),t("p",[e._v("kube-scheduler组件支持高可用性（即多实例同时运行），即基于Etcd集群上的分布式锁实现领导者选举机制，多实例同时运行，通过kube-apiserver提供的资源锁进行选举竞争。抢先获取锁的实例被称为Leader节点（即领导者节点），并运行kube-scheduler组件的主逻辑；而未获取锁的实例被称为Candidate节点（即候选节点），运行时处于阻塞状态。在Leader节点因某些原因退出后，Candidate节点则通过领导者选举机制参与竞选，成为Leader节点后接替kube-scheduler的工作。")]),e._v(" "),t("p",[e._v("kubelet")]),e._v(" "),t("p",[e._v("kubelet组件，用于管理节点，运行在每个Kubernetes节点上。kubelet组件用来接收、处理、上报kube-apiserver组件下发的任务。kubelet进程启动时会向kube-apiserver注册节点自身信息。它主要负责所在节点（Node）上的Pod资源对象的管理，例如Pod资源对象的创建、修改、监控、删除、驱逐及Pod生命周期管理等。")]),e._v(" "),t("p",[e._v("kubelet组件会定期监控所在节点的资源使用状态并上报给kube-apiserver组件，这些资源数据可以帮助kube-scheduler调度器为Pod资源对象预选节点。kubelet也会对所在节点的镜像和容器做清理工作，保证节点上的镜像不会占满磁盘空间、删除的容器释放相关资源。")]),e._v(" "),t("p",[e._v("kubelet组件实现了3种开放接口:")]),e._v(" "),t("ul",[t("li",[e._v("Container Runtime Interface：简称CRI（容器运行时接口），提供容器运行时通用插件接口服务。CRI定义了容器和镜像服务的接口。CRI将kubelet组件与容器运行时进行解耦，将原来完全面向Pod级别的内部接口拆分成面向Sandbox和Container的gRPC接口，并将镜像管理和容器管理分离给不同的服务。")]),e._v(" "),t("li",[e._v("Container Network Interface：简称CNI（容器网络接口），提供网络通用插件接口服务。CNI定义了Kubernetes网络插件的基础，容器创建时通过CNI插件配置网络。")]),e._v(" "),t("li",[e._v("Container Storage Interface：简称CSI（容器存储接口），提供存储通用插件接口服务。CSI定义了容器存储卷标准规范，容器创建时通过CSI插件配置存储卷。")])]),e._v(" "),t("p",[e._v("Kube-proxy")]),e._v(" "),t("p",[e._v("kube-proxy组件，作为节点上的网络代理，运行在每个Kubernetes节点上。它监控kube-apiserver的服务和端点资源变化，并通过iptables/ipvs等配置负载均衡器，为一组Pod提供统一的TCP/UDP流量转发和负载均衡功能。")]),e._v(" "),t("p",[e._v("kube-proxy组件是参与管理Pod-to-Service和External-to-Service网络的最重要的节点组件之一。kube-proxy组件相当于代理模型，对于某个IP：Port的请求，负责将其转发给专用网络上的相应服务或应用程序。但是，kube-proxy组件与其他负载均衡服务的区别在于，kube-proxy代理只向Kubernetes服务及其后端Pod发出请求。")]),e._v(" "),t("h2",{attrs:{id:"基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),t("h3",{attrs:{id:"术语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[e._v("#")]),e._v(" 术语")]),e._v(" "),t("p",[e._v("CRD")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#crd",target:"_blank",rel:"noopener noreferrer"}},[e._v("CRD"),t("OutboundLink")],1),e._v("，全称 Custom Resource Definition（自定义资源定义）是默认的 Kubernetes API 扩展。")]),e._v(" "),t("p",[e._v("eBPF")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#ebpf",target:"_blank",rel:"noopener noreferrer"}},[e._v("eBPF"),t("OutboundLink")],1),e._v(" 是"),t("strong",[e._v("扩展的柏克莱封包过滤器")]),e._v("（extented Berkeley Packet Filter）的缩写，它是类 Unix 系统上数据链路层的一种原始接口，提供原始链路层封包的收发，除此之外，如果网卡驱动支持洪泛模式，那么它可以让网卡处于此种模式，这样可以收到网络上的所有包，不管他们的目的地是不是所在主机。")]),e._v(" "),t("p",[e._v("Mutual TLS Authentication")]),e._v(" "),t("p",[e._v("双向 TLS 通过内置身份和凭证管理，提供强大的服务到服务身份验证。 了解更多关于双向 TLS 身份验证。")]),e._v(" "),t("p",[e._v("OpenTracing")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#opentracing",target:"_blank",rel:"noopener noreferrer"}},[e._v("OpenTracing"),t("OutboundLink")],1),e._v(" 是一个分布式追踪标准规范，它定义了一套通用的数据上报接口，提供平台无关、厂商无关的 API，要求各个分布式追踪系统都来实现这套接口，使得开发人员能够方便的添加（或更换）追踪系统的实现。")]),e._v(" "),t("p",[e._v("Operator")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#operator",target:"_blank",rel:"noopener noreferrer"}},[e._v("Operator"),t("OutboundLink")],1),e._v(" 是打包、部署和管理 Kubernetes 应用程序的一种方法。")]),e._v(" "),t("p",[e._v("SNI")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#sni",target:"_blank",rel:"noopener noreferrer"}},[e._v("SNI"),t("OutboundLink")],1),e._v(" 全称 Server Name Indication（服务器名称指示），是 TLS 的扩展，用来解决一个服务器拥有多个域名的情况。")]),e._v(" "),t("p",[e._v("Sidecar")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#sidecar",target:"_blank",rel:"noopener noreferrer"}},[e._v("Sidecar"),t("OutboundLink")],1),e._v("，全称 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#sidecar",target:"_blank",rel:"noopener noreferrer"}},[e._v("Sidecar"),t("OutboundLink")],1),e._v(" proxy，为在应用程序旁运行的单独的进程，它可以为应用程序添加许多功能，而无需在应用程序中添加额外的第三方组件，或修改应用程序的代码或配置。")]),e._v(" "),t("p",[e._v("SPIFFE")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v("，即每个人的安全生产身份框架（Secure Production Identity Framework for Everyone），是一套开源标准，用于在动态和异构环境中安全地进行身份识别。采用 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v(" 的系统无论在哪里运行，都可以轻松可靠地相互认证。")]),e._v(" "),t("p",[e._v("SPIRE")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spire",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIRE"),t("OutboundLink")],1),e._v(" 是 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v(" API 的一个生产就绪的实现，用于执行节点和工作负载认证，以便根据一组预先定义的条件，安全地向工作负载发出 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#svid",target:"_blank",rel:"noopener noreferrer"}},[e._v("SVID"),t("OutboundLink")],1),e._v("，并验证其他工作负载的 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#svid",target:"_blank",rel:"noopener noreferrer"}},[e._v("SVID"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v(" ID")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v(" ID 是一个统一资源标识符（URI），其格式如下："),t("code",[e._v("spiffe://信任域/工作负载标识符")]),e._v("，用来唯一地、具体地标识一个工作负载。")]),e._v(" "),t("p",[e._v("SVID")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#svid",target:"_blank",rel:"noopener noreferrer"}},[e._v("SVID"),t("OutboundLink")],1),e._v("（"),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v(" Verifiable Identity Document） 是工作负载向资源或调用者证明其身份的"),t("strong",[e._v("文件")]),e._v("。"),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#svid",target:"_blank",rel:"noopener noreferrer"}},[e._v("SVID"),t("OutboundLink")],1),e._v(" 包含一个 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v(" ID，代表了服务的身份。它将 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/GLOSSARY.html#spiffe",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPIFFE"),t("OutboundLink")],1),e._v(" ID 编码在一个可加密验证的文件中。")]),e._v(" "),t("h3",{attrs:{id:"组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[e._v("#")]),e._v(" 组件")]),e._v(" "),t("h4",{attrs:{id:"控制平面组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制平面组件"}},[e._v("#")]),e._v(" 控制平面组件")]),e._v(" "),t("p",[e._v("Master组件提供集群的管理控制中心。")]),e._v(" "),t("p",[e._v("Master组件可以在集群中任何节点上运行。但是为了简单起见，通常在一台VM/机器上启动所有Master组件，并且不会在此VM/机器上运行用户容器。")]),e._v(" "),t("p",[e._v("kube-apiserver")]),e._v(" "),t("p",[e._v("API 服务器是 Kubernetes "),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane",target:"_blank",rel:"noopener noreferrer"}},[e._v("控制平面"),t("OutboundLink")],1),e._v("的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端")]),e._v(" "),t("p",[e._v("Kubernetes API 服务器的主要实现是 "),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/",target:"_blank",rel:"noopener noreferrer"}},[e._v("kube-apiserver"),t("OutboundLink")],1),e._v("。 "),t("code",[e._v("kube-apiserver")]),e._v(" 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 "),t("code",[e._v("kube-apiserver")]),e._v(" 的多个实例，并在这些实例之间平衡流量")]),e._v(" "),t("p",[e._v("Kube-scheduler")]),e._v(" "),t("p",[t("code",[e._v("kube-scheduler")]),e._v(" 是"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane",target:"_blank",rel:"noopener noreferrer"}},[e._v("控制平面"),t("OutboundLink")],1),e._v("的组件， 负责监视新创建的、未指定运行"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("节点（node）"),t("OutboundLink")],1),e._v("的 "),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pods"),t("OutboundLink")],1),e._v("， 并选择节点来让 Pod 在上面运行。")]),e._v(" "),t("p",[e._v("调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。")]),e._v(" "),t("p",[e._v("Kube-controller-manager")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/",target:"_blank",rel:"noopener noreferrer"}},[e._v("kube-controller-manager"),t("OutboundLink")],1),e._v(" 是"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane",target:"_blank",rel:"noopener noreferrer"}},[e._v("控制平面"),t("OutboundLink")],1),e._v("的组件， 负责运行"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/",target:"_blank",rel:"noopener noreferrer"}},[e._v("控制器"),t("OutboundLink")],1),e._v("进程。")]),e._v(" "),t("p",[e._v("从逻辑上讲， 每个"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/",target:"_blank",rel:"noopener noreferrer"}},[e._v("控制器"),t("OutboundLink")],1),e._v("都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。")]),e._v(" "),t("p",[e._v("这些控制器包括：")]),e._v(" "),t("ul",[t("li",[e._v("节点控制器(Node Controller): 负责在节点出现故障时进行通知和响应")]),e._v(" "),t("li",[e._v("任务控制器(Job Controller): 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成")]),e._v(" "),t("li",[e._v("端点分片控制器(EndpointSlice controller)：填充端点分片(EndpointSlice)对象(以提供 Service 和 Pod 之间的链接)。")]),e._v(" "),t("li",[e._v("服务账号控制器(ServiceAccount controller)：为新的命名空间创建默认的服务账号(ServiceAccount）。")])]),e._v(" "),t("p",[e._v("cloud-controller-manager")]),e._v(" "),t("p",[e._v("一个 Kubernetes "),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane",target:"_blank",rel:"noopener noreferrer"}},[e._v("控制平面"),t("OutboundLink")],1),e._v("组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器(Cloud Controller Manager)允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。")]),e._v(" "),t("p",[t("code",[e._v("cloud-controller-manager")]),e._v(" 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。")]),e._v(" "),t("p",[e._v("与 "),t("code",[e._v("kube-controller-manager")]),e._v(" 类似，"),t("code",[e._v("cloud-controller-manager")]),e._v(" 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。")]),e._v(" "),t("p",[e._v("下面的控制器都包含对云平台驱动的依赖：")]),e._v(" "),t("ul",[t("li",[e._v("节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除")]),e._v(" "),t("li",[e._v("路由控制器（Route Controller）：用于在底层云基础架构中设置路由")]),e._v(" "),t("li",[e._v("服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器")])]),e._v(" "),t("h4",{attrs:{id:"node组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node组件"}},[e._v("#")]),e._v(" Node组件")]),e._v(" "),t("p",[e._v("节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。")]),e._v(" "),t("p",[e._v("kubelet")]),e._v(" "),t("p",[t("code",[e._v("kubelet")]),e._v(" 会在集群中每个"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("节点（node）"),t("OutboundLink")],1),e._v("上运行。 它保证"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers",target:"_blank",rel:"noopener noreferrer"}},[e._v("容器（containers）"),t("OutboundLink")],1),e._v("都运行在 "),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pod"),t("OutboundLink")],1),e._v(" 中。")]),e._v(" "),t("p",[e._v("kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。")]),e._v(" "),t("p",[e._v("kube-proxy")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/",target:"_blank",rel:"noopener noreferrer"}},[e._v("kube-proxy"),t("OutboundLink")],1),e._v(" 是集群中每个"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("节点（node）"),t("OutboundLink")],1),e._v("上所运行的网络代理， 实现 Kubernetes "),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/",target:"_blank",rel:"noopener noreferrer"}},[e._v("服务（Service）"),t("OutboundLink")],1),e._v(" 概念的一部分。")]),e._v(" "),t("p",[e._v("kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。")]),e._v(" "),t("p",[e._v("如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。")]),e._v(" "),t("p",[e._v("运行时(Runtime)")]),e._v(" "),t("p",[e._v("容器运行环境是负责运行容器的软件。")]),e._v(" "),t("p",[e._v("Kubernetes 支持许多容器运行环境，例如 "),t("a",{attrs:{href:"https://containerd.io/docs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("containerd"),t("OutboundLink")],1),e._v("、 "),t("a",{attrs:{href:"https://cri-o.io/#what-is-cri-o",target:"_blank",rel:"noopener noreferrer"}},[e._v("CRI-O"),t("OutboundLink")],1),e._v(" 以及 "),t("a",{attrs:{href:"https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes CRI (容器运行环境接口)"),t("OutboundLink")],1),e._v(" 的其他任何实现。")]),e._v(" "),t("h5",{attrs:{id:"状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态"}},[e._v("#")]),e._v(" 状态")]),e._v(" "),t("p",[e._v("Node 包括如下状态信息：")]),e._v(" "),t("ul",[t("li",[e._v("Address\n"),t("ul",[t("li",[e._v("HostName：可以被 kubelet 中的 "),t("code",[e._v("--hostname-override")]),e._v(" 参数替代。")]),e._v(" "),t("li",[e._v("ExternalIP：可以被集群外部路由到的 IP 地址。")]),e._v(" "),t("li",[e._v("InternalIP：集群内部使用的 IP，集群外部无法访问。")])])]),e._v(" "),t("li",[e._v("Condition\n"),t("ul",[t("li",[e._v("OutOfDisk：磁盘空间不足时为 "),t("code",[e._v("True")])]),e._v(" "),t("li",[e._v("Ready：Node controller 40 秒内没有收到 node 的状态报告为 "),t("code",[e._v("Unknown")]),e._v("，健康为 "),t("code",[e._v("True")]),e._v("，否则为 "),t("code",[e._v("False")]),e._v("。")]),e._v(" "),t("li",[e._v("MemoryPressure：当 node 有内存压力时为 "),t("code",[e._v("True")]),e._v("，否则为 "),t("code",[e._v("False")]),e._v("。")]),e._v(" "),t("li",[e._v("DiskPressure：当 node 有磁盘压力时为 "),t("code",[e._v("True")]),e._v("，否则为 "),t("code",[e._v("False")]),e._v("。")])])]),e._v(" "),t("li",[e._v("Capacity\n"),t("ul",[t("li",[e._v("CPU")]),e._v(" "),t("li",[e._v("内存")]),e._v(" "),t("li",[e._v("可运行的最大 Pod 个数")])])]),e._v(" "),t("li",[e._v("Info：节点的一些版本信息，如 OS、kubernetes、docker 等")])]),e._v(" "),t("h4",{attrs:{id:"namespace"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#namespace"}},[e._v("#")]),e._v(" namespace")]),e._v(" "),t("p",[e._v("在一个 Kubernetes 集群中可以使用 namespace 创建多个 “虚拟集群”，这些 namespace 之间可以完全隔离，也可以通过某种方式，让一个 namespace 中的 service 可以访问到其他的 namespace 中的服务，我们 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-centos.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("在 CentOS 中部署 kubernetes1.6 集群"),t("OutboundLink")],1),e._v(" 的时候就用到了好几个跨越 namespace 的服务，比如 Traefik ingress 和 "),t("code",[e._v("kube-system")]),e._v("namespace 下的 service 就可以为整个集群提供服务，这些都需要通过 RBAC 定义集群级别的角色来实现")]),e._v(" "),t("p",[e._v("因为 namespace 可以提供独立的命名空间，因此可以实现部分的环境隔离。当你的项目和人员众多的时候可以考虑根据项目属性，例如生产、测试、开发划分不同的 namespace。")]),e._v(" "),t("p",[e._v("获取namespace")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("kubectl get ns\n")])])]),t("p",[e._v("集群中默认会有 "),t("code",[e._v("default")]),e._v(" 和 "),t("code",[e._v("kube-system")]),e._v(" 这两个 namespace。")]),e._v(" "),t("p",[e._v("在执行 "),t("code",[e._v("kubectl")]),e._v(" 命令时可以使用 "),t("code",[e._v("-n")]),e._v(" 指定操作的 namespace。")]),e._v(" "),t("p",[e._v("用户的普通应用默认是在 "),t("code",[e._v("default")]),e._v(" 下，与集群管理相关的为整个集群提供服务的应用一般部署在 "),t("code",[e._v("kube-system")]),e._v(" 的 namespace 下，例如我们在安装 kubernetes 集群时部署的 "),t("code",[e._v("kubedns")]),e._v("、"),t("code",[e._v("heapseter")]),e._v("、"),t("code",[e._v("EFK")]),e._v(" 等都是在这个 namespace 下面。")]),e._v(" "),t("p",[e._v("另外，并不是所有的资源对象都会对应 namespace，"),t("code",[e._v("node")]),e._v(" 和 "),t("code",[e._v("persistentVolume")]),e._v(" 就不属于任何 namespace。")]),e._v(" "),t("h4",{attrs:{id:"插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插件"}},[e._v("#")]),e._v(" 插件")]),e._v(" "),t("p",[e._v("插件使用 Kubernetes 资源（"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/",target:"_blank",rel:"noopener noreferrer"}},[e._v("DaemonSet"),t("OutboundLink")],1),e._v("、 "),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Deployment"),t("OutboundLink")],1),e._v(" 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 "),t("code",[e._v("kube-system")]),e._v(" 命名空间。")]),e._v(" "),t("p",[e._v("有几种标配的插件")]),e._v(" "),t("p",[e._v("DNS")]),e._v(" "),t("p",[e._v("尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有"),t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/",target:"_blank",rel:"noopener noreferrer"}},[e._v("集群 DNS"),t("OutboundLink")],1),e._v("， 因为很多示例都需要 DNS 服务。")]),e._v(" "),t("p",[e._v("集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。")]),e._v(" "),t("p",[e._v("Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。")]),e._v(" "),t("p",[e._v("Web界面")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dashboard"),t("OutboundLink")],1),e._v(" 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除")]),e._v(" "),t("p",[e._v("容器资源监控")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/",target:"_blank",rel:"noopener noreferrer"}},[e._v("容器资源监控"),t("OutboundLink")],1),e._v(" 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面。")]),e._v(" "),t("p",[e._v("集群层面日志")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/",target:"_blank",rel:"noopener noreferrer"}},[e._v("集群层面日志"),t("OutboundLink")],1),e._v("机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。")]),e._v(" "),t("h3",{attrs:{id:"控制器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制器"}},[e._v("#")]),e._v(" 控制器")]),e._v(" "),t("p",[e._v("Kubernetes 中内建了很多 controller（控制器），这些相当于一个状态机，用来控制 Pod 的具体状态和行为")]),e._v(" "),t("h4",{attrs:{id:"deployment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),t("p",[e._v("Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括：")]),e._v(" "),t("ul",[t("li",[e._v("定义 Deployment 来创建 Pod 和 ReplicaSet")]),e._v(" "),t("li",[e._v("滚动升级和回滚应用")]),e._v(" "),t("li",[e._v("扩容和缩容")]),e._v(" "),t("li",[e._v("暂停和继续 Deployment")])]),e._v(" "),t("p",[e._v("Deployment 为 Pod 和 Replica Set（下一代 Replication Controller）提供声明式更新。")]),e._v(" "),t("p",[e._v("您只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会帮您将 Pod 和 ReplicaSet 的实际状态改变到您的目标状态。您可以定义一个全新的 Deployment 来创建 ReplicaSet 或者删除已有的 Deployment 并创建一个新的来替换。")]),e._v(" "),t("p",[t("strong",[e._v("注意")]),e._v("：您不该手动管理由 Deployment 创建的 ReplicaSet，否则您就篡越了 Deployment controller 的职责！下文罗列了 Deployment 对象中已经覆盖了所有的用例。如果未有覆盖您所有需要的用例，请直接在 Kubernetes 的代码库中提 issue。")]),e._v(" "),t("p",[e._v("典型的用例如下：")]),e._v(" "),t("ul",[t("li",[e._v("使用 Deployment 来创建 ReplicaSet。ReplicaSet 在后台创建 pod。检查启动状态，看它是成功还是失败。")]),e._v(" "),t("li",[e._v("然后，通过更新 Deployment 的 PodTemplateSpec 字段来声明 Pod 的新状态。这会创建一个新的 ReplicaSet，Deployment 会按照控制的速率将 pod 从旧的 ReplicaSet 移动到新的 ReplicaSet 中。")]),e._v(" "),t("li",[e._v("如果当前状态不稳定，回滚到之前的 Deployment revision。每次回滚都会更新 Deployment 的 revision。")]),e._v(" "),t("li",[e._v("扩容 Deployment 以满足更高的负载。")]),e._v(" "),t("li",[e._v("暂停 Deployment 来应用 PodTemplateSpec 的多个修复，然后恢复上线。")]),e._v(" "),t("li",[e._v("根据 Deployment 的状态判断上线是否 hang 住了。")]),e._v(" "),t("li",[e._v("清除旧的不必要的 ReplicaSet。")])]),e._v(" "),t("h4",{attrs:{id:"statefulset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#statefulset"}},[e._v("#")]),e._v(" StatefulSet")]),e._v(" "),t("p",[e._v("StatefulSet 作为 Controller 为 Pod 提供唯一的标识。它可以保证部署和 scale 的顺序")]),e._v(" "),t("p",[e._v("StatefulSet 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计），其应用场景包括：")]),e._v(" "),t("ul",[t("li",[e._v("稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现")]),e._v(" "),t("li",[e._v("稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有 Cluster IP 的 Service）来实现")]),e._v(" "),t("li",[e._v("有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从 0 到 N-1，在下一个 Pod 运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现")]),e._v(" "),t("li",[e._v("有序收缩，有序删除（即从 N-1 到 0）")])]),e._v(" "),t("p",[e._v("从上面的应用场景可以发现，StatefulSet 由以下几个部分组成：")]),e._v(" "),t("ul",[t("li",[e._v("用于定义网络标志（DNS domain）的 Headless Service")]),e._v(" "),t("li",[e._v("用于创建 PersistentVolumes 的 volumeClaimTemplates")]),e._v(" "),t("li",[e._v("定义具体应用的 StatefulSet")])]),e._v(" "),t("p",[e._v("StatefulSet 中每个 Pod 的 DNS 格式为 "),t("code",[e._v("statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local")]),e._v("，其中")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("serviceName")]),e._v(" 为 Headless Service 的名字")]),e._v(" "),t("li",[t("code",[e._v("0..N-1")]),e._v(" 为 Pod 所在的序号，从 0 开始到 N-1")]),e._v(" "),t("li",[t("code",[e._v("statefulSetName")]),e._v(" 为 StatefulSet 的名字")]),e._v(" "),t("li",[t("code",[e._v("namespace")]),e._v(" 为服务所在的 namespace，Headless Servic 和 StatefulSet 必须在相同的 namespace")]),e._v(" "),t("li",[t("code",[e._v(".cluster.local")]),e._v(" 为 Cluster Domain")])]),e._v(" "),t("p",[e._v("使用StatefulSet")]),e._v(" "),t("p",[e._v("StatefulSet 适用于有以下某个或多个需求的应用：")]),e._v(" "),t("ul",[t("li",[e._v("稳定，唯一的网络标志。")]),e._v(" "),t("li",[e._v("稳定，持久化存储。")]),e._v(" "),t("li",[e._v("有序，优雅地部署和 scale。")]),e._v(" "),t("li",[e._v("有序，优雅地删除和终止。")]),e._v(" "),t("li",[e._v("有序，自动的滚动升级。")])]),e._v(" "),t("p",[e._v("在上文中，稳定是 Pod （重新）调度中持久性的代名词。 如果应用程序不需要任何稳定的标识符、有序部署、删除和 scale，则应该使用提供一组无状态副本的 controller 来部署应用程序，例如 "),t("a",{attrs:{href:"https://kubernetes.io/docs/concepts/workloads/controllers/deployment",target:"_blank",rel:"noopener noreferrer"}},[e._v("Deployment"),t("OutboundLink")],1),e._v(" 或 "),t("a",{attrs:{href:"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReplicaSet"),t("OutboundLink")],1),e._v(" 可能更适合您的无状态需求")]),e._v(" "),t("h4",{attrs:{id:"daemonset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#daemonset"}},[e._v("#")]),e._v(" DaemonSet")]),e._v(" "),t("p",[t("em",[e._v("DaemonSet")]),e._v(" 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。")]),e._v(" "),t("p",[e._v("使用 DaemonSet 的一些典型用法：")]),e._v(" "),t("ul",[t("li",[e._v("运行集群存储 daemon，例如在每个 Node 上运行 "),t("code",[e._v("glusterd")]),e._v("、"),t("code",[e._v("ceph")]),e._v("。")]),e._v(" "),t("li",[e._v("在每个 Node 上运行日志收集 daemon，例如 "),t("code",[e._v("fluentd")]),e._v("、"),t("code",[e._v("logstash")]),e._v("。")]),e._v(" "),t("li",[e._v("在每个 Node 上运行监控 daemon，例如 "),t("a",{attrs:{href:"https://github.com/prometheus/node_exporter",target:"_blank",rel:"noopener noreferrer"}},[e._v("Prometheus Node Exporter"),t("OutboundLink")],1),e._v("、"),t("code",[e._v("collectd")]),e._v("、Datadog 代理、New Relic 代理，或 Ganglia "),t("code",[e._v("gmond")]),e._v("。")])]),e._v(" "),t("p",[e._v("一个简单的用法是，在所有的 Node 上都存在一个 DaemonSet，将被作为每种类型的 daemon 使用。 一个稍微复杂的用法可能是，对单独的每种类型的 daemon 使用多个 DaemonSet，但具有不同的标志，和 / 或对不同硬件类型具有不同的内存、CPU 要求")]),e._v(" "),t("p",[e._v("DaemonSet 需要 "),t("code",[e._v("apiVersion")]),e._v("、"),t("code",[e._v("kind")]),e._v(" 和 "),t("code",[e._v("metadata")]),e._v(" 字段")]),e._v(" "),t("p",[e._v("与 DaemonSet 中的 Pod 进行通信，几种可能的模式如下：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Push")]),e._v("：配置 DaemonSet 中的 Pod 向其它 Service 发送更新，例如统计数据库。它们没有客户端。")]),e._v(" "),t("li",[t("strong",[e._v("NodeIP 和已知端口")]),e._v("：DaemonSet 中的 Pod 可以使用 "),t("code",[e._v("hostPort")]),e._v("，从而可以通过 Node IP 访问到 Pod。客户端能通过某种方法知道 Node IP 列表，并且基于此也可以知道端口。")]),e._v(" "),t("li",[t("strong",[e._v("DNS")]),e._v("：创建具有相同 Pod Selector 的 "),t("a",{attrs:{href:"https://kubernetes.io/docs/user-guide/services/#headless-services",target:"_blank",rel:"noopener noreferrer"}},[e._v("Headless Service"),t("OutboundLink")],1),e._v("，然后通过使用 "),t("code",[e._v("endpoints")]),e._v(" 资源或从 DNS 检索到多个 A 记录来发现 DaemonSet。")]),e._v(" "),t("li",[t("strong",[e._v("Service")]),e._v("：创建具有相同 Pod Selector 的 Service，并使用该 Service 访问到某个随机 Node 上的 daemon。（没有办法访问到特定 Node）")])]),e._v(" "),t("p",[e._v("更新DaemonSet")]),e._v(" "),t("p",[e._v("如果修改了 Node Label，DaemonSet 将立刻向新匹配上的 Node 添加 Pod，同时删除新近无法匹配上的 Node 上的 Pod。")]),e._v(" "),t("p",[e._v("可以修改 DaemonSet 创建的 Pod。然而，不允许对 Pod 的所有字段进行更新。当下次 Node（即使具有相同的名称）被创建时，DaemonSet Controller 还会使用最初的模板。")]),e._v(" "),t("p",[e._v("可以删除一个 DaemonSet。如果使用 "),t("code",[e._v("kubectl")]),e._v(" 并指定 "),t("code",[e._v("--cascade=false")]),e._v(" 选项，则 Pod 将被保留在 Node 上。然后可以创建具有不同模板的新 DaemonSet。具有不同模板的新 DaemonSet 将鞥能够通过 Label 匹配识别所有已经存在的 Pod。它不会修改或删除它们，即使是错误匹配了 Pod 模板。通过删除 Pod 或者 删除 Node，可以强制创建新的 Pod。")]),e._v(" "),t("p",[e._v("在 Kubernetes 1.6 或以后版本，可以在 DaemonSet 上 "),t("a",{attrs:{href:"https://kubernetes.io/docs/tasks/manage-daemon/update-daemon-set/",target:"_blank",rel:"noopener noreferrer"}},[e._v("执行滚动升级"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("h4",{attrs:{id:"job"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#job"}},[e._v("#")]),e._v(" Job")]),e._v(" "),t("p",[e._v("Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束。")]),e._v(" "),t("p",[e._v("Job Spec格式")]),e._v(" "),t("ul",[t("li",[e._v("spec.template 格式同 Pod")]),e._v(" "),t("li",[e._v("RestartPolicy 仅支持 Never 或 OnFailure")]),e._v(" "),t("li",[e._v("单个 Pod 时，默认 Pod 成功运行后 Job 即结束")]),e._v(" "),t("li",[t("code",[e._v(".spec.completions")]),e._v(" 标志 Job 结束需要成功运行的 Pod 个数，默认为 1")]),e._v(" "),t("li",[t("code",[e._v(".spec.parallelism")]),e._v(" 标志并行运行的 Pod 的个数，默认为 1")]),e._v(" "),t("li",[t("code",[e._v("spec.activeDeadlineSeconds")]),e._v(" 标志失败 Pod 的重试最大时间，超过这个时间不会继续重试")])]),e._v(" "),t("p",[e._v("所谓 Bare Pod 是指直接用 PodSpec 来创建的 Pod（即不在 ReplicaSet 或者 ReplicationController 的管理之下的 Pod）。这些 Pod 在 Node 重启后不会自动重启，但 Job 则会创建新的 Pod 继续任务。所以，推荐使用 Job 来替代 Bare Pod，即便是应用只需要一个 Pod。")]),e._v(" "),t("h4",{attrs:{id:"cronjob"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cronjob"}},[e._v("#")]),e._v(" CronJob")]),e._v(" "),t("p",[t("em",[e._v("Cron Job")]),e._v(" 管理基于时间的 "),t("a",{attrs:{href:"https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Job"),t("OutboundLink")],1),e._v("，即：")]),e._v(" "),t("ul",[t("li",[e._v("在给定时间点只运行一次")]),e._v(" "),t("li",[e._v("周期性地在给定时间点运行")])]),e._v(" "),t("p",[e._v("当前使用的 Kubernetes 集群，版本 >= 1.8（对 CronJob）。对于先前版本的集群，版本 < 1.8，启动 API Server（参考 "),t("a",{attrs:{href:"https://kubernetes.io/docs/admin/cluster-management/#turn-on-or-off-an-api-version-for-your-cluster",target:"_blank",rel:"noopener noreferrer"}},[e._v("为集群开启或关闭 API 版本"),t("OutboundLink")],1),e._v(" 获取更多信息）时，通过传递选项 "),t("code",[e._v("--runtime-config=batch/v2alpha1=true")]),e._v(" 可以开启 batch/v2alpha1 API。")]),e._v(" "),t("p",[e._v("典型的用法如下所示：")]),e._v(" "),t("ul",[t("li",[e._v("在给定的时间点调度 Job 运行")]),e._v(" "),t("li",[e._v("创建周期性运行的 Job，例如：数据库备份、发送邮件。")])]),e._v(" "),t("p",[e._v("Cron Job的spec文件")]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v(".spec.schedule")]),e._v("："),t("strong",[e._v("调度")]),e._v("，必需字段，指定任务运行周期，格式同 "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Cron",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cron"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[t("code",[e._v(".spec.jobTemplate")]),e._v("："),t("strong",[e._v("Job 模板")]),e._v("，必需字段，指定需要运行的任务，格式同 "),t("a",{attrs:{href:"https://jimmysong.io/kubernetes-handbook/concepts/job.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Job"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[t("code",[e._v(".spec.startingDeadlineSeconds")]),e._v(" ："),t("strong",[e._v("启动 Job 的期限（秒级别）")]),e._v("，该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限")])]),e._v(" "),t("li",[t("p",[t("code",[e._v(".spec.concurrencyPolicy")]),e._v("："),t("strong",[e._v("并发策略")]),e._v("，该字段也是可选的。它指定了如何处理被 Cron Job 创建的 Job 的并发执行。只允许指定下面策略中的一种：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Allow")]),e._v("（默认）：允许并发运行 Job")]),e._v(" "),t("li",[t("code",[e._v("Forbid")]),e._v("：禁止并发运行，如果前一个还没有完成，则直接跳过下一个")]),e._v(" "),t("li",[t("code",[e._v("Replace")]),e._v("：取消当前正在运行的 Job，用一个新的来替换")])]),e._v(" "),t("p",[e._v("注意，当前策略只能应用于同一个 Cron Job 创建的 Job。如果存在多个 Cron Job，它们创建的 Job 之间总是允许并发运行。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v(".spec.suspend")]),e._v(" ："),t("strong",[e._v("挂起")]),e._v("，该字段也是可选的。如果设置为 "),t("code",[e._v("true")]),e._v("，后续所有执行都会被挂起。它对已经开始执行的 Job 不起作用。默认值为 "),t("code",[e._v("false")]),e._v("。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v(".spec.successfulJobsHistoryLimit")]),e._v(" 和 "),t("code",[e._v(".spec.failedJobsHistoryLimit")]),e._v(" ："),t("strong",[e._v("历史限制")]),e._v("，是可选的字段。它们指定了可以保留多少完成和失败的 Job。")]),e._v(" "),t("p",[e._v("默认情况下，它们分别设置为 "),t("code",[e._v("3")]),e._v(" 和 "),t("code",[e._v("1")]),e._v("。设置限制的值为 "),t("code",[e._v("0")]),e._v("，相关类型的 Job 完成后将不会被保留")])])]),e._v(" "),t("p",[e._v("当然，也可以用 "),t("code",[e._v("kubectl run")]),e._v(" 来创建一个 CronJob")]),e._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[e._v("kubectl run hello "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("--schedule")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"*/1 * * * *"')]),e._v(" "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("--restart")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("OnFailure "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("--image")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("busybox -- /bin/sh "),t("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-c")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"date; echo Hello from the Kubernetes cluster"')]),e._v("\n")])])]),t("p",[e._v("限制")]),e._v(" "),t("p",[e._v("Cron Job 在每次调度运行时间内 "),t("em",[e._v("大概")]),e._v(" 会创建一个 Job 对象。我们之所以说 "),t("em",[e._v("大概")]),e._v(" ，是因为在特定的环境下可能会创建两个 Job，或者一个 Job 都没创建。我们尝试少发生这种情况，但却不能完全避免。因此，创建 Job 操作应该是 "),t("em",[e._v("幂等的")]),e._v("。")]),e._v(" "),t("p",[e._v("Job 根据它所创建的 Pod 的并行度，负责重试创建 Pod，并就决定这一组 Pod 的成功或失败。Cron Job 根本就不会去检查 Pod。")]),e._v(" "),t("p",[e._v("删除Cron Job")]),e._v(" "),t("h2",{attrs:{id:"ingress"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ingress"}},[e._v("#")]),e._v(" Ingress")]),e._v(" "),t("p",[e._v("Kubernetes 还为我们提供了一个非常重要的资源对象可以用来暴露服务给外部用户，那就是 "),t("code",[e._v("Ingress")]),e._v("。对于小规模的应用我们使用 NodePort 或许能够满足我们的需求，但是当你的应用越来越多的时候，你就会发现对于 NodePort 的管理就非常麻烦了，这个时候使用 Ingress 就非常方便了，可以避免管理大量的端口。")]),e._v(" "),t("p",[e._v("Ingress 其实就是从 Kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，可能你会觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新服务加入的时候怎么改 Nginx 配置？不可能让我们去手动更改或者滚动更新前端的 Nginx Pod 吧？那我们再加上一个服务发现的工具比如 consul 如何？貌似是可以，对吧？Ingress 实际上就是这样实现的，只是服务发现的功能自己实现了，不需要使用第三方的服务了，然后再加上一个域名规则定义，路由信息的刷新依靠 Ingress Controller 来提供。")]),e._v(" "),t("p",[e._v("Ingress Controller 可以理解为一个监听器，通过不断地监听 kube-apiserver，实时的感知后端 Service、Pod 的变化，当得到这些信息变化后，Ingress Controller 再结合 Ingress 的配置，更新反向代理"),t("a",{attrs:{href:"https://cloud.tencent.com/product/clb?from=10680",target:"_blank",rel:"noopener noreferrer"}},[e._v("负载均衡器"),t("OutboundLink")],1),e._v("，达到服务发现的作用。其实这点和服务发现工具 consul、 consul-template 非常类似。")]),e._v(" "),t("p",[e._v("ingress flow")]),e._v(" "),t("p",[e._v("现在可以供大家使用的 Ingress Controller 有很多，比如 traefik、nginx-controller、Kubernetes Ingress Controller for Kong、HAProxy Ingress controller，当然你也可以自己实现一个 Ingress Controller，现在普遍用得较多的是 traefik 和 nginx-controller，traefik 的性能较 nginx-controller 差，但是配置使用要简单许多，我们这里会重点给大家介绍 nginx-controller 的使用。")]),e._v(" "),t("h3",{attrs:{id:"nginx-ingress-controller"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx-ingress-controller"}},[e._v("#")]),e._v(" Nginx Ingress Controller")]),e._v(" "),t("p",[e._v("https://cloud.tencent.com/developer/article/1761376")]),e._v(" "),t("p",[e._v("NGINX Ingress Controller 是使用 Kubernetes Ingress 资源对象构建的，用 ConfigMap 来存储 Nginx 配置的一种 Ingress Controller 实现。")]),e._v(" "),t("p",[e._v("要使用 Ingress 对外暴露服务，就需要提前安装一个 Ingress Controller，我们这里就先来安装 NGINX Ingress Controller，由于 nginx-ingress 所在的节点需要能够访问外网，这样域名可以解析到这些节点上直接使用，所以需要让 nginx-ingress 绑定节点的 80 和 443 端口，所以可以使用 hostPort 来进行访问，当然对于线上环境来说为了保证高可用，一般是需要运行多个 nginx-ingress 实例的，然后可以用一个 nginx/haproxy 作为入口，通过 keepalived 来访问边缘节点的 vip 地址。")]),e._v(" "),t("p",[e._v("“所谓的边缘节点即集群内部用来向集群外暴露服务能力的节点，集群外部的服务通过该节点来调用集群内部的服务，边缘节点是集群内外交流的一个 Endpoint。“")]),e._v(" "),t("p",[e._v("URL rewrite")]),e._v(" "),t("p",[e._v("NGINX Ingress Controller 很多高级的用法可以通过 Ingress 对象的 "),t("code",[e._v("annotation")]),e._v(" 进行配置，比如常用的 URL Rewrite 功能，比如我们有一个 todo 的前端应用，代码位于 https://github.com/cnych/todo-app，直接部署这个应用进行测试：")]),e._v(" "),t("p",[e._v("Basic Auth")]),e._v(" "),t("p",[e._v("同样我们还可以在 Ingress Controller 上面配置一些基本的 Auth 认证，比如 Basic Auth，可以用 htpasswd 生成一个密码文件来验证身份验证")]),e._v(" "),t("p",[e._v("灰度发布")]),e._v(" "),t("p",[e._v("在日常工作中我们经常需要对服务进行版本更新升级，所以我们经常会使用到滚动升级、蓝绿发布、灰度发布等不同的发布操作。而 "),t("code",[e._v("ingress-nginx")]),e._v(" 支持通过 Annotations 配置来实现不同场景下的灰度发布和测试，可以满足金丝雀发布、蓝绿部署与 A/B 测试等业务场景。ingress-nginx 的 Annotations 支持以下 4 种 Canary 规则：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("nginx.ingress.kubernetes.io/canary-by-header")]),e._v("：基于 Request Header 的流量切分，适用于灰度发布以及 A/B 测试。当 Request Header 设置为 always 时，请求将会被一直发送到 Canary 版本；当 Request Header 设置为 never时，请求不会被发送到 Canary 入口；对于任何其他 Header 值，将忽略 Header，并通过优先级将请求与其他金丝雀规则进行优先级的比较。")]),e._v(" "),t("li",[t("code",[e._v("nginx.ingress.kubernetes.io/canary-by-header-value")]),e._v("：要匹配的 Request Header 的值，用于通知 Ingress 将请求路由到 Canary Ingress 中指定的服务。当 Request Header 设置为此值时，它将被路由到 Canary 入口。该规则允许用户自定义 Request Header 的值，必须与上一个 annotation (即：canary-by-header) 一起使用。")]),e._v(" "),t("li",[t("code",[e._v("nginx.ingress.kubernetes.io/canary-weight")]),e._v("：基于服务权重的流量切分，适用于蓝绿部署，权重范围 0 - 100 按百分比将请求路由到 Canary Ingress 中指定的服务。权重为 0 意味着该金丝雀规则不会向 Canary 入口的服务发送任何请求，权重为 100 意味着所有请求都将被发送到 Canary 入口。")]),e._v(" "),t("li",[t("code",[e._v("nginx.ingress.kubernetes.io/canary-by-cookie")]),e._v("：基于 cookie 的流量切分，适用于灰度发布与 A/B 测试。用于通知 Ingress 将请求路由到 Canary Ingress 中指定的服务的cookie。当 cookie 值设置为 always 时，它将被路由到 Canary 入口；当 cookie 值设置为 never 时，请求不会被发送到 Canary 入口；对于任何其他值，将忽略 cookie 并将请求与其他金丝雀规则进行优先级的比较。")])]),e._v(" "),t("p",[e._v("总的来说可以把以上的四个 annotation 规则划分为以下两类：")]),e._v(" "),t("ul",[t("li",[e._v("基于权重的 Canary 规则")]),e._v(" "),t("li",[e._v("基于用户请求的 Canary 规则")])]),e._v(" "),t("h3",{attrs:{id:"traefik-ingress-controller"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#traefik-ingress-controller"}},[e._v("#")]),e._v(" Traefik Ingress Controller")]),e._v(" "),t("h3",{attrs:{id:"kube-vip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kube-vip"}},[e._v("#")]),e._v(" kube-vip")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/kube-vip/kube-vip?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE1NTI2MDQsImZpbGVHVUlEIjoiMTZxOE00UkJ4UVU1dlBrNyIsImlhdCI6MTY4MTU1MjMwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjowfQ.3XN8pyiqaehgqCWYJsa6iO_1hAQgpGFcHEonGPW2I_M",target:"_blank",rel:"noopener noreferrer"}},[e._v("kube-vip"),t("OutboundLink")],1),e._v(" 是一个为 Kubernetes 集群内部和外部提供高可用和负载均衡的开源项目。")]),e._v(" "),t("p",[e._v("kube-vip 支持以静态 Pod 的形式运行在 Control Plane 节点上，这样就可以不需要部署 HAProxy + Keepalived 等传统的 LB 来保证高可用。")]),e._v(" "),t("p",[e._v("kube-vip 静态 Pod 通过 ARP 会话来识别每个节点上的其他主机，我们可以选择 BGP 或 ARP 来设置负载平衡器。在 ARP 模式下，会选出一个领导者，这个节点将继承虚拟 IP 并成为集群内负载均衡的 Leader，而在 BGP 模式下，所有节点都会通知 VIP 地址。")]),e._v(" "),t("p",[e._v("通过把 kube-vip 静态 Pod 的 yaml 文件配置到 cloud-init 的脚本中，当 cloud-init 命令执行的时候会把 kube-vip yaml 的相关内容写入到 control plane 节点机器上的 /etc/kubernetes/manifests/kube-vip.yaml 文件中。kubeadm 部署 control plane 节点的过程，在启动静态 Pod 的阶段，就会启动 kube-vip 服务")]),e._v(" "),t("p",[e._v("CAPI 通过 MHC 为集群定义节点故障替换信息，由 KCP 和 MD/MS 配合完成故障节点的替换工作")]),e._v(" "),t("p",[e._v("云原生可划分为容器与容器编排、应用开发与部署、服务治理、可观测性等"),t("a",{attrs:{href:"https://landscape.cncf.io/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE1NTI2MDQsImZpbGVHVUlEIjoiMTZxOE00UkJ4UVU1dlBrNyIsImlhdCI6MTY4MTU1MjMwNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjowfQ.3XN8pyiqaehgqCWYJsa6iO_1hAQgpGFcHEonGPW2I_M",target:"_blank",rel:"noopener noreferrer"}},[e._v("领域"),t("OutboundLink")],1),e._v("，每个领域一般有多种实现方案，云原生平台可以理解为是多个领域的有机整合。与此相似，Kubernetes 也可划分多个领域，网络、存储、容器，每个领域都有标准（CNI、CSI、CRI 等）和不同的实现方案。CAPI 有多种 Provider，每种 Provider 可以有多种实现。")])])}),[],!1,null,null,null);r.default=n.exports}}]);