<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Linux</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.88b3a504.css" as="style"><link rel="preload" href="/assets/js/app.f8154061.js" as="script"><link rel="preload" href="/assets/js/2.4cccd600.js" as="script"><link rel="preload" href="/assets/js/41.ab3f4971.js" as="script"><link rel="prefetch" href="/assets/js/10.54f00d7a.js"><link rel="prefetch" href="/assets/js/11.3da5b74a.js"><link rel="prefetch" href="/assets/js/12.7fee73d6.js"><link rel="prefetch" href="/assets/js/13.76868392.js"><link rel="prefetch" href="/assets/js/14.73742d11.js"><link rel="prefetch" href="/assets/js/15.5f9a7bea.js"><link rel="prefetch" href="/assets/js/16.bc63dc43.js"><link rel="prefetch" href="/assets/js/17.cf9ef8d3.js"><link rel="prefetch" href="/assets/js/18.813f3d8e.js"><link rel="prefetch" href="/assets/js/19.381f5e21.js"><link rel="prefetch" href="/assets/js/20.e6f846bb.js"><link rel="prefetch" href="/assets/js/21.699eb7d8.js"><link rel="prefetch" href="/assets/js/22.9b419f3a.js"><link rel="prefetch" href="/assets/js/23.9e2fcc0f.js"><link rel="prefetch" href="/assets/js/24.c0934c78.js"><link rel="prefetch" href="/assets/js/25.4d32001d.js"><link rel="prefetch" href="/assets/js/26.6a089853.js"><link rel="prefetch" href="/assets/js/27.b32725bd.js"><link rel="prefetch" href="/assets/js/28.a7d1db61.js"><link rel="prefetch" href="/assets/js/29.ee4f84ac.js"><link rel="prefetch" href="/assets/js/3.6608d946.js"><link rel="prefetch" href="/assets/js/30.c1000c38.js"><link rel="prefetch" href="/assets/js/31.694fd1d6.js"><link rel="prefetch" href="/assets/js/32.ac026d3a.js"><link rel="prefetch" href="/assets/js/33.c8ee999f.js"><link rel="prefetch" href="/assets/js/34.6663a77a.js"><link rel="prefetch" href="/assets/js/35.da0b5d07.js"><link rel="prefetch" href="/assets/js/36.75f20762.js"><link rel="prefetch" href="/assets/js/37.df31ffd6.js"><link rel="prefetch" href="/assets/js/38.848c2684.js"><link rel="prefetch" href="/assets/js/39.9a7a0d1a.js"><link rel="prefetch" href="/assets/js/4.9660033f.js"><link rel="prefetch" href="/assets/js/40.ca8e34ae.js"><link rel="prefetch" href="/assets/js/42.3f849176.js"><link rel="prefetch" href="/assets/js/43.9b90ce3e.js"><link rel="prefetch" href="/assets/js/44.196181d0.js"><link rel="prefetch" href="/assets/js/45.4ebcccbd.js"><link rel="prefetch" href="/assets/js/46.a68cdba9.js"><link rel="prefetch" href="/assets/js/47.d26979d7.js"><link rel="prefetch" href="/assets/js/48.f6c3543c.js"><link rel="prefetch" href="/assets/js/49.87b9dc0d.js"><link rel="prefetch" href="/assets/js/5.bbf68f26.js"><link rel="prefetch" href="/assets/js/50.0d956d0a.js"><link rel="prefetch" href="/assets/js/51.6d654f81.js"><link rel="prefetch" href="/assets/js/52.180028c6.js"><link rel="prefetch" href="/assets/js/53.688b8ed0.js"><link rel="prefetch" href="/assets/js/54.4760398b.js"><link rel="prefetch" href="/assets/js/55.79d61c82.js"><link rel="prefetch" href="/assets/js/56.22ba5d85.js"><link rel="prefetch" href="/assets/js/57.085d3e52.js"><link rel="prefetch" href="/assets/js/58.a778b7b9.js"><link rel="prefetch" href="/assets/js/59.2ea1a17d.js"><link rel="prefetch" href="/assets/js/6.690811ac.js"><link rel="prefetch" href="/assets/js/60.82c5f4a5.js"><link rel="prefetch" href="/assets/js/61.9851b4bf.js"><link rel="prefetch" href="/assets/js/62.e9ca8158.js"><link rel="prefetch" href="/assets/js/63.44d8baf4.js"><link rel="prefetch" href="/assets/js/64.df339ab2.js"><link rel="prefetch" href="/assets/js/65.ac505688.js"><link rel="prefetch" href="/assets/js/66.3af3b829.js"><link rel="prefetch" href="/assets/js/67.41c1aab0.js"><link rel="prefetch" href="/assets/js/68.5d9e177d.js"><link rel="prefetch" href="/assets/js/69.d3e85f6e.js"><link rel="prefetch" href="/assets/js/7.491a7910.js"><link rel="prefetch" href="/assets/js/70.4494003e.js"><link rel="prefetch" href="/assets/js/71.6e2116c7.js"><link rel="prefetch" href="/assets/js/72.49cda61b.js"><link rel="prefetch" href="/assets/js/73.e7e66ead.js"><link rel="prefetch" href="/assets/js/74.5e98329f.js"><link rel="prefetch" href="/assets/js/75.3dd401e4.js"><link rel="prefetch" href="/assets/js/76.aabec56b.js"><link rel="prefetch" href="/assets/js/77.95564de2.js"><link rel="prefetch" href="/assets/js/78.69634719.js"><link rel="prefetch" href="/assets/js/79.6fcc3d23.js"><link rel="prefetch" href="/assets/js/8.63bf7718.js"><link rel="prefetch" href="/assets/js/9.58039158.js">
    <link rel="stylesheet" href="/assets/css/0.styles.88b3a504.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="linux概述"><a href="#linux概述" class="header-anchor">#</a> Linux概述</h2> <p>在我看来，Linux是一个对软件开发非常友好的操作系统。它去除了很多windows下的杂质，保留了非常干净的系统。Mac系统也是与它有很多相似的地方，才这样好用。</p> <p></p> <h2 id="下载与安装"><a href="#下载与安装" class="header-anchor">#</a> 下载与安装</h2> <p>​       以linux为内核的有Ubuntu，Debian、Centos，操作方式大同小异</p> <p>​       因为linux是开源系统，所以在百度或者谷歌直接搜索ubuntu16.0，就能找到安装包。安装的时候找阿里镜像源，会下载的快一些。</p> <h2 id="修改镜像源和网络"><a href="#修改镜像源和网络" class="header-anchor">#</a> 修改镜像源和网络</h2> <p>清华大学镜像源网站：https://mirrors.tuna.tsinghua.edu.cn/</p> <h2 id="常用命令"><a href="#常用命令" class="header-anchor">#</a> 常用命令</h2> <p>查看进程</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">ps</span> aux
<span class="token function">ps</span> -elf
</code></pre></div><p>查看端口状态</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">lsof</span> -i:端口号
<span class="token comment">##查看tcp udp端口和进程等情况</span>
<span class="token function">netstat</span> -tunlp <span class="token operator">|</span> <span class="token function">grep</span> 端口号
<span class="token function">netstat</span> -ntlp <span class="token comment">## 查看当前所有tcp端口</span>
<span class="token function">netstat</span> -ntulp <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">80</span> <span class="token comment">##查看所有80端口使用情况</span>
<span class="token function">netstat</span> -l <span class="token comment">##只显示监听端口</span>
<span class="token function">netstat</span> -lt <span class="token comment">## 只列出所有监听TCP端口</span>
<span class="token function">netstat</span> -lu <span class="token comment">## 只列出所有监听UDP端口</span>
<span class="token function">netstat</span> -lx <span class="token comment">## 只列出所有监听UNIX端口</span>
<span class="token function">netstat</span> -pt <span class="token comment">## 在netstat输出中显示PIC和进程名称</span>
<span class="token function">netstat</span> -an <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">':80'</span> <span class="token comment">##找出运行在指定端口的进程</span>
</code></pre></div><p>服务器常用端口</p> <p>21 ftp ftp服务器所开放的端口，用于上传下载</p> <p>22 ssh 22端口就是ssh端口，用于通过命令行模式远程连接Linux系统的服务器</p> <p>25 SMTP SMTP服务器所开放的端口，用于发送邮件</p> <p>80 HTTP 用于网站服务例如IIS、Apache、Nginx等提供对外访问</p> <p>113 POP3 110端口是为POP3服务开放的</p> <p>143 IMAP 143端口主页用于Internet Message</p> <p>443 HTTPS 网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP</p> <p>3306 MySQL  3306端口是MySQL数据库的默认端口，用于MySQL对外提供服务</p> <p>8080 代理端口 8080端口同80端口，是被用于www代理服务的，可以实现网页浏览，经常在访问某个网站或使用代理服务器时会加上8080端口，此外Apache Tomcat web server默认服务端口就是8080</p> <p>清除端口进程</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">kill</span> <span class="token punctuation">[</span>信号<span class="token punctuation">]</span> PID//pid号
</code></pre></div><p>kill信号</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">kill</span> -0:程序退出时收到该信息
<span class="token function">kill</span> -1:挂掉电话线或者终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化
<span class="token function">kill</span> -2:表示结束进程，但不是强制性的，常用的ctrl+c就是发出一个kill -2命令
<span class="token function">kill</span> -3:退出
<span class="token function">kill</span> -9:杀死进程，即强制结束进程，有可能会导致程序崩溃等
<span class="token function">kill</span> -11:段错误
<span class="token function">kill</span> -15:正常结束进程，是kill命令段默认信号
</code></pre></div><p>删除文件/文件夹</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">rm</span> -f filename

<span class="token function">rm</span> -rf filename
</code></pre></div><p>set</p> <p>set命令用于设置shell</p> <p>关机/重启</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">## 立即关机</span>
<span class="token function">shutdown</span> -h now
<span class="token comment">## 10分钟后关机</span>
<span class="token function">shutdown</span> -h <span class="token number">10</span>
<span class="token comment">## 立刻关机</span>
power off
<span class="token comment">## 重启</span>
<span class="token function">reboot</span>
<span class="token comment">## 重启</span>
<span class="token function">shutdown</span> -r now
</code></pre></div><p>传输文件</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">## 从服务器上下载文件</span>
<span class="token function">scp</span> username@servernama:/path/filename /var/www/local_dir

<span class="token comment">## 上传文件到服务器</span>
<span class="token function">scp</span> /path/filename username@servernama:/path

<span class="token comment">## 下载目录</span>
<span class="token function">scp</span> -r username@servernama:/path/ /var/www/local_dir

<span class="token comment">## 上传目录</span>
<span class="token function">scp</span> -r /var/www/local_dir username@servernama:/path
</code></pre></div><p>修改文件</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">sed</span> <span class="token string">'s/properties/property/g'</span> build.xml
<span class="token comment">## 批量替换</span>
<span class="token function">grep</span> -ilr <span class="token string">'log('</span> *<span class="token operator">|</span>xargs-<span class="token operator">|</span>@ <span class="token function">sed</span> -i <span class="token string">&quot;'s/print(///Log(/g'@
## 
sed -i &quot;</span>s/hello/hi/g<span class="token string">&quot; test.txt
## 删除行首空格
sed -i 's/^ //g'test
## 删除行尾空格
sed -i 's/$//g' test
## 替换当前目录中所有含有hello字符的文件中的hello为hi
sed -i &quot;</span>s/hello/hi/g&quot; <span class="token variable"><span class="token variable">`</span><span class="token function">grep</span> <span class="token string">&quot;hello&quot;</span> -rl ./<span class="token variable">`</span></span>
<span class="token comment">## 批量操作当前目录以m开头的文件</span>
<span class="token function">sed</span> -i <span class="token string">'s/foo/bar/g'</span> ./m*
<span class="token comment">## 查找所有子目录中m开头的文件并进行替换</span>
<span class="token function">sed</span> -i <span class="token string">'s/foo/bar/g'</span> <span class="token variable"><span class="token variable">`</span><span class="token function">grep</span> foo -rl --include<span class="token operator">=</span><span class="token string">&quot;m*&quot;</span> ./<span class="token variable">`</span></span>
</code></pre></div><h3 id="systemd"><a href="#systemd" class="header-anchor">#</a> systemd</h3> <p>历史上，linux的启动一直采用init进程</p> <p>init进程有两个缺点：</p> <p>启动时间长、启动脚本复杂</p> <p>systemd就是为解决这个问题而生的，d是守护进程daemon的缩写。</p> <p>systemd取代了initd，成为了系统的第一个进程（pid等于1），其他进程都是它的子进程</p> <p>systemd的优点是功能强大，使用方便，缺点是体系庞大，非常复杂</p> <p>systemd的常用命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">## 重启系统</span>
<span class="token function">sudo</span> systemctl <span class="token function">reboot</span>
<span class="token comment">## 关闭系统，切断电源</span>
<span class="token function">sudo</span> systemctl poweroff
<span class="token comment">## cpu停止工作</span>
<span class="token function">sudo</span> systemctl <span class="token function">halt</span>
<span class="token comment">## 暂停系统</span>
<span class="token function">sudo</span> systemctl <span class="token function">suspend</span>
<span class="token comment">## 让系统进入冬眠状态</span>
<span class="token function">sudo</span> systemctl hibernate
<span class="token comment">## 让系统进入交互式休眠状态</span>
<span class="token function">sudo</span> systemctl hybrid-sleep
<span class="token comment">## 启动救援状态</span>
<span class="token function">sudo</span> systemctl rescue
</code></pre></div><p>查看本机信息</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">## 查看当前主机信息</span>
hostnamectl

<span class="token comment">## 设置主机名</span>
<span class="token function">sudo</span> hostnamectl set-hostname rhel7

<span class="token comment">## 查看本地化设置</span>
localectl

<span class="token comment">## 设置本地化参数</span>
<span class="token function">sudo</span> localectl set-locale <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_GB.utf8
<span class="token function">sudo</span> lccalectl set-keymap en_GB

<span class="token comment">## 查看当前登陆的用户</span>
loginctl list-users

<span class="token comment">## 列出当前session</span>
loginctl list-sessions

<span class="token comment">## 列出显示指定用户的信息</span>
loginctl show-user ruanyf

<span class="token comment">## 查看当前时区设置</span>
timedatectl 

<span class="token comment">## 显示所有可用的时区</span>
timedatectl list-timezones

<span class="token comment">## 设置当前时区</span>
<span class="token function">sudo</span> timedatectl set-timezone America/New_York
<span class="token function">sudo</span> timedatectl set-time YYYY-MM-DD
<span class="token function">sudo</span> timedatectl set-time HH:MM:SS
</code></pre></div><p>查看Unit信息</p> <p>nohup命令</p> <p>nohup命令用于在后台不挂断地运行命令，挂起进程，退出终端不会影响程序的运行</p> <p>nohup命令在默认情况下，也就是非重定向时，会输出一个名叫nohup。out的文件到当前目录，如果当前目录到nohup。out文件不可写，输出到HOME/nohu。pout文件中</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">nohup</span> ./nebula-httpd <span class="token operator">&amp;</span>
</code></pre></div><h4 id="node应用的systemd启动"><a href="#node应用的systemd启动" class="header-anchor">#</a> node应用的systemd启动</h4> <p>创建配置文件,后缀为service</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>node simple server

<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token comment">##启动命令</span>
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>
<span class="token assign-left variable">Restart</span><span class="token operator">=</span>always
<span class="token assign-left variable">User</span><span class="token operator">=</span>nobody
<span class="token assign-left variable">Group</span><span class="token operator">=</span>nobody
<span class="token assign-left variable">Environment</span><span class="token operator">=</span><span class="token environment constant">PATH</span><span class="token operator">=</span>/usr/bin:/user/local/bin
<span class="token assign-left variable">Environment</span><span class="token operator">=</span>NODE_ENV<span class="token operator">=</span>production
<span class="token assign-left variable">WorkingDirectory</span><span class="token operator">=</span>/tmp/node-systemd-demo

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target
</code></pre></div><p>将配置文件拷贝到systemd之中</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">sudo</span> <span class="token function">cp</span> node-server.service /etc/systemd/system
</code></pre></div><p>重载配置文件</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">sudo</span> systemctl daemon-reload
</code></pre></div><h3 id="什么命令都不能用了"><a href="#什么命令都不能用了" class="header-anchor">#</a> 什么命令都不能用了</h3> <p>环境变量配置错误造成的，输入</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/sbin:usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
</code></pre></div><p>或者手动在/etc/profile中添加此行</p> <h2 id="用户"><a href="#用户" class="header-anchor">#</a> 用户</h2> <p>普通用户可以用sudo</p> <p>如果提示不再sudoers文件中，在sudoers文件中添加用户</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /etc/sudoers
</code></pre></div><p>添加语句</p> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token attr-name">username</span> <span class="token attr-value">ALL=(ALL)  ALL</span>
</code></pre></div><h2 id="连接"><a href="#连接" class="header-anchor">#</a> 连接</h2> <p>linux最重要的用途还是服务器吧，目前绝大多数服务器都是linux系统。centos或者ubuntu、debian，在本地可以远程连接服务器进行操作</p> <p>通过密码连接服务器</p> <p>直接输入命令</p> <div class="language-linux extra-class"><pre class="language-text"><code>ssh 用户名@IP地址 -p 端口号
</code></pre></div><p>运行后会要求输入密码，输入即可登录</p> <p>通过密钥连接服务器</p> <p>首先在服务器端创建密钥对，下载私钥</p> <p>将私钥保存在.ssh文件下，如果没有.ssh目录，创建一个</p> <div class="language-mac extra-class"><pre class="language-text"><code>cd ~
mkdir .ssh
</code></pre></div><p>修改密钥权限</p> <div class="language-mac extra-class"><pre class="language-text"><code>cd ~/.ssh
chmod 400 密钥文件名
</code></pre></div><p>通过ssh密钥方式连接服务器</p> <div class="language-linux extra-class"><pre class="language-text"><code>ssh -i ~/.ssh/mac root@192.168.0.1
</code></pre></div><p>~/.ssh/mac为下载的私钥的路径和文件名</p> <p>root是服务器端管理员账号，一般是root</p> <p>192.168.0.1是服务器的公网ip</p> <p>终端变成root就说明连接成功</p> <p>让mac终端始终保持与远程连接状态（Broken pipe）</p> <div class="language-linux extra-class"><pre class="language-text"><code>sudo vim /etc/ssh/ssh_config
</code></pre></div><p>添加设置</p> <div class="language-linux extra-class"><pre class="language-text"><code># 断开时重试连接的次数
ServerAliveCountMax 5
# 每隔5s发送一个空请求以保持连接
ServerAliveInterval 5
</code></pre></div><h2 id="快捷键"><a href="#快捷键" class="header-anchor">#</a> 快捷键</h2> <p>启动终端：ctrl+alt+T</p> <p>​        创建目录：mkdir</p> <p>​        返回上层目录：cd ..</p> <p>​        停止运行：Ctrl+c</p> <p>​        关闭终端   Ctrl+alt+Q</p> <p>​        新建终端   Ctrl+alt+N</p> <h2 id="增加cpu占有率"><a href="#增加cpu占有率" class="header-anchor">#</a> 增加CPU占有率</h2> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token punctuation">$(</span>cat/proc/cpuinfo <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">&quot;physical id&quot;</span> <span class="token operator">|</span><span class="token function">wc</span> -l<span class="token punctuation">)</span><span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/null <span class="token operator">&amp;</span> <span class="token keyword">done</span>
</code></pre></div><h2 id="centos"><a href="#centos" class="header-anchor">#</a> centos</h2> <p>查找操作系统的内核版本</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">uname</span> -r
</code></pre></div><p>更新系统底层的库文件</p> <div class="language-centos extra-class"><pre class="language-text"><code>yum update
</code></pre></div><h2 id="vim"><a href="#vim" class="header-anchor">#</a> Vim</h2> <p>vim命令</p> <div class="language-vim extra-class"><pre class="language-vim"><code><span class="token punctuation">:</span><span class="token keyword">w</span> 保存文件但不退出<span class="token keyword">vim</span> 
<span class="token punctuation">:</span><span class="token keyword">w</span><span class="token operator">!</span> 强制保存文件但不退出<span class="token keyword">vim</span> 
<span class="token punctuation">:</span><span class="token keyword">wq</span> 保存文件并退出<span class="token keyword">vim</span>
<span class="token punctuation">:</span><span class="token keyword">wq</span><span class="token operator">!</span>强制保存文件并退出<span class="token keyword">vim</span>
<span class="token punctuation">:</span><span class="token keyword">q</span> 不保存文件直接退出
<span class="token punctuation">:</span><span class="token keyword">q</span><span class="token operator">!</span> 不保存文件强制退出<span class="token keyword">vim</span>
<span class="token punctuation">:</span><span class="token keyword">e</span><span class="token operator">!</span> 放弃所有修改，从上次保存文件开始再编辑命令历史
</code></pre></div><h2 id="linux下软件包"><a href="#linux下软件包" class="header-anchor">#</a> linux下软件包</h2> <p>linux下应用程序的软件包按<strong>内容类别</strong>分为两类：</p> <p>1.可执行文件(编译后的二进制软件包)</p> <p>解压包之后就可以直接运行，类似于windows下的软件包，安装完可以直接使用，但是看不到源程序，而且下载时要注意这个软件是否是你所使用的平台，否则无法正常安装，如centos与ubuntu</p> <p>优点：使用简单，只需要几个命令就能实现软件包的安装、卸载、升级、查询，安装速度快</p> <p>缺点：不能看源代码，功能选择不如源代码灵活，依赖性</p> <p>2.源程序(源码包)</p> <p>解开包之后你还需要使用编译器将其编译为可执行文件，这是linux独有的，windows的思想是不开放源程序</p> <p>优点：开源，可以自由选择所需功能，可看源码，卸载方便</p> <p>缺点：安装步骤过多，编译时间过长</p> <p>二进制软件包与源码包区别：</p> <p>与直接从源代码安装相比，软件包管理易于安装和卸载，易于更新已安装的软件包，易于保护配置文件，易于跟踪已安装文件</p> <p>通常用tar打包的都是源程序，用rpm、dpkg打包的则常是可执行程序，一般来说，自己动手打包源程序更具灵活性，但是容易遇到各种问题，而可执行程序包更容易安装，但是灵活性会差很多，所以一般一个软件会提供多种打包格式的安装程序。</p> <p>linux下应用程序的软件包按<strong>格式</strong>分类：</p> <p>linux下的软件安装包主要有rpm、deb、tar.gz三种格式</p> <p>软件后缀为.rpm最初是Red Hat Linux提供的一种包封装格式，rpm较deb发行早，所以现在许多linux发行版本都使用。rpm包本质就是一个可以在特定机器上运行的Linux软件，可以在红帽Linux、Suse、Fedora直接进行安装，但在Ubuntu上无法识别</p> <p>软件后缀为.deb是Debian linux提供的包封装格式。deb的包管理器dpkg只在debian上有，ubuntu也支持，可以在ubuntu上进行安装</p> <p>软件后缀.tar.gz、tar.Z、tar.bz2、.tgz是使用unix系统打包工具tar打包的。tar包在所有Linux版本中都能运行，但是安装过程也最麻烦，tar包就是一个压缩包，是为了便于传输所产生的一种专门用于网络流通的文件格式，tar包与deb、rpm包相比，tar包不一定是软件，也可能是图片、文本等等</p> <p>软件后缀为.bin的一般是一些商业软件</p> <h3 id="安装方法"><a href="#安装方法" class="header-anchor">#</a> 安装方法</h3> <p>rpm包：</p> <p>查询系统中所有的rpm包</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">rpm</span> -qa

<span class="token comment">## 查询所有包含某个字符串sql的软件包</span>
<span class="token function">rpm</span> -qa <span class="token operator">|</span><span class="token function">grep</span> sql
</code></pre></div><p>安装</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">rpm</span> -i your-package.rpm
<span class="token comment">## 强制安装</span>
<span class="token function">rpm</span> -i --force your-package.rpm
</code></pre></div><p>卸载（后缀不能包含rpm）</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">rpm</span> -e your-package
</code></pre></div><p>升级软件包</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">rpm</span> -Uvh your-package.rpm
</code></pre></div><p>安装rpm-build</p> <div class="language-shell extra-class"><pre class="language-shell"><code>yum list <span class="token operator">|</span><span class="token function">grep</span> rpm-build
yum <span class="token function">install</span> -y rpm-build.x86_64
</code></pre></div><p>tar包：</p> <h3 id="下载方法"><a href="#下载方法" class="header-anchor">#</a> 下载方法</h3> <p>wget可以下载整个页面和文件</p> <p>wget会遵守robots.txt文件。</p> <div class="language-shell extra-class"><pre class="language-shell"><code> <span class="token function">wget</span> -r -p -e <span class="token assign-left variable">robots</span><span class="token operator">=</span>off http://www.example.com
</code></pre></div><h3 id="安装cmake"><a href="#安装cmake" class="header-anchor">#</a> 安装cmake</h3> <p>准备编译环境</p> <div class="language-shell extra-class"><pre class="language-shell"><code>yum -y <span class="token function">install</span> gcc gcc-c++
</code></pre></div><p>获取源码并解压</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">wget</span> https://github.com/Kitware/CMake/releases/download/3.15.5/cmake-3.15.5.tar.gz
<span class="token comment">## 备用下载地址 https://down.24kplus.com/linux/cmake/cmake-3.15.5.tar.gz</span>

<span class="token function">tar</span> -zxf cmake-3.15.5.tar.gz

<span class="token builtin class-name">cd</span> cmake-3.15.5
</code></pre></div><p>编译安装</p> <div class="language-shell extra-class"><pre class="language-shell"><code>./bootstrap --prefix<span class="token operator">=</span>/usr --datadir<span class="token operator">=</span>share/cmake --docdir<span class="token operator">=</span>doc/cmake <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> 
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre></div><p>验证安装</p> <div class="language-shell extra-class"><pre class="language-shell"><code>cmake --version
</code></pre></div><h3 id="rpm-build"><a href="#rpm-build" class="header-anchor">#</a> rpm-build</h3> <p>如果你想打包rpm包，可能还需要rpm-build包</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">sudo</span> yum <span class="token function">install</span> rpm-build 
</code></pre></div><h2 id="selinux"><a href="#selinux" class="header-anchor">#</a> Selinux</h2> <p>安全增强型 Linux（SELinux）是一种采用安全架构的 <a href="https://www.redhat.com/zh/topics/linux/what-is-linux" target="_blank" rel="noopener noreferrer">Linux® 系统<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，它能够让管理员更好地管控哪些人可以访问系统。它最初是作为 <a href="https://www.redhat.com/zh/topics/linux/what-is-the-linux-kernel" target="_blank" rel="noopener noreferrer">Linux 内核<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的一系列补丁，由美国国家安全局（NSA）利用 Linux 安全模块（LSM）开发而成。</p> <p>SELinux 于 2000 年发布到开源社区，并于 2003 年集成到上游 Linux 内核中。</p> <p>SELinux 定义了每个人对系统上的应用、进程和文件的访问权限。它利用安全策略（一组告知 SELinux 哪些能访问，哪些不能访问的规则）来强制执行策略所允许的访问。</p> <p>当应用或进程（称为主体）发出访问对象（如文件）的请求时，SELinux 会检查访问向量缓存（AVC），其中缓存有主体和对象的访问权限。</p> <p>查看selinux状态</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">## 命令1</span>
/usr/sbin/sestatus -v
<span class="token comment">## SELinux status:                 enabled</span>
<span class="token comment">## 命令2</span>
getenforce
</code></pre></div><p>临时关闭</p> <div class="language-shell extra-class"><pre class="language-shell"><code>setenforce <span class="token number">0</span> <span class="token comment">##设置SELinux 成为permissive模式</span>
<span class="token comment">##setenforce 1 设置SELinux 成为enforcing模式</span>
</code></pre></div><p>也可以修改/etc/selinux/config 文件</p> <p>将SELINUX=enforcing改为SELINUX=disabled</p> <h2 id="firewalld和utf"><a href="#firewalld和utf" class="header-anchor">#</a> firewalld和utf</h2> <h3 id="全局端口转发"><a href="#全局端口转发" class="header-anchor">#</a> 全局端口转发</h3> <p>iptables 是一个配置 Linux 内核 防火墙 的命令行工具，是 netfilter 项目的一部分。
术语 iptables 也经常代指该内核级防火墙。
iptables 用于 ipv4，ip6tables 用于 ipv6。
需要root账户执行以下操作</p> <p>开启iptables</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">&gt;</span>/proc/sys/net/ipv4/ip_forward
</code></pre></div><p>默认值0是禁止ip转发，修改为1即开启ip转发功能。</p> <p>简单转发</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#-- 把访问本机 8091 端口的请求转发到 8090端口</span>
$ iptables -t nat -A PREROUTING -p tcp --dport <span class="token number">8091</span> -j REDIRECT --to-ports <span class="token number">8090</span>
<span class="token comment">#-- 把访问本机 8093 端口的请求转发到 192.168.1.3 的 8090端口</span>
$ iptables -t nat -A PREROUTING -i eth0 -p tcp --dport <span class="token number">8093</span> -j DNAT --to <span class="token number">192.168</span>.1.3:8090
</code></pre></div><h2 id="定时执行脚本"><a href="#定时执行脚本" class="header-anchor">#</a> 定时执行脚本</h2> <p>crontab可以在指定的时间执行一个shell脚本以及一系列Linux命令</p> <p>常用于定时备份数据库、日志等</p> <p>常用命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">crontab</span> -e     <span class="token comment">##修改crontab文件，</span>
<span class="token function">crontab</span> -l     <span class="token comment">##显示crontab文件</span>
<span class="token function">crontab</span> -r     <span class="token comment">##删除crontab文件</span>
<span class="token function">crontab</span> -ir    <span class="token comment">##删除crontab文件之前提醒用户</span>

<span class="token function">service</span> crond status
<span class="token function">service</span> crond start
<span class="token function">service</span> crond stop
<span class="token function">service</span> crond restart
<span class="token function">service</span> crond reload
</code></pre></div><p>基本格式</p> <div class="language-shell extra-class"><pre class="language-shell"><code>* * * * * <span class="token builtin class-name">command</span>
<span class="token comment">#分 时 日 月 周 + 命令</span>
<span class="token number">10</span> <span class="token number">0</span> * * * <span class="token builtin class-name">command</span> ./a.sh
<span class="token comment">## 每天0点10分执行命令</span>
</code></pre></div><h2 id="apache"><a href="#apache" class="header-anchor">#</a> Apache</h2> <p>apache在linux下的文件是httpd，centos自带apache,文件目录为cd/etc/init.d</p> <p>启动apache服务</p> <div class="language-centos extra-class"><pre class="language-text"><code>service httpd start
service httpd restart
service httpd stop
</code></pre></div><h2 id="部署项目"><a href="#部署项目" class="header-anchor">#</a> 部署项目</h2> <h3 id="react"><a href="#react" class="header-anchor">#</a> react</h3> <p>system limit for number of file watchers reached</p> <p>文件监控数量超过了系统限制，直接修改系统参数</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">cat</span> /proc/sys/fs/inotify/max_user_matches
<span class="token comment">##8192</span>
<span class="token function">sudo</span> <span class="token function">vim</span> /etc/sysctl.conf

<span class="token comment">## 添加语句 fs.inotify.max_user_watches=524288</span>

<span class="token function">sudo</span> sysctl -p 

<span class="token function">cat</span> /proc/sys/fs/inotify/max_user_matches
<span class="token comment">##524288</span>
</code></pre></div><h3 id="node"><a href="#node" class="header-anchor">#</a> Node</h3> <p>运行命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">## 14.*</span>
<span class="token function">curl</span> -sL https://rpm.nodesource.com/setup_14.x <span class="token operator">|</span> <span class="token function">bash</span> -
<span class="token comment">## 12.*</span>
<span class="token function">curl</span> -sL https://rpm.nodesource.com/setup_12.x <span class="token operator">|</span> <span class="token function">bash</span> -

yum -y <span class="token function">install</span> nodejs

<span class="token comment">## 安装gcc插件</span>
yum <span class="token function">install</span> gcc-c++ cmake
</code></pre></div><h2 id="服务器翻墙github太慢问题"><a href="#服务器翻墙github太慢问题" class="header-anchor">#</a> 服务器翻墙GitHub太慢问题</h2> <p>使用代理网址https://github.com.cnpmjs.org/</p> <h2 id="linux端口无法访问问题排查"><a href="#linux端口无法访问问题排查" class="header-anchor">#</a> linux端口无法访问问题排查</h2> <p>1.确认服务器的项目部署成功</p> <p>2.确认访问地址是否存在。访问地址和端口是否正常。</p> <p>3.确定服务器安全规则是否添加了要访问的端口。在控制台检查安全规则。</p> <p>4.连接服务器的用户。一般服务器有root管理员，和其他个人创建用户。</p> <p>5.服务器防火墙问题。服务器一般配置80端口为开放端口，在外网访问服务器80端口</p> <p>使用telnet判断端口是否可以访问</p> <div class="language-shell extra-class"><pre class="language-shell"><code>telnet <span class="token number">47.49</span>.182.93:7001
</code></pre></div><p></p> <h2 id="docker"><a href="#docker" class="header-anchor">#</a> docker</h2> <p>Docker作为容器管理的平台，早已在服务部署等领域有非常广泛的应用。容器是轻量级的虚拟化方案，依托于overlayfs、Linux下的namespace、cgroups等OS级别的虚拟化技术，性能相比于基于VM的虚拟化更加突出。</p> <p>更重要的是，通过Docker安装和配置软件更加方便</p> <p>移除可能有旧的Docker版本</p> <div class="language-shell extra-class"><pre class="language-shell"><code>yum erase -y docker docker-common docker-engine
</code></pre></div><p>安装工具包和依赖，设置仓库源</p> <div class="language-linux extra-class"><pre class="language-text"><code>yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager \ 
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre></div><p>使用yum安装docker-ce</p> <div class="language-linux extra-class"><pre class="language-text"><code>##最新稳定版
yum install docker-ce docker-ce-cli containerd.io
##指定版本
yum install docker-ce-18.09.6 docker-ce-cli-18.09.6 containerd.io
</code></pre></div><p>启动docker服务</p> <div class="language-centos extra-class"><pre class="language-text"><code>systemctl start docker
</code></pre></div><p>检查docker的信息和版本</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker version
docker info
</code></pre></div><p>验证docker，通过下载镜像和创建容器来看看Docker是否可以运转起来。可以使用下面的命令从Docker的镜像仓库下载名为hello-world的镜像文件。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker pull hello-world
</code></pre></div><p>docker安装容器</p> <div class="language-dockerfile extra-class"><pre class="language-dockerfile"><code>docker pull gitlab/gitlab<span class="token punctuation">-</span>ce
</code></pre></div><p>如果docker拉取较慢更换docker源，docker默认为docker国内镜像，可以腾讯源、中科大源或者dcloud</p> <p>启动容器</p> <div class="language-dockerfile extra-class"><pre class="language-dockerfile"><code>docker run 
</code></pre></div><p>查看容器</p> <h2 id="v2ray"><a href="#v2ray" class="header-anchor">#</a> V2ray</h2> <p>一键安装脚本</p> <div class="language-linux extra-class"><pre class="language-text"><code>bash &lt;(curl -s -L https://git.io/v2ray.sh)
</code></pre></div><p>运行后自动安装，安装过程中：</p> <p>输入1进行安装</p> <p>选择tcp协议（默认）</p> <p>选择端口号：为了不和别的软件冲突，推荐使用10000以上不超过65535的端口号，我选的10086</p> <p>广告拦截：是否开启广告拦截，推荐不要开启，开启广告拦截会消耗服务器资源，且国外环境略由于国内环境</p> <p>配置shadowsocks：选择开启，后面使用游戏加速器会用上</p> <p>选择shadowsocks端口号：随意，不要和上面v2ray一样，我选2333</p> <p>ss连接密码：123456</p> <p>ss加密协议：选择默认</p> <p>然后继续回车，直到安装完毕</p> <p>开启BBR加速：google BBR是一款免费开源的TCP拥塞控制传输协议，可以使linux服务器显著提高吞吐量和减少TCP连接的延迟</p> <p>修改系统变量</p> <div class="language-linux extra-class"><pre class="language-text"><code>echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf
echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt;/etc/sysctl.conf
</code></pre></div><p>保存生效</p> <div class="language-linux extra-class"><pre class="language-text"><code>sysctl -p
</code></pre></div><p>检查BBR是否开启</p> <div class="language-linux extra-class"><pre class="language-text"><code>sysctl net.ipv4.tcp_available_congestion_control
</code></pre></div><p>返回变量==bbr则说明开启成功</p> <p>检查BBR是否启动成功</p> <div class="language-linux extra-class"><pre class="language-text"><code>lsmod | grep bbr
</code></pre></div><p>如果返回tcp_bar 20480说明启动成功</p> <h3 id="客户端使用"><a href="#客户端使用" class="header-anchor">#</a> 客户端使用</h3> <p>windows客户端使用v2rayN</p> <p>​       在服务器端输入v2ray url，复制vmess链接</p> <p>​      下载v2rayN软件，打开软件点击服务器，点击从剪贴板批量导入url</p> <p>​      右键点击刚刚导入的服务器，测试服务器延迟，表示连接成功</p> <p>​      在小图标点击右键，选择pcahttp代理模式，表示只有被墙的网站才会启用代理，全局模式是所有链接都走代理</p> <p>mac端使用v2rayU</p> <p>ios端使用shadowsocks扫描</p> <p>Android端使用v2rayNG</p> <p>在服务器端输入</p> <div class="language-linux extra-class"><pre class="language-text"><code>v2ray qr
</code></pre></div><p>打开二维码链接，然后在手机上下载v2rayNG，打开客户端用扫一扫扫描二维码就能添加到节点</p> <p>路由器端</p> <p>在服务器段输入</p> <div class="language-linux extra-class"><pre class="language-text"><code>v2ray url
</code></pre></div><p>复制链接，代开路由器端openwrt，勾选代理开关，点击服务器列表，在通过vmess链接添加节点处粘贴刚刚复制的链接</p> <p>然后点击账号设置，代理模式选择gtwlist模式，服务器选择刚刚添加的服务器，点击提交就完成</p> <p>https://noobyy.com/31.html</p> <h2 id="nextcloud个人网盘服务器"><a href="#nextcloud个人网盘服务器" class="header-anchor">#</a> Nextcloud个人网盘服务器</h2></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f8154061.js" defer></script><script src="/assets/js/2.4cccd600.js" defer></script><script src="/assets/js/41.ab3f4971.js" defer></script>
  </body>
</html>
