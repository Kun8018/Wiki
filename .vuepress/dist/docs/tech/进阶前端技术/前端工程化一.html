<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶（一）-前端工程化</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.88b3a504.css" as="style"><link rel="preload" href="/assets/js/app.f8154061.js" as="script"><link rel="preload" href="/assets/js/2.4cccd600.js" as="script"><link rel="preload" href="/assets/js/60.82c5f4a5.js" as="script"><link rel="prefetch" href="/assets/js/10.54f00d7a.js"><link rel="prefetch" href="/assets/js/11.3da5b74a.js"><link rel="prefetch" href="/assets/js/12.7fee73d6.js"><link rel="prefetch" href="/assets/js/13.76868392.js"><link rel="prefetch" href="/assets/js/14.73742d11.js"><link rel="prefetch" href="/assets/js/15.5f9a7bea.js"><link rel="prefetch" href="/assets/js/16.bc63dc43.js"><link rel="prefetch" href="/assets/js/17.cf9ef8d3.js"><link rel="prefetch" href="/assets/js/18.813f3d8e.js"><link rel="prefetch" href="/assets/js/19.381f5e21.js"><link rel="prefetch" href="/assets/js/20.e6f846bb.js"><link rel="prefetch" href="/assets/js/21.699eb7d8.js"><link rel="prefetch" href="/assets/js/22.9b419f3a.js"><link rel="prefetch" href="/assets/js/23.9e2fcc0f.js"><link rel="prefetch" href="/assets/js/24.c0934c78.js"><link rel="prefetch" href="/assets/js/25.4d32001d.js"><link rel="prefetch" href="/assets/js/26.6a089853.js"><link rel="prefetch" href="/assets/js/27.b32725bd.js"><link rel="prefetch" href="/assets/js/28.a7d1db61.js"><link rel="prefetch" href="/assets/js/29.ee4f84ac.js"><link rel="prefetch" href="/assets/js/3.6608d946.js"><link rel="prefetch" href="/assets/js/30.c1000c38.js"><link rel="prefetch" href="/assets/js/31.694fd1d6.js"><link rel="prefetch" href="/assets/js/32.ac026d3a.js"><link rel="prefetch" href="/assets/js/33.c8ee999f.js"><link rel="prefetch" href="/assets/js/34.6663a77a.js"><link rel="prefetch" href="/assets/js/35.da0b5d07.js"><link rel="prefetch" href="/assets/js/36.75f20762.js"><link rel="prefetch" href="/assets/js/37.df31ffd6.js"><link rel="prefetch" href="/assets/js/38.848c2684.js"><link rel="prefetch" href="/assets/js/39.9a7a0d1a.js"><link rel="prefetch" href="/assets/js/4.9660033f.js"><link rel="prefetch" href="/assets/js/40.ca8e34ae.js"><link rel="prefetch" href="/assets/js/41.ab3f4971.js"><link rel="prefetch" href="/assets/js/42.3f849176.js"><link rel="prefetch" href="/assets/js/43.9b90ce3e.js"><link rel="prefetch" href="/assets/js/44.196181d0.js"><link rel="prefetch" href="/assets/js/45.4ebcccbd.js"><link rel="prefetch" href="/assets/js/46.a68cdba9.js"><link rel="prefetch" href="/assets/js/47.d26979d7.js"><link rel="prefetch" href="/assets/js/48.f6c3543c.js"><link rel="prefetch" href="/assets/js/49.87b9dc0d.js"><link rel="prefetch" href="/assets/js/5.bbf68f26.js"><link rel="prefetch" href="/assets/js/50.0d956d0a.js"><link rel="prefetch" href="/assets/js/51.6d654f81.js"><link rel="prefetch" href="/assets/js/52.180028c6.js"><link rel="prefetch" href="/assets/js/53.688b8ed0.js"><link rel="prefetch" href="/assets/js/54.4760398b.js"><link rel="prefetch" href="/assets/js/55.79d61c82.js"><link rel="prefetch" href="/assets/js/56.22ba5d85.js"><link rel="prefetch" href="/assets/js/57.085d3e52.js"><link rel="prefetch" href="/assets/js/58.a778b7b9.js"><link rel="prefetch" href="/assets/js/59.2ea1a17d.js"><link rel="prefetch" href="/assets/js/6.690811ac.js"><link rel="prefetch" href="/assets/js/61.9851b4bf.js"><link rel="prefetch" href="/assets/js/62.e9ca8158.js"><link rel="prefetch" href="/assets/js/63.44d8baf4.js"><link rel="prefetch" href="/assets/js/64.df339ab2.js"><link rel="prefetch" href="/assets/js/65.ac505688.js"><link rel="prefetch" href="/assets/js/66.3af3b829.js"><link rel="prefetch" href="/assets/js/67.41c1aab0.js"><link rel="prefetch" href="/assets/js/68.5d9e177d.js"><link rel="prefetch" href="/assets/js/69.d3e85f6e.js"><link rel="prefetch" href="/assets/js/7.491a7910.js"><link rel="prefetch" href="/assets/js/70.4494003e.js"><link rel="prefetch" href="/assets/js/71.6e2116c7.js"><link rel="prefetch" href="/assets/js/72.49cda61b.js"><link rel="prefetch" href="/assets/js/73.e7e66ead.js"><link rel="prefetch" href="/assets/js/74.5e98329f.js"><link rel="prefetch" href="/assets/js/75.3dd401e4.js"><link rel="prefetch" href="/assets/js/76.aabec56b.js"><link rel="prefetch" href="/assets/js/77.95564de2.js"><link rel="prefetch" href="/assets/js/78.69634719.js"><link rel="prefetch" href="/assets/js/79.6fcc3d23.js"><link rel="prefetch" href="/assets/js/8.63bf7718.js"><link rel="prefetch" href="/assets/js/9.58039158.js">
    <link rel="stylesheet" href="/assets/css/0.styles.88b3a504.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>前端的基础是html、css和JavaScript，掌握这些能够实现基本的功能和整齐的样式。掌握vue或者react框架能够快速实现spa应用。</p> <p>​       对于进阶，掌握基本原理和一些动画方面的库能够更美观的进行展现，实现更炫酷的动画效果。</p> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> Webpack</h2> <p><strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的_静态模块打包工具_。当 webpack 处理应用程序时，它会在内部构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener noreferrer">依赖图(dependency graph)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p> <h3 id="webpack中的基本概念"><a href="#webpack中的基本概念" class="header-anchor">#</a> webpack中的基本概念</h3> <p>1.入口：</p> <p>__入口起点(entry point)__指示 webpack 应该使用哪个模块，来作为构建其内部 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener noreferrer">依赖图(dependency graph)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p> <p>默认值是 <code>./src/index.js</code>，但你可以通过在 <a href="https://webpack.docschina.org/configuration" target="_blank" rel="noopener noreferrer">webpack configuration<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中配置 <code>entry</code> 属性，来指定一个（或多个）不同的入口起点。</p> <p>2.输出：</p> <p>可以通过配置 <code>output</code> 选项，告知 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个 <code>entry</code> 起点，但只能指定一个 <code>output</code> 配置。</p> <p>3.loader：</p> <p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。<strong>loader</strong> 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href="https://webpack.docschina.org/concepts/modules" target="_blank" rel="noopener noreferrer">模块<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，以供应用程序使用，以及被添加到依赖图中。</p> <p>在 webpack 的配置中，<strong>loader</strong> 有两个属性：</p> <p>（1）<code>test</code> 属性，识别出哪些文件会被转换。</p> <p>（2）<code>use</code> 属性，定义出在进行转换时，应该使用哪个 loader。</p> <p>4.插件。</p> <p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p> <p>5.模式</p> <h3 id="配置的相关概念"><a href="#配置的相关概念" class="header-anchor">#</a> 配置的相关概念</h3> <p>1.解析(resolve)：能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。</p> <p>2.优化(Optimization)</p> <p>3.开发服务器(devServer)</p> <p>devServer配置跨域：</p> <p>使用http-proxy-middleware实现跨域代理</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  devServer<span class="token operator">:</span><span class="token punctuation">{</span>
    proxy<span class="token operator">:</span><span class="token punctuation">{</span>
      <span class="token string">'/api'</span><span class="token operator">:</span><span class="token punctuation">{</span>
        target<span class="token operator">:</span><span class="token string">'http://www.baidu.com'</span><span class="token punctuation">,</span>
        pathRewrite<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">'^/api'</span><span class="token operator">:</span><span class="token string">''</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//代理为域名是添加此配置才能生效</span>
        secure<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token comment">//是否支持https协议的代理</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token string">'/api2'</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token operator">...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>说明：</p> <p>'/api':捕获api的标志，如果api中有这个字符串就会匹配代理，如/api/users会代理为 http://www.baidu.com/api/users</p> <p>Target:代理的api地址，可以是域名或者ip地址</p> <p>pathRewrite：</p> <p>4.devtools：</p> <p>此选项控制是否生成，以及如何生成 source map。</p> <p>使用 <a href="https://webpack.docschina.org/plugins/source-map-dev-tool-plugin" target="_blank" rel="noopener noreferrer"><code>SourceMapDevToolPlugin</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 进行更细粒度的配置。查看 <a href="https://webpack.docschina.org/loaders/source-map-loader" target="_blank" rel="noopener noreferrer"><code>source-map-loader</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来处理已有的 source map。</p> <p>source map 是有用的调试工具，可以在报错时直接查看压缩代码对应的原始代码文件。</p> <p>常用配置</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  devServer<span class="token operator">:</span><span class="token punctuation">{</span>
     hot<span class="token operator">:</span><span class="token boolean">true</span> <span class="token comment">//热更新</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="代码分离"><a href="#代码分离" class="header-anchor">#</a> 代码分离</h3> <p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p> <p>去掉重复</p> <p>动态加载模块</p> <h3 id="tree-shaking"><a href="#tree-shaking" class="header-anchor">#</a> tree shaking</h3> <p><em>tree shaking</em> 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。</p> <h3 id="外部扩展external"><a href="#外部扩展external" class="header-anchor">#</a> 外部扩展external</h3> <p><code>externals</code> 配置选项提供了「从输出的 bundle 中排除依赖」的方法。相反，所创建的 bundle 依赖于那些存在于用户环境(consumer's environment)中的依赖。此功能通常对 <strong>library 开发人员</strong>来说是最有用的，然而也会有各种各样的应用程序用到它。</p> <p><strong>防止</strong>将某些 <code>import</code> 的包(package)<strong>打包</strong>到 bundle 中，而是在运行时(runtime)再去从外部获取这些<em>扩展依赖(external dependencies)</em>，比如CDN的方式引入。</p> <p>比如在index.html中通过cdn的方式引入jquery而不是打包</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span>
  <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://code.jquery.com/jquery-3.1.0.js<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">integrity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>anonymous<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在webpack中配置</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  externals<span class="token operator">:</span> <span class="token punctuation">{</span>
    jquery<span class="token operator">:</span> <span class="token string">'jQuery'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这样就剥离了那些不需要改动的依赖模块，换句话，下面展示的代码还可以正常运行：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> $ <span class="token keyword">from</span> <span class="token string">'jquery'</span><span class="token punctuation">;</span>

<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.my-element'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>具有外部依赖(external dependency)的 bundle 可以在各种模块上下文(module context)中使用</p> <p>另一方面，如果你想将一个符合 CommonJS 模块化规则的类库外部化，你可以提供外联类库的类型以及类库的名称。</p> <p>如果你想将 <code>fs-extra</code> 从输出的 bundle 中剔除并在运行时中引入它，你可以如下定义：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  externals<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'fs-extra'</span><span class="token operator">:</span> <span class="token string">'commonjs2 fs-extra'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>则代码会变化为</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//import fs from 'fs-extra';</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs-extra'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="支持typescript"><a href="#支持typescript" class="header-anchor">#</a> 支持typescript</h3> <p>首先，执行以下命令安装 TypeScript compiler 和 loader：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">npm</span> <span class="token function">install</span> --save-dev typescript ts-loader
</code></pre></div><p>在webpack.config.js中配置</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/index.ts'</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.tsx?$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token string">'ts-loader'</span><span class="token punctuation">,</span>
        exclude<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  resolve<span class="token operator">:</span> <span class="token punctuation">{</span>
    extensions<span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">'.tsx'</span><span class="token punctuation">,</span> <span class="token string">'.ts'</span><span class="token punctuation">,</span> <span class="token string">'.js'</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="创建插件"><a href="#创建插件" class="header-anchor">#</a> 创建插件</h3> <p>一个webpack的插件有五部分构成：</p> <p>1.一个JavaScript的命名函数；</p> <p>2.在该函数上定义apply方法；</p> <p>3.指定一个绑定到 webpack 自身的事件钩子。</p> <p>4.处理 webpack 内部实例的特定数据。</p> <p>5.功能完成后调用 webpack 提供的回调。</p> <p>因此，一个最简单的插件可以写为</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 一个 JavaScript 命名函数。</span>
<span class="token keyword">function</span> <span class="token function">MyExampleWebpackPlugin</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 使用 options 设置插件实例……</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 在插件函数的 prototype 上定义一个 `apply` 方法。</span>
<span class="token class-name">MyExampleWebpackPlugin</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">apply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 指定一个挂载到 webpack 自身的事件钩子。</span>
  compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'webpacksEventHook'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>compilation <span class="token comment">/* 处理 webpack 内部实例的特定数据。*/</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;This is an example plugin!!!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 功能完成后调用 webpack 提供的回调。</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//ES6 写法</span>
<span class="token keyword">class</span> <span class="token class-name">BasicPlugin</span><span class="token punctuation">{</span>
  <span class="token comment">// 在构造函数中获取用户给该插件传入的配置</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'compilation'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">compilation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 导出 Plugin</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> BasicPlugin<span class="token punctuation">;</span>
</code></pre></div><p>具体解释如下：</p> <p><code>compiler</code> 对象代表了完整的 webpack 环境配置，负责文件的监听和启动编译，全局只有一个compiler对象。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</p> <p><code>compilation</code> 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p> <p>插件是由「具有 <code>apply</code> 方法的 prototype 对象」所实例化出来的。这个 <code>apply</code> 方法在安装插件时，会被 webpack compiler 调用一次。<code>apply</code> 方法可以接收一个 webpack compiler 对象的引用，从而可以在回调函数中访问到 compiler 对象。</p> <p>使用 compiler 对象时，你可以绑定提供了编译 compilation 引用的回调函数，然后拿到每次新的 compilation 对象。这些 compilation 对象提供了一些钩子函数，来钩入到构建流程的很多步骤中。</p> <p>上述插件在Webpack 启动后，在读取配置的过程中会先执行 <code>new BasicPlugin(options)</code> 初始化一个 BasicPlugin 获得其实例。 在初始化 compiler 对象后，再调用 <code>basicPlugin.apply(compiler)</code> 给插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 <code>compiler.plugin(事件名称, 回调函数)</code> 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。</p> <p>有一些编译插件中的步骤是异步的，这样就需要额外传入一个 callback 回调函数，并且在插件运行结束时，_必须_调用这个回调函数。</p> <p>事件流</p> <p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</p> <p>Webpack 通过 <a href="https://github.com/webpack/tapable" target="_blank" rel="noopener noreferrer">Tapable<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p> <p>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。 Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/** 广播出事件
* event-name 为事件名称，注意不要和现有的事件重名
* params 为附带的参数
*/</span>
<span class="token function">compiler</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">'event-name'</span><span class="token punctuation">,</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。
* 同时函数中的 params 参数为广播事件时附带的参数。
*/</span>
compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'event-name'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>常用api</p> <p>读取输出资源、代码块、模块及其依赖</p> <p>有些插件可能需要读取 Webpack 的处理结果，例如输出资源、代码块、模块及其依赖，以便做下一步处理。</p> <p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Plugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'emit'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// compilation.chunks 存放所有代码块，是一个数组</span>
      compilation<span class="token punctuation">.</span>chunks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// chunk 代表一个代码块</span>
        <span class="token comment">// 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块</span>
        chunk<span class="token punctuation">.</span><span class="token function">forEachModule</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// module 代表一个模块</span>
          <span class="token comment">// module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组</span>
          module<span class="token punctuation">.</span>fileDependencies<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">filepath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件</span>
        <span class="token comment">// 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时，</span>
        <span class="token comment">// 该 Chunk 就会生成 .js 和 .css 两个文件</span>
        chunk<span class="token punctuation">.</span>files<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// compilation.assets 存放当前所有即将输出的资源</span>
          <span class="token comment">// 调用一个输出资源的 source() 方法能获取到输出资源的内容</span>
          <span class="token keyword">let</span> source <span class="token operator">=</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。</span>
      <span class="token comment">// 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>监听文件变化api</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 当依赖的文件发生变化时会触发 watch-run 事件</span>
compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'watch-run'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">watching<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取发生变化的文件列表</span>
    <span class="token keyword">const</span> changedFiles <span class="token operator">=</span> watching<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span>watchFileSystem<span class="token punctuation">.</span>watcher<span class="token punctuation">.</span>mtimes<span class="token punctuation">;</span>
    <span class="token comment">// changedFiles 格式为键值对，键为发生变化的文件路径。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>changedFiles<span class="token punctuation">[</span>filePath<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// filePath 对应的文件发生了变化</span>
    <span class="token punctuation">}</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。 由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。 为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'after-compile'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译</span>
    compilation<span class="token punctuation">.</span>fileDependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>判断当前使用了哪些插件</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 判断当前配置使用使用了 ExtractTextPlugin，</span>
<span class="token comment">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数</span>
<span class="token keyword">function</span> <span class="token function">hasExtractTextPlugin</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当前配置所有使用的插件列表</span>
  <span class="token keyword">const</span> plugins <span class="token operator">=</span> compiler<span class="token punctuation">.</span>options<span class="token punctuation">.</span>plugins<span class="token punctuation">;</span>
  <span class="token comment">// 去 plugins 中寻找有没有 ExtractTextPlugin 的实例</span>
  <span class="token keyword">return</span> plugins<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">plugin</span><span class="token operator">=&gt;</span>plugin<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> ExtractTextPlugin<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>修改输出资源</p> <p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 <code>emit</code> 事件，因为发生 <code>emit</code> 事件时所有模块的转换和代码块对应的文件已经生成好， 需要输出的资源即将输出，因此 <code>emit</code> 事件是修改 Webpack 输出资源的最后时机。</p> <p>所有需要输出的资源会存放在 <code>compilation.assets</code> 中，<code>compilation.assets</code> 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'emit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 设置名称为 fileName 的输出资源</span>
  compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>fileName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 返回文件内容</span>
    <span class="token function-variable function">source</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer</span>
      <span class="token keyword">return</span> fileContent<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 返回文件大小</span>
      <span class="token function-variable function">size</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Buffer<span class="token punctuation">.</span><span class="token function">byteLength</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="创建脚手架"><a href="#创建脚手架" class="header-anchor">#</a> 创建脚手架</h3> <h3 id="webpack多入口配置"><a href="#webpack多入口配置" class="header-anchor">#</a> webpack多入口配置</h3> <p>通常使用webpack来打包单页应用，这个时候只需要配置一个入口文件，但是有时候会出现需要打包多个页面的项目，比如项目比较大或者项目需要多次的更新迭代时，都适合做成多页面程序；</p> <p>又或者，公司经常开发一些活动页，几个活动页毫不相关，页面之间也没有共享的数据，但是页面都是用相同的react框架，使用相同的弹框组件，在这种情景下就需要webpack进行多页面打包。</p> <p>这样既保留了单页应用的开发习惯，可以把每个页面看成单独的应用，又可以独立部署，解耦项目的复杂性，甚至可以在不同的页面选择不同的技术栈。</p> <p>可以把多页面应用看成乞丐版的前端微服务。</p> <p>手动配置</p> <p>配置多个入口文件和htmlwebpackplugin</p> <p>单页面</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token string">'page1'</span><span class="token operator">:</span><span class="token string">'./src/page/page1.js'</span><span class="token punctuation">,</span> <span class="token comment">//页面1</span>
  <span class="token punctuation">}</span>，
  output<span class="token operator">:</span><span class="token punctuation">{</span>
     path<span class="token operator">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>_dirname<span class="token punctuation">,</span><span class="token string">'./dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     filename<span class="token operator">:</span><span class="token string">'js/[name]/[name]-bundle.js'</span><span class="token punctuation">,</span> <span class="token comment">//filename不能写死，通过name获取bundle</span>
	<span class="token punctuation">}</span>，
<span class="token punctuation">}</span>
</code></pre></div><p>多页面</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token string">'page1'</span><span class="token operator">:</span><span class="token string">'./src/page/page1.js'</span><span class="token punctuation">,</span> <span class="token comment">//页面1</span>
    <span class="token string">'page2'</span><span class="token operator">:</span><span class="token string">'./src/page/page2.js'</span>  <span class="token comment">//页面2</span>
  <span class="token punctuation">}</span>，
  output<span class="token operator">:</span><span class="token punctuation">{</span>
     path<span class="token operator">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>_dirname<span class="token punctuation">,</span><span class="token string">'./dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     filename<span class="token operator">:</span><span class="token string">'js/[name]/[name]-bundle.js'</span><span class="token punctuation">,</span> <span class="token comment">//filename不能写死，通过name获取bundle</span>
	<span class="token punctuation">}</span>，
  plugins<span class="token operator">:</span><span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span>
      <span class="token punctuation">{</span>
        template<span class="token operator">:</span> <span class="token string">'./src/pages/page1/index.html'</span><span class="token punctuation">,</span>
        chunks<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'page1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
   		<span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span>
      <span class="token punctuation">{</span>
        template<span class="token operator">:</span> <span class="token string">'./src/pages/page2/index.html'</span><span class="token punctuation">,</span>
        chunks<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'page2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
   		<span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其他细节</p> <p>1.把多个页面共用的第三方库(React、Fastclick)单独打包成一个vendor.js</p> <p>2.把多个页面共用的逻辑代码和共用的全局css(字体、icon、全局cssreset)等单独打包common.js和common.css</p> <p>3.把运行时代码单独提取出来manifest.js</p> <p>4.把每个页面自己的业务代码打包出page1.js和page1.css</p> <p>通过optimization实现</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>export <span class="token operator">=</span> <span class="token punctuation">{</span>
  optimization<span class="token operator">:</span><span class="token punctuation">{</span>
    splitChunks<span class="token operator">:</span><span class="token punctuation">{</span>
      cacheGroups<span class="token operator">:</span><span class="token punctuation">{</span>
        common<span class="token operator">:</span><span class="token punctuation">{</span>
          name<span class="token operator">:</span><span class="token string">&quot;common&quot;</span><span class="token punctuation">,</span>
          chunks<span class="token operator">:</span><span class="token string">&quot;initial&quot;</span><span class="token punctuation">,</span>
          minSize<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
          priority<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>
          minChunks<span class="token operator">:</span><span class="token number">2</span> <span class="token comment">//引用了2次才打包</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        vendor<span class="token operator">:</span><span class="token punctuation">{</span>
          name<span class="token operator">:</span><span class="token string">&quot;vendor&quot;</span><span class="token punctuation">,</span>
          test<span class="token operator">:</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\/]node_modules[\\/]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
          chunks<span class="token operator">:</span><span class="token string">&quot;initial&quot;</span><span class="token punctuation">,</span>
          priority<span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">,</span>
          minchunks<span class="token operator">:</span><span class="token number">2</span> <span class="token comment">//引用了2次才打包</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    runtimeChunk<span class="token operator">:</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'manifest'</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>动态添加</p> <p>通过glob库动态添加</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">getEntry</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  glob<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token string">'/src/js/*.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> start <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'/src/js'</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> end <span class="token operator">=</span> name<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> eArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    eArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    entry<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> eArr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> entry<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span><span class="token punctuation">{</span>
    path<span class="token operator">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>_dirname<span class="token punctuation">,</span><span class="token string">'./dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span><span class="token string">'./js/[name].[chunkhash:8].js'</span> <span class="token comment">//包名</span>
    chunkFilename<span class="token operator">:</span><span class="token string">'js/[name].[chunkhash:8].js'</span><span class="token comment">//公共块名</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  config<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    template<span class="token operator">:</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./src/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.pug</span><span class="token template-punctuation string">`</span></span>
    filename<span class="token operator">:</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.html</span><span class="token template-punctuation string">`</span></span>
    chunks<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'js'</span><span class="token punctuation">,</span>`$<span class="token punctuation">{</span>name`<span class="token punctuation">]</span><span class="token punctuation">,</span>
    minify<span class="token operator">:</span><span class="token punctuation">{</span>
      collapseWhitespace<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="webpack-的缺点"><a href="#webpack-的缺点" class="header-anchor">#</a> webpack 的缺点</h3> <h3 id="webpack优化"><a href="#webpack优化" class="header-anchor">#</a> webpack优化</h3> <p>如果你的项目很小，构建很快，其实不需要特别关注性能方面的问题。</p> <p>但是随着项目涉及到的页面越来越多，功能和业务代码也会越来越多，相应的 <code>webpack</code> 的构建时间也会越来越久，这个时候我们就不得不考虑性能优化的事情了。</p> <p>因为这个构建时间与我们的日常开发是密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率。</p> <p>试想一个场景，我们突然碰到一个紧急 <code>bug</code>，项目启动需要花费 <code>3/4</code> 分钟，改完后项目 <code>build</code> 上线也要 <code>3/4</code> 分钟，这个时候脑瓜是不是 <code>duang</code>、<code>duang</code>、<code>duang</code>...</p> <p>体积压缩</p> <p>优化构建速度</p> <p>减小搜索范围</p> <p>利用多线程、多进程打包、压缩：运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。由于 JavaScript 是单线程模型，要想发挥多核 CPU 的能力，只能通过多进程去实现，而无法通过多线程实现。<a href="https://github.com/amireh/happypack" target="_blank" rel="noopener noreferrer">HappyPack<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。</p> <p>用过 UglifyJS 的你一定会发现在构建用于开发环境的代码时很快就能完成，但在构建用于线上的代码时构建一直卡在一个时间点迟迟没有反应，其实卡住的这个时候就是在进行代码压缩。</p> <p>由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。</p> <p><a href="https://github.com/gdborton/webpack-parallel-uglify-plugin" target="_blank" rel="noopener noreferrer">ParallelUglifyPlugin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就做了这个事情。 当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。</p> <p>使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，</p> <p>开启缓存，提升二次构建的速度。</p> <p>合理使用sourcemap</p> <ul><li>使用 <code>ES6 Modules</code> 语法，以保证 <code>Tree-Shaking</code> 起作用</li></ul> <p>因为 <code>tree-shaking</code> 只对 <code>ES6 Modules</code> 静态引入生效，对于类似于 <code>CommonJs</code> 的动态引入方式是无效的</p> <ul><li>合理使用 <code>Ployfill</code></li></ul> <p>如果我们对于引入的 <code>polyfill</code> 不做处理的话，<code>Webpack</code> 会把所有的 <code>Polyfill</code> 都加载进来，导致产出文件过大。推荐使用 <code>@babel/preset-env</code> 的 <code>useBuiltIns='usage'</code> 方案，此配置项会根据浏览器的兼容性帮助我们按需引入所需的垫片；此外我们也可以使用动态 <code>polyfill</code> 服务，每次根据浏览器的 <code>User Agent</code>，下发不同的 <code>Polyfill</code>，具体可以参考 <a href="https://polyfill.io/v3/" target="_blank" rel="noopener noreferrer"><code>polyfill.io</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <ul><li>预加载资源 <code>webpackPrefetch</code></li></ul> <p>使用 <code>webpackPrefetch</code> 来提前预加载一些资源，意思就是 <strong>将来可能需要一些模块资源，在核心代码加载完成之后带宽空闲的时候再去加载需要用到的模块代码。</strong></p> <ul><li><code>icon</code> 类图片使用 <code>css Sprite</code> 来合并图片</li></ul> <p>如果 <code>icon</code> 类图片太多的话，就使用雪碧图合成一张图片，减少网络请求，或者使用字体文件。</p> <ul><li><code>html-webpack-externals-plugin</code></li></ul> <p>此插件可以将一些公用包提取出来使用 <code>cdn</code> 引入，不打入 <code>bundle</code> 中，从而减少打包文件大小，加快打包速度。</p> <ul><li>合理配置 <code>chunk</code> 的哈希值</li></ul> <p>在生产环境打包，一定要配置文件的 <code>hash</code>，这样有助于浏览器缓存我们的文件，当我们的代码文件没变化的时候，用户就只需要读取浏览器缓存的文件即可。<strong>一般来说 <code>javascript</code> 文件使用 <code>[chunkhash]</code>、<code>css</code> 文件使用 <code>[contenthash]</code>、其他资源（例如图片、字体等）使用 <code>[hash]</code>。</strong></p> <h2 id="webpack-loader"><a href="#webpack-loader" class="header-anchor">#</a> Webpack loader</h2> <h3 id="loader原理"><a href="#loader原理" class="header-anchor">#</a> loader原理</h3> <p>module 一开始构建的过程中，首先会创建一个 loaderContext 对象，它和这个 module 是一一对应的关系，而这个 module 所使用的所有 loaders 都会共享这个 loaderContext 对象，每个 loader 执行的时候上下文就是这个 loaderContext 对象</p> <p>一共有4种loader，<code>同一种类型文件被多条rules匹配</code>上的话会按以下叠加顺序处理，通过<code>enforce</code>声明类型</p> <ul><li><strong>post</strong></li> <li><strong>inline</strong></li> <li><strong>normal(AutoLoaders)(<code>默认</code>)</strong></li> <li><strong>pre(前置loader)</strong></li></ul> <p>Loader默认加载顺序
post(后置)-&gt;inline(内联)-&gt;normal(autoLoaders)-&gt;pre(前置)</p> <p>控制loader加载(require路径)</p> <h3 id="常见loader"><a href="#常见loader" class="header-anchor">#</a> 常见loader</h3> <p>file-loader</p> <p>File-loader就是在JavaScript代码里import/require一个文件时会将该文件生成到输出目录，一般是资源文件图片等</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">npm</span> <span class="token function">install</span> file-loader
</code></pre></div><p>配置</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpg|png|gif)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            loader<span class="token operator">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">,</span>
            options<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>scss-loader</p> <p>style-loader</p> <p>css-loader</p> <p>babel-loader</p> <h3 id="创建loader"><a href="#创建loader" class="header-anchor">#</a> 创建loader</h3> <p>一个<code>loader</code>可以看做是一个<code>node</code>模块，也可以看做一个<code>loader</code>就是一个函数 (loader会导出一个函数)，众所周知<code>webpack</code>只能识别<code>js</code>文件，<code>loader</code>在<code>webpack</code>中担任的角色就是翻译工作，它可以让其它非<code>js</code>的资源（source）可以在<code>webpack</code>中通过<code>loader</code>顺利加载。</p> <p>编写loader的原则：</p> <ul><li>单一职责，一个loader只做一件事</li> <li>调用方式，loader是从右向左执行，链式调用</li> <li>统一原则，loader输入和输出都字符串</li></ul> <p>loader导出尽量别使用箭头函数，loader内部属性都是靠this来获取的，如this.callback，this.sync</p> <p>一个最简单的loader代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// source 为 compiler 传递给 Loader 的一个文件的原内容</span>
  <span class="token comment">// 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换</span>
  <span class="token keyword">return</span> source<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>由于 Loader 运行在 Node.js 中，你可以调用任何 Node.js 自带的 API，或者安装第三方模块进行调用：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f8154061.js" defer></script><script src="/assets/js/2.4cccd600.js" defer></script><script src="/assets/js/60.82c5f4a5.js" defer></script>
  </body>
</html>
